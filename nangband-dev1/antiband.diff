diff [unapplied] from object.txt; a few objects to add

+N:170:Clairvoyance
+G:":d
+I:40:9:0
+W:20:0:3:500
+A:20/3
+F:TELEPATHY | EASY_KNOW

+N:633:the Planes
+G:":d
+I:40:10:0
+W:50:0:3:30000
+A:50/4
+F:SEE_INVIS | REGEN | HOLD_LIFE | RES_NEXUS | RES_DARK | 
+F:IGNORE_ACID | IGNORE_ELEC | IGNORE_FIRE | IGNORE_COLD | EASY_KNOW
+
+N:634:Resist Confusion
+G:":d
+I:40:11:0
+W:30:0:3:750
+A:40/2
+F:RES_CONFU | EASY_KNOW

diff --recursive --unified=4 angband-291/lib/edit/r_info.txt antiband/lib/edit/r_info.txt
--- angband-291/lib/edit/r_info.txt	Tue Jul 25 19:57:47 2000
+++ antiband/lib/edit/r_info.txt	Sat Nov 10 11:35:12 2001
@@ -155,9 +155,9 @@


 # Version stamp (required)

-V:2.9.1
+V:12.9.1


 ##### Non-race (contains the "player" picture) #####

@@ -949,9 +949,9 @@
 B:HIT:HURT:1d4
 B:TOUCH:POISON:2d4
 F:ONLY_GOLD | DROP_1D2 |
 F:COLD_BLOOD | BASH_DOOR |
-F:ANIMAL | IM_POIS |
+F:IM_POIS |
 F:NO_CONF | NO_SLEEP
 D:It is a pile of coins.
 
 N:73:Giant white rat
@@ -1210,9 +1210,9 @@
 B:HIT:HURT:1d6
 B:TOUCH:POISON:2d6
 F:ONLY_GOLD | DROP_60 | DROP_1D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | IM_POIS | NO_CONF | NO_SLEEP
+F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, crawling forward on thousands of tiny legs.
 
 N:96:Snaga
 G:o:U
@@ -1222,8 +1222,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_10 | 
+S:SCREAM
 D:He is one of the many weaker 'slave' orcs, often mistakenly known as a 
 D:goblin.
 
 N:97:Rattlesnake
@@ -1245,8 +1247,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_8 | 
+S:SCREAM
 D:He is often found in huge numbers in deep caves.
 
 N:99:Wood spider
 G:S:U
@@ -1512,8 +1516,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC
+S:1_IN_6 | 
+S:SCREAM
 D:He is a hardy well-weathered survivor.
 
 N:121:Bandit
 G:p:b
@@ -1856,9 +1862,8 @@
 B:HIT:HURT:2d5
 B:TOUCH:POISON:3d5
 F:ONLY_GOLD | DROP_90 | DROP_1D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, crawling forward on thousands of tiny legs.
 
 N:147:Wolf
@@ -2212,8 +2217,10 @@
 F:FRIENDS | 
 F:DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_10 | 
+S:SCREAM
 D:A hideous, smallish giant that is often found near or with orcs.
 
 N:175:Creeping mithril coins
 G:$:B
@@ -2222,9 +2229,8 @@
 B:HIT:HURT:2d5
 B:TOUCH:POISON:3d5
 F:ONLY_GOLD | DROP_90 | DROP_2D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, shambling forward on thousands of tiny legs.
 
 N:176:Illusionist
@@ -2263,8 +2269,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_6 | 
+S:SCREAM
 D:He is a large orc with powerful arms and deep black skin.
 
 N:179:Ochre jelly
 G:j:U
@@ -2418,8 +2426,10 @@
 F:RAND_25 | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_10 | 
+S:SCREAM
 D:A massive orc-like figure with black skin and powerful arms.
 
 N:191:Magic mushroom patch
 G:,:B
@@ -2481,8 +2491,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC
+S:1_IN_4 | 
+S:SCREAM
 D:He is a hideous deformed cross-breed with man and orc, combining man's 
 D:strength and cunning with orcish evil.
 
 N:196:Giant tarantula
@@ -2729,8 +2741,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | HURT_LITE
+S:1_IN_16 | 
+S:SCREAM
 D:He is green skinned and ugly.
 
 N:215:Nar, the Dwarf
 G:h:y
@@ -2865,9 +2879,9 @@
 W:18:3:0:60
 B:HIT:POISON:3d4
 B:HIT:HURT:2d3
 B:HIT:HURT:2d3
-F:CHAR_MULTI | 
+F:CHAR_MULTI | ATTR_RANDOM |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_6 | 
@@ -2898,8 +2912,10 @@
 F:MALE | 
 F:FORCE_MAXHP | FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:He is a cunning orc of power, as tall as a man, and stronger.  It fears 
 D:little.
 
 N:227:Shagrat, the Orc Captain
@@ -3250,9 +3266,9 @@
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:HURT:2d3
 B:HIT:HURT:2d3
-F:CHAR_MULTI | 
+F:CHAR_MULTI |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_5 | 
@@ -3626,8 +3642,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | HURT_LITE | HURT_ROCK
+S:1_IN_12 | 
+S:SCREAM
 D:He is a giant troll with scabrous black skin.
 
 N:279:Troll priest
 G:T:G
@@ -3733,8 +3751,10 @@
 B:HIT:HURT:3d8
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_8 | 
+S:SCREAM
 D:A giant orc-like figure with an awesomely muscled frame.
 
 N:288:White wraith
 G:W:w
@@ -3807,9 +3827,8 @@
 B:HIT:HURT:1d12
 B:HIT:HURT:1d12
 F:ONLY_GOLD | DROP_90 | DROP_2D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, slithering forward on thousands of tiny legs.
 
 N:293:Algroth
@@ -3821,8 +3840,10 @@
 B:BITE:HURT:1d6
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL
+S:1_IN_8 | 
+S:SCREAM
 D:A powerful troll form.  Venom drips from its needlelike claws.
 
 N:294:Vibration hound
 G:Z:y
@@ -3858,9 +3879,9 @@
 D:A locus of conflicting points coalesce to form the vague shape of a huge 
 D:hound.  Or is it just your imagination?
 
 N:296:Ogre mage
-G:O:r
+G:O:R
 I:110:30d12:20:40:30
 W:27:2:0:300
 B:HIT:HURT:3d8
 B:HIT:HURT:3d8
@@ -4081,8 +4102,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_COLD | HURT_LITE
+S:1_IN_8 | 
+S:SCREAM
 D:He is a white troll with powerfully clawed hands.
 
 N:310:Giant purple worm
 G:w:v
@@ -4134,9 +4157,9 @@
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
-F:CHAR_MULTI | 
+F:CHAR_MULTI | ATTR_RANDOM |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_4 | 
@@ -4449,8 +4472,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS | HURT_LITE
+S:1_IN_6 | 
+S:SCREAM
 D:He is a vicious monster, feared for his ferocity.
 
 N:335:Half-troll
 G:T:U
@@ -4464,8 +4489,10 @@
 F:FRIENDS | 
 F:ONLY_ITEM | DROP_90 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:A huge, ugly, half-human in search of plunder.
 
 N:336:Mystic
 G:p:o
@@ -4683,8 +4710,10 @@
 F:FORCE_MAXHP | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_COLD | IM_POIS | HURT_LITE
+S:1_IN_10 | 
+S:SCREAM
 D:He is a troll that reeks of brine.
 
 N:349:Fire elemental
 G:E:r
@@ -4909,8 +4938,10 @@
 B:BITE:HURT:2d3
 F:FORCE_MAXHP | OPEN_DOOR | FRIENDS | DROP_60 | 
 F:SMART | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:It is a massive intelligent troll with needle sharp fangs.
 
 N:364:Dagashi
 G:p:y
@@ -6004,9 +6035,8 @@
 I:120:16d10:20:1:0
 W:40:1:0:1500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TPORT | 
 S:S_UNDEAD
@@ -7041,9 +7071,8 @@
 I:120:48d10:20:1:0
 W:51:1:0:3000
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TPORT | 
 S:S_DEMON
@@ -7775,9 +7804,8 @@
 I:120:20d100:20:1:0
 W:71:3:0:12000
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:S_MONSTER | S_MONSTERS | S_UNDEAD | S_DRAGON | S_HI_UNDEAD |
 S:S_HI_DRAGON | S_HI_DEMON
@@ -7788,9 +7816,8 @@
 I:120:15d100:20:1:0
 W:71:3:0:10500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TELE_TO | 
 S:S_HI_DRAGON
@@ -7802,9 +7829,8 @@
 I:120:15d100:20:1:0
 W:71:3:0:10500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TELE_TO | 
 S:S_HI_UNDEAD
@@ -7929,9 +7955,8 @@
 F:UNIQUE | 
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:ONLY_ITEM | DROP_4D2 | 
 F:INVISIBLE | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BRAIN_SMASH | 
 S:S_HI_UNDEAD | S_HI_DRAGON | S_HI_DEMON
@@ -7946,9 +7971,8 @@
 F:UNIQUE | 
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:ONLY_ITEM | DROP_4D2 | 
 F:INVISIBLE | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_1 | 
 S:S_MONSTER | S_MONSTERS | S_UNDEAD | S_DEMON | S_DRAGON | S_ANGEL | 
 S:S_HYDRA | S_SPIDER | S_ANT | S_HOUND | S_UNIQUE | S_WRAITH | 
@@ -8250,4 +8274,128 @@
 D:two remaining Silmarils forever burning him.  Grond, the mighty Hammer of 
 D:the Underworld, cries defiance as he strides towards you to crush you to a 
 D:pulp!
 
+N:548:Mimic (chest)
+G:~:s
+I:120:20d80:30:90:5
+W:35:3:0:600
+B:HIT:POISON:8d6
+B:HIT:POISON:8d6
+B:TOUCH:PARALYZE:6d4
+B:TOUCH:PARALYZE:6d4
+F:CHAR_MULTI | 
+F:FORCE_SLEEP | NEVER_MOVE | 
+F:EMPTY_MIND | COLD_BLOOD | 
+F:DROP_2D2 | 
+F:SMART | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_4 | 
+S:BLIND | CONF | BRAIN_SMASH | TELE_TO
+D:A strange creature that disguises itself as discarded objects to lure 
+D:unsuspecting adventurers within reach of its venomous claws.
+
+N:549:Animated armor
+G:[:W
+I:100:60d20:10:150:20
+W:28:4:0:500
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+F:EMPTY_MIND | COLD_BLOOD | BASH_DOOR | 
+F:IM_FIRE | IM_COLD | IM_ELEC | IM_POIS | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+D:It is a huge suit of armor animated by magic.
+
+N:550:Neeker-breeker
+G:I:v
+I:110:1d1:5:0:20
+W:2:6:0:1
+F:WEIRD_MIND | COLD_BLOOD |
+F:MULTIPLY | NO_FEAR | RAND_25 | RAND_50
+S:1_IN_10 |
+S:CONF
+D:You never thought such a small insect could make such noise.
+
+N:551:Psychic quylthulg
+G:Q:v
+I:110:13d10:10:1:0
+W:35:2:0:360
+F:FORCE_SLEEP | NEVER_MOVE | NEVER_BLOW | 
+F:INVISIBLE | WEIRD_MIND | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_1 | 
+S:BLINK | TPORT | BRAIN_SMASH | FORGET | DRAIN_MANA
+D:It is a strange brain-like pulsing mound of flesh.
+
+N:552:Chaos quylthulg
+G:Q:v
+I:120:24d10:20:1:0
+W:45:2:0:1500
+F:ATTR_MULTI | 
+F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
+F:INVISIBLE | EMPTY_MIND | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_2 | 
+S:BLINK | TPORT | BR_CHAO
+D:It is a pulsing flesh mound that changes form as you watch.
+
+N:553:Fire ogre
+G:O:r
+I:110:30d12:20:33:30
+W:28:1:0:70
+B:HIT:FIRE:3d10
+B:HIT:FIRE:3d10
+F:FRIENDS | DROP_60 | 
+F:OPEN_DOOR | BASH_DOOR | 
+F:EVIL | GIANT | IM_FIRE
+S:1_IN_8 | 
+S:SCREAM
+D:A huge ogre covered in dark red fur.
+
+N:554:Faerie dragon
+G:d:v
+I:110:8d10:20:25:15
+W:8:2:0:30
+B:BITE:HURT:1d5
+F:FORCE_MAXHP | FORCE_SLEEP | 
+F:ONLY_GOLD | DROP_90 | 
+F:OPEN_DOOR | BASH_DOOR | 
+F:DRAGON
+S:1_IN_8 | 
+S:BR_LITE | 
+S:HASTE | BLINK | BLIND | CONF | DARKNESS
+D:This tiny dragon appears and disappears in great agitation.
+
+N:555:Quickling
+G:h:W
+I:130:4d6:16:5:3
+W:5:3:0:15
+B:HIT:HURT:1d2
+F:MALE | 
+F:ONLY_GOLD | DROP_90 | 
+F:OPEN_DOOR
+S:1_IN_4 | 
+S:ARROW_1 | MISSILE | BLINK
+D:A tiny elf-like figure moving incredibly quickly.
+
+N:556:Giant slime mold
+G:,:g
+I:100:2d10:5:3:20
+W:1:1:0:2
+B:HIT:HURT:1d4
+B:TOUCH:ACID:1d2
+F:EMPTY_MIND | BASH_DOOR | 
+F:ANIMAL
+D:A giant green blob searching mindlessly for food.
+
+N:557:Carnivorous slime mold
+G:,:y
+I:100:3d8:5:8:20
+W:2:1:0:3
+B:HIT:HURT:1d4
+B:HIT:HURT:1d4
+B:TOUCH:ACID:1d3
+F:EMPTY_MIND | BASH_DOOR | 
+F:ANIMAL
+D:A giant yellow blob searching mindlessly for food.

diff --recursive --unified=4 angband-291/src/cmd2.c antiband/src/cmd2.c
--- angband-291/src/cmd2.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd2.c	Sun Nov  4 12:43:44 2001
@@ -234,9 +234,9 @@
 		/* Otherwise drop an item */
 		else
 		{
 			/* Make an object */
-			if (!make_object(i_ptr, FALSE, FALSE)) continue;
+			if (!make_object(i_ptr, FALSE, FALSE, FALSE)) continue;
 		}

 		/* Drop it in the dungeon */
 		drop_near(i_ptr, -1, y, x);
diff --recursive --unified=4 angband-291/src/cmd5.c antiband/src/cmd5.c
--- angband-291/src/cmd5.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd5.c	Wed Oct 31 16:46:56 2001
@@ -1603,15 +1593,15 @@
 			}
 
 			case 49:
 			{
-				(void)enchant_spell(rand_int(4) + 1, rand_int(4) + 1, 0);
+				(void)enchant_spell(rand_int(4) + 1, rand_int(4) + 1, 0, FALSE);
 				break;
 			}
 
 			case 50:
 			{
-				(void)enchant_spell(0, 0, rand_int(3) + 2);
+				(void)enchant_spell(0, 0, rand_int(3) + 2, FALSE);
 				break;
 			}
 
 			case 51:
diff --recursive --unified=4 angband-291/src/cmd6.c antiband/src/cmd6.c
--- angband-291/src/cmd6.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd6.c	Thu Nov  1 22:42:28 2001
@@ -1221,36 +1223,36 @@
 
 		case SV_SCROLL_ENCHANT_ARMOR:
 		{
 			ident = TRUE;
-			if (!enchant_spell(0, 0, 1)) used_up = FALSE;
+			if (!enchant_spell(0, 0, 1, FALSE)) used_up = FALSE;
 			break;
 		}
 
 		case SV_SCROLL_ENCHANT_WEAPON_TO_HIT:
 		{
-			if (!enchant_spell(1, 0, 0)) used_up = FALSE;
+			if (!enchant_spell(1, 0, 0, FALSE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_ENCHANT_WEAPON_TO_DAM:
 		{
-			if (!enchant_spell(0, 1, 0)) used_up = FALSE;
+			if (!enchant_spell(0, 1, 0, FALSE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_STAR_ENCHANT_ARMOR:
 		{
-			if (!enchant_spell(0, 0, randint(3) + 2)) used_up = FALSE;
+			if (!enchant_spell(0, 0, randint(3) + 2, TRUE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_STAR_ENCHANT_WEAPON:
 		{
-			if (!enchant_spell(randint(3), randint(3), 0)) used_up = FALSE;
+			if (!enchant_spell(randint(3), randint(3), 0, TRUE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}

diff --recursive --unified=4 angband-291/src/externs.h antiband/src/externs.h
--- angband-291/src/externs.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/externs.h	Sun Nov  4 12:55:04 2001
@@ -477,11 +480,11 @@
 extern void object_flags(object_type *o_ptr, u32b *f1, u32b *f2, u32b *f3);
 extern void object_flags_known(object_type *o_ptr, u32b *f1, u32b *f2, u32b *f3);
 extern void object_desc(char *buf, object_type *o_ptr, int pref, int mode);
 extern void object_desc_store(char *buf, object_type *o_ptr, int pref, int mode);
-extern cptr item_activation(object_type *o_ptr);
+extern cptr item_activation(object_type *o_ptr, char *buffer);
 extern int identify_random_gen(object_type *o_ptr, cptr *info, int len);
-extern bool identify_fully_aux(object_type *o_ptr);
+extern bool identify_fully_aux(object_type *o_ptr, char *o_name);
 extern char index_to_label(int i);
 extern s16b label_to_inven(int c);
 extern s16b label_to_equip(int c);
 extern s16b wield_slot(object_type *o_ptr);
diff --recursive --unified=4 angband-291/src/files.c antiband/src/files.c
--- angband-291/src/files.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/files.c	Tue Nov 20 12:09:14 2001
@@ -1222,9 +1222,9 @@
 	char buf[160];
 
 
 	/* Upper middle */
-	col = 26;
+	col = 19;
 
 
 	/* Age */
 	Term_putstr(col, 3, -1, TERM_WHITE, "Age");
@@ -1659,8 +1659,27 @@
 				{
 					c_put_str(TERM_WHITE, "*", row, col+n);
 				}
 
+				/* Check bonus flags */
+				else if ((x == 3) && (f[set] & flag))
+				{
+					byte a;
+					char c;
+
+					if (o_ptr->pval >= 0)
+						a = TERM_L_GREEN;
+					else
+						a = TERM_RED;
+
+					if (ABS(o_ptr->pval) < 10)
+						c = '0' + ABS(o_ptr->pval);
+					else
+						c = '*';
+
+					Term_putch(row, col+n, a, c);
+				}
+
 				/* Check flags */
 				else if (f[set] & flag)
 				{
 					c_put_str(TERM_WHITE, "+", row, col+n);
@@ -1678,10 +1697,19 @@
 
 			/* Default */
 			c_put_str(TERM_SLATE, ".", row, col+n);
 
+			/* Hack - basic resists are special */
+			if ((x == 0) && (y < 4) && (f[set] & flag))
+			{
+				c_put_str(TERM_WHITE, "!", row, col+n);
+			}
+
 			/* Check flags */
-			if (f[set] & flag) c_put_str(TERM_WHITE, "+", row, col+n);
+			else if (f[set] & flag)
+			{
+				c_put_str(TERM_WHITE, "+", row, col+n);
+			}
 
 			/* Advance */
 			row++;
 		}
@@ -1776,20 +1804,24 @@
 	/* Row */
 	row = 3;
 
 	/* Column */
-	col = 42;
+	col = 35;
 
 	/* Print out the labels for the columns */
 	c_put_str(TERM_WHITE, "  Self", row-1, col+5);
 	c_put_str(TERM_WHITE, " RB", row-1, col+12);
 	c_put_str(TERM_WHITE, " CB", row-1, col+16);
 	c_put_str(TERM_WHITE, " EB", row-1, col+20);
 	c_put_str(TERM_WHITE, "  Best", row-1, col+24);
+	c_put_str(TERM_WHITE, " Limit", row-1, col+31);
 
 	/* Display the stats */
 	for (i = 0; i < A_MAX; i++)
 	{
+		int limit;
+		int bonus;
+
 		/* Reduced */
 		if (p_ptr->stat_use[i] < p_ptr->stat_top[i])
 		{
 			/* Use lowercase stat name */
@@ -1803,9 +1835,9 @@
 			put_str(stat_names[i], row+i, col);
 		}
 
 		/* Indicate natural maximum */
-		if (p_ptr->stat_max[i] == 18+100)
+		if (p_ptr->stat_max[i] == p_ptr->stat_lim[i])
 		{
 			put_str("!", row+i, col+3);
 		}
 
@@ -1828,13 +1860,23 @@
 		/* Resulting "modified" maximum value */
 		cnv_stat(p_ptr->stat_top[i], buf);
 		c_put_str(TERM_L_GREEN, buf, row+i, col+24);
 
+		/* Absolute limit */
+		if (adult_maximize)
+			bonus = rp_ptr->r_adj[i] + cp_ptr->c_adj[i];
+		else
+			bonus = 0;
+		limit = modify_stat_value(p_ptr->stat_lim[i], p_ptr->stat_add[i] + bonus);
+
+		cnv_stat(limit, buf);
+		c_put_str(TERM_L_GREEN, buf, row+i, col+31);
+
 		/* Only display stat_use if not maximal */
 		if (p_ptr->stat_use[i] < p_ptr->stat_top[i])
 		{
 			cnv_stat(p_ptr->stat_use[i], buf);
-			c_put_str(TERM_YELLOW, buf, row+i, col+31);
+			c_put_str(TERM_YELLOW, buf, row+i, col+38);
 		}
 	}
 }
 
@@ -1865,9 +1907,9 @@
 	/* Row */
 	row = 3;
 
 	/* Column */
-	col = 26;
+	col = 19;
 
 	/* Header */
 	c_put_str(TERM_WHITE, "abcdefghijkl@", row-1, col);
 
@@ -1957,9 +1999,9 @@
 		Term_putch(col, row+stat, a, c);
 	}
 
 	/* Column */
-	col = 26;
+	col = 19;
 
 	/* Footer */
 	c_put_str(TERM_WHITE, "abcdefghijkl@", row+6, col);
 
@@ -3727,8 +3817,34 @@
 	return (0);
 }
 
 
+/*
+ * Add the current character to the high score file (used by the borg to simulate
+ * a death)
+ */
+errr score_current(void)
+{
+	char buf[1024];
+	errr result;
+
+	/* Build the filename */
+	path_build(buf, 1024, ANGBAND_DIR_APEX, "scores.raw");
+
+	/* Open the high score file, for reading/writing */
+	highscore_fd = fd_open(buf, O_RDWR);
+
+	/* Get time of death */
+	(void)time(&death_time);
+
+	result = enter_score();
+
+	/* Shut the high score file */
+	fd_close(highscore_fd);
+
+	return result;
+}

diff --recursive --unified=4 angband-291/src/generate.c antiband/src/generate.c
--- angband-291/src/generate.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/generate.c	Thu Nov 15 02:19:28 2001
@@ -103,9 +103,9 @@
 /*
  * Dungeon generation values
  */
 #define DUN_ROOMS	50	/* Number of rooms to attempt */
-#define DUN_UNUSUAL	200	/* Level/chance of unusual room */
+#define DUN_UNUSUAL	150	/* Level/chance of unusual room */
 #define DUN_DEST	30	/* 1/chance of having a destroyed level */
 
 /*
  * Dungeon tunnel generation values
@@ -993,30 +993,41 @@
 
 	/* Hack -- Occasional pillar room */
 	if (rand_int(20) == 0)
 	{
-		for (y = y1; y <= y2; y += 2)
+		int pillar_p = 5 + rand_int(20);
+
+		for (y = y1 + 1; y <= y2 - 1; y++)
 		{
-			for (x = x1; x <= x2; x += 2)
+			for (x = x1 + 1; x <= x2 - 1; x++)
 			{
-				cave_set_feat(y, x, FEAT_WALL_INNER);
+				if (!cave_naked_bold(y - 1, x - 1)) continue;
+				if (!cave_naked_bold(y - 1, x)) continue;
+				if (!cave_naked_bold(y - 1, x + 1)) continue;
+				if (!cave_naked_bold(y, x - 1)) continue;
+				if (rand_int(100) < ((x == x1 + 1 || y == y1 + 1) ? pillar_p : pillar_p * 2))
+					cave_set_feat(y, x, FEAT_WALL_INNER);
 			}
 		}
 	}
 
 	/* Hack -- Occasional ragged-edge room */
-	else if (rand_int(50) == 0)
+	if (rand_int(50) == 0)
 	{
-		for (y = y1 + 2; y <= y2 - 2; y += 2)
+		for (y = y1 + 2; y <= y2 - 2; y++)
 		{
-			cave_set_feat(y, x1, FEAT_WALL_INNER);
-			cave_set_feat(y, x2, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y, x1, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y, x2, FEAT_WALL_INNER);
 		}
 
-		for (x = x1 + 2; x <= x2 - 2; x += 2)
+		for (x = x1 + 2; x <= x2 - 2; x++)
 		{
-			cave_set_feat(y1, x, FEAT_WALL_INNER);
-			cave_set_feat(y2, x, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y1, x, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y2, x, FEAT_WALL_INNER);
 		}
 	}
 }
 
@@ -1377,20 +1388,20 @@
 			break;
 		}
 
 
-		/* An inner room with a checkerboard */
+		/* An inner room with an odd layout */
 		case 4:
 		{
 			/* Open the inner room with a secret door */
 			generate_hole(y1-1, x1-1, y2+1, x2+1, FEAT_SECRET);
 
-			/* Checkerboard */
+			/* Random */
 			for (y = y1; y <= y2; y++)
 			{
 				for (x = x1; x <= x2; x++)
 				{
-					if ((x + y) & 0x01)
+					if (rand_int(100) < 40)
 					{
 						cave_set_feat(y, x, FEAT_WALL_INNER);
 					}
 				}
@@ -1500,8 +1511,25 @@
 	/* Okay */
 	return (TRUE);
 }
 
+/*
+ * Helper function for "monster nest (kennel)"
+ */
+static bool vault_aux_kennel(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require canine or hound */
+	if (!strchr("CZ", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
 
 /*
  * Helper function for "monster nest (undead)"
  */
@@ -1518,8 +1546,83 @@
 	/* Okay */
 	return (TRUE);
 }
 
+/*
+ * Helper function for "monster nest (terrarium)"
+ */
+static bool vault_aux_terrarium(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require reptile */
+	if (!strchr("JRM", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (elemental)"
+ */
+static bool vault_aux_elemental(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require elemental or vortex */
+	if (!strchr("Ev", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (hive)"
+ */
+static bool vault_aux_hive(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require insect or spider */
+	if (!strchr("FSIlcaK", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (greater dragon)"
+ */
+static bool vault_aux_greater_dragon(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require greater dragon */
+	if (!strchr("D", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
 
 /*
  * Helper function for "monster pit (orc)"
  */
@@ -1538,8 +1641,26 @@
 }
 
 
 /*
+ * Helper function for "monster pit (yeek)"
+ */
+static bool vault_aux_yeek(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "y" monsters */
+	if (!strchr("y", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+/*
  * Helper function for "monster pit (troll)"
  */
 static bool vault_aux_troll(int r_idx)
 {
@@ -1620,8 +1741,103 @@
 
 
 
 /*
+ * Helper function for "monster pit (human)"
+ */
+static bool vault_aux_human(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "p" monsters */
+	if (!strchr("p", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (mimic)"
+ */
+static bool vault_aux_mimic(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require mimic monsters */
+	if (!strchr("$?!=~[", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (ogre)"
+ */
+static bool vault_aux_ogre(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require ogre */
+	if (!strchr("O", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (chapel)"
+ */
+static bool vault_aux_chapel(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "A" monsters or priests */
+	if (!strchr("A", r_ptr->d_char) && !strstr((r_name + r_ptr->name), "riest")) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (dark elf)"
+ */
+static bool vault_aux_dark_elf(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require dark elves */
+	if (!strstr((r_name + r_ptr->name), "ark el")) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
  * Type 5 -- Monster nests
  *
  * A monster nest is a "big" room, with an "inner" room, containing
  * a "collection" of monsters of a given type strewn about the room.
@@ -1691,38 +1907,102 @@
 
 	/* Hack -- Choose a nest type */
 	tmp = randint(p_ptr->depth);
 
+	/* Sometimes boost depth */
+	while (rand_int(5) == 0)
+		tmp += randint(10);
+
+	/* Monster nest (hive) */
+	if (tmp < 10)
+	{
+		/* Describe */
+		name = "hive";
+
+		/* Restrict to insect */
+		get_mon_num_hook = vault_aux_hive;
+	}
+
 	/* Monster nest (jelly) */
-	if (tmp < 30)
+	else if (tmp < 15)
 	{
 		/* Describe */
 		name = "jelly";
 
 		/* Restrict to jelly */
 		get_mon_num_hook = vault_aux_jelly;
 	}
 
+	/* Monster nest (terrarium) */
+	else if (tmp < 20)
+	{
+		/* Describe */
+		name = "terrarium";
+
+		/* Restrict to reptiles */
+		get_mon_num_hook = vault_aux_terrarium;
+	}
+
+	/* Monster nest (mimic) */
+	else if (tmp < 25)
+	{
+		/* Message */
+		name = "mimic";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_mimic;
+	}
+	
 	/* Monster nest (animal) */
-	else if (tmp < 50)
+	else if (tmp < 35)
 	{
 		/* Describe */
 		name = "animal";
 
 		/* Restrict to animal */
 		get_mon_num_hook = vault_aux_animal;
 	}
 
+	/* Monster nest (kennel) */
+	else if (tmp < 40)
+	{
+		/* Describe */
+		name = "kennel";
+
+		/* Restrict to kennel */
+		get_mon_num_hook = vault_aux_kennel;
+	}
+
+	/* Monster nest (elemental) */
+	else if (tmp < 45)
+	{
+		/* Describe */
+		name = "elemental";
+
+		/* Restrict to elemental */
+		get_mon_num_hook = vault_aux_elemental;
+	}
+
 	/* Monster nest (undead) */
-	else
+	else if (tmp < 70)
 	{
 		/* Describe */
 		name = "undead";
 
 		/* Restrict to undead */
 		get_mon_num_hook = vault_aux_undead;
 	}
 
+	/* Monster nest (greater dragon) */
+	else
+	{
+		/* Describe */
+		name = "greater dragon";
+
+		/* Restrict to greater dragons */
+		get_mon_num_hook = vault_aux_greater_dragon;
+	}
+
 	/* Prepare allocation table */
 	get_mon_num_prep();
 
 
@@ -1756,9 +2036,9 @@
 	}
 
 
 	/* Increase the level rating */
-	rating += 10;
+	/* rating += 10; */
 
 	/* (Sometimes) Cause a "special feeling" (for "Monster Nests") */
 	if ((p_ptr->depth <= 40) &&
 	    (randint(p_ptr->depth * p_ptr->depth + 1) < 300))
@@ -1870,18 +2150,62 @@
 
 	/* Choose a pit type */
 	tmp = randint(p_ptr->depth);
 
+	/* Sometimes boost depth */
+	while (rand_int(5) == 0)
+		tmp += randint(10);
+
+	/* Yeek pit */
+	if (tmp < 3)
+	{
+		/* Message */
+		name = "yeek";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_yeek;
+	}
+
 	/* Orc pit */
-	if (tmp < 20)
+	else if (tmp < 20)
 	{
 		/* Message */
 		name = "orc";
 
 		/* Restrict monster selection */
 		get_mon_num_hook = vault_aux_orc;
 	}
 
+	/* Ogre pit */
+	else if (tmp < 25)
+	{
+		/* Message */
+		name = "ogre";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_ogre;
+	}
+
+	/* Human pit */
+	else if (tmp < 30)
+	{
+		/* Message */
+		name = "human";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_human;
+	}
+
+	/* Dark elf pit */
+	else if (tmp < 35)
+	{
+		/* Message */
+		name = "dark elf";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_dark_elf;
+	}
+
 	/* Troll pit */
 	else if (tmp < 40)
 	{
 		/* Message */
@@ -1901,9 +2225,9 @@
 		get_mon_num_hook = vault_aux_giant;
 	}
 
 	/* Dragon pit */
-	else if (tmp < 80)
+	else if (tmp < 75)
 	{
 		/* Pick dragon type */
 		switch (rand_int(6))
 		{
@@ -1992,8 +2316,18 @@
 		/* Restrict monster selection */
 		get_mon_num_hook = vault_aux_dragon;
 	}
 
+	/* Chapel */
+	else if (tmp < 80)
+	{
+		/* Message */
+		name = "chapel";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_chapel;
+	}
+
 	/* Demon pit */
 	else
 	{
 		/* Message */
@@ -2067,9 +2401,9 @@
 	}
 
 
 	/* Increase the level rating */
-	rating += 10;
+	/* rating += 10; */
 
 	/* (Sometimes) Cause a "special feeling" (for "Monster Pits") */
 	if ((p_ptr->depth <= 40) &&
 	    (randint(p_ptr->depth * p_ptr->depth + 1) < 300))
@@ -2312,9 +2646,9 @@
 		if (v_ptr->typ == 7) break;
 	}
 
 	/* Message */
-	if (cheat_room) msg_print("Lesser Vault");
+	if (cheat_room) msg_format("Lesser Vault (%s)", v_ptr->name + v_name);
 
 	/* Boost the rating */
 	rating += v_ptr->rat;
 
@@ -2348,9 +2682,9 @@
 		if (v_ptr->typ == 8) break;
 	}
 
 	/* Message */
-	if (cheat_room) msg_print("Greater Vault");
+	if (cheat_room) msg_format("Greater Vault (%s)", v_ptr->name + v_name);
 
 	/* Boost the rating */
 	rating += v_ptr->rat;
 
@@ -2728,8 +3062,10 @@
 
 	/* Restrict level */
 	if (p_ptr->depth < room[typ].level) return (FALSE);
 
+	dun->crowded = (z_info->m_max - m_max < 400);
+
 	/* Restrict "crowded" rooms */
 	if (dun->crowded && ((typ == 5) || (typ == 6))) return (FALSE);
 
 	/* Extract blocks */
@@ -2861,8 +3197,16 @@
 
 	/* Build some rooms */
 	for (i = 0; i < DUN_ROOMS; i++)
 	{
+		int unusual = DUN_UNUSUAL;
+
+		/* Generate some interesting levels */
+		if (p_ptr->depth % 7 == 0)
+			unusual = unusual * 4 / 5;
+		if (p_ptr->depth % 13 == 0)
+			unusual = unusual * 3 / 4;
+
 		/* Pick a block for the room */
 		by = rand_int(dun->row_rooms);
 		bx = rand_int(dun->col_rooms);
 
@@ -2886,27 +3230,34 @@
 			continue;
 		}
 
 		/* Attempt an "unusual" room */
-		if (rand_int(DUN_UNUSUAL) < p_ptr->depth)
+		if (rand_int(unusual) < p_ptr->depth)
 		{
 			/* Roll for room type */
 			k = rand_int(100);
 
+			/* Try to fit a greater vault on the level by placing it early */
+			if (i < 2)
+				k = rand_int(35);
+			/* Some extra-interesting levels */
+			else if (p_ptr->depth % 13 == 0)
+				k = rand_int(95 - p_ptr->depth / 13 * 5);
+
 			/* Attempt a very unusual room */
-			if (rand_int(DUN_UNUSUAL) < p_ptr->depth)
+			if (rand_int(unusual) < p_ptr->depth)
 			{
-				/* Type 8 -- Greater vault (10%) */
-				if ((k < 10) && room_build(by, bx, 8)) continue;
+				/* Type 8 -- Greater vault (15%) */
+				if ((k < 15) && room_build(by, bx, 8)) continue;
 
-				/* Type 7 -- Lesser vault (15%) */
-				if ((k < 25) && room_build(by, bx, 7)) continue;
+				/* Type 7 -- Lesser vault (20%) */
+				if ((k < 35) && room_build(by, bx, 7)) continue;
 
-				/* Type 6 -- Monster pit (15%) */
-				if ((k < 40) && room_build(by, bx, 6)) continue;
+				/* Type 6 -- Monster pit (20%) */
+				if ((k < 55) && room_build(by, bx, 6)) continue;
 
-				/* Type 5 -- Monster nest (10%) */
-				if ((k < 50) && room_build(by, bx, 5)) continue;
+				/* Type 5 -- Monster nest (15%) */
+				if ((k < 70) && room_build(by, bx, 5)) continue;
 			}
 
 			/* Type 4 -- Large room (25%) */
 			if ((k < 25) && room_build(by, bx, 4)) continue;
@@ -3026,9 +3377,9 @@
 	/* Place 3 or 4 down stairs near some walls */
 	alloc_stairs(FEAT_MORE, rand_range(3, 4), 3);
 
 	/* Place 1 or 2 up stairs near some walls */
-	alloc_stairs(FEAT_LESS, rand_range(1, 2), 3);
+	alloc_stairs(FEAT_LESS, rand_range(2, 3), 3);
 
 
 	/* Basic "amount" */
 	k = (p_ptr->depth / 3);
@@ -3447,23 +3798,23 @@
 		}
 
 
 		/* Extract the feeling */
-		if (rating > 100) feeling = 2;
-		else if (rating > 80) feeling = 3;
-		else if (rating > 60) feeling = 4;
-		else if (rating > 40) feeling = 5;
-		else if (rating > 30) feeling = 6;
-		else if (rating > 20) feeling = 7;
-		else if (rating > 10) feeling = 8;
+		if (rating > 150) feeling = 2;
+		else if (rating > 120) feeling = 3;
+		else if (rating > 90) feeling = 4;
+		else if (rating > 60) feeling = 5;
+		else if (rating > 45) feeling = 6;
+		else if (rating > 30) feeling = 7;
+		else if (rating > 15) feeling = 8;
 		else if (rating > 0) feeling = 9;
 		else feeling = 10;
 
 		/* Hack -- Have a special feeling sometimes */
 		if (good_item_flag && !adult_preserve) feeling = 1;
 
 		/* It takes 1000 game turns for "feelings" to recharge */
-		if ((turn - old_turn) < 1000) feeling = 0;
+		/* if ((turn - old_turn) < 1000) feeling = 0; */
 
 		/* Hack -- no feeling in the town */
 		if (!p_ptr->depth) feeling = 0;
 
@@ -3490,14 +3841,15 @@
 
 		/* Mega-Hack -- "auto-scum" */
 		if (auto_scum && (num < 100))
 		{
+			int req = 2 * p_ptr->depth;
+
+			if (p_ptr->depth > 20) req = p_ptr->depth + 20;
+			if (req > 90) req = 90;
+
 			/* Require "goodness" */
-			if ((feeling > 9) ||
-			    ((p_ptr->depth >= 5) && (feeling > 8)) ||
-			    ((p_ptr->depth >= 10) && (feeling > 7)) ||
-			    ((p_ptr->depth >= 20) && (feeling > 6)) ||
-			    ((p_ptr->depth >= 40) && (feeling > 5)))
+			if (rating < req)
 			{
 				/* Give message to cheaters */
 				if (cheat_room || cheat_hear ||
 				    cheat_peek || cheat_xtra)

diff --recursive --unified=4 angband-291/src/load2.c antiband/src/load2.c
--- angband-291/src/load2.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/load2.c	Fri Nov  2 12:19:32 2001
@@ -1275,8 +1322,18 @@
 	/* Read the stat info */
 	for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_max[i]);
 	for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_cur[i]);

+	/* Read stat limits */
+	if (older_than(12,9,1))
+	{
+		for (i = 0; i < A_MAX; i++) p_ptr->stat_lim[i] = 18+100;
+	}
+	else
+	{
+		for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_lim[i]);
+	}
+
 	strip_bytes(24);	/* oops */

 	rd_s32b(&p_ptr->au);

--- angband-291/src/melee2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/melee2.c	Thu Nov 15 02:26:04 2001
@@ -417,13 +417,10 @@
  * Cast a breath (or ball) attack at the player
  * Pass over any monsters that may be in the way
  * Affect grids, objects, monsters, and the player
  */
-static void breath(int m_idx, int typ, int dam_hp)
+static void breath(int m_idx, int py, int px, int typ, int dam_hp)
 {
-	int py = p_ptr->py;
-	int px = p_ptr->px;
-
 	int rad;
 
 	int flg = PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
 
@@ -437,8 +434,129 @@
 	(void)project(m_idx, rad, py, px, dam_hp, typ, flg);
 }
 
 
+static bool should_wake_friends(int who)
+{
+	int i;
+
+	/* Aggravate everyone nearby */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Skip monsters of a different race (should check 'symbol'?) */
+		if (m_ptr->r_idx != m_list[who].r_idx) continue;
+
+		/* Check for sleeping monsters in los of shouting monster */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			if (m_ptr->csleep)
+			{
+				return TRUE;
+			}
+		}
+	}
+	
+	return FALSE;
+}
+
+static bool pack_indirect_fire_okay(int who, int py, int px)
+{
+	int i;
+
+	/* If the monster has los, it can still try to hit an out-of-range player */
+	if (los(m_list[who].fy, m_list[who].fy, py, px))
+		return TRUE;
+
+	/* Check all monsters of same race */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Skip monsters of a different race (should check 'symbol'?) */
+		if (m_ptr->r_idx != m_list[who].r_idx) continue;
+
+		/* Check for monsters in los who themselves have los to the player */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			if (los(m_ptr->fy, m_ptr->fx, py, px))
+			{
+  				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+
+static bool find_indirect_fire(int who, int *py, int *px)
+{
+	int cur_r, x, y;
+	int fx = m_list[who].fx, fy = m_list[who].fy;
+	int found = 0;
+	int best_x, best_y;
+	int rad;
+
+	monster_type *m_ptr = &m_list[who];
+	monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+	/* Determine the radius of the blast */
+	rad = (r_ptr->flags2 & (RF2_POWERFUL)) ? 3 : 2;
+
+	for (cur_r = 1; cur_r <= rad; cur_r++)
+	{
+		for (y = *py - cur_r; y <= *py + cur_r; y++)
+		{
+			for (x = *px - cur_r; x <= *px + cur_r; x++)
+			{
+				if (!in_bounds(y, x) || !cave_floor_bold(y, x))
+					continue;
+
+				if (distance(*py, *px, y, x) > cur_r)
+					continue;
+
+				if (distance(fy, fx, y, x) > MAX_RANGE)
+					continue;
+
+				if (!projectable(fy, fx, y, x))
+					continue;
+
+				if (rand_int(++found) == 0)
+				{
+					best_x = x;
+					best_y = y;
+				}
+			}
+		}
+
+		if (found > 0)
+		{
+			*px = best_x;
+			*py = best_y;
+			return (TRUE);
+		}
+	}
+
+	return (FALSE);
+}
+
+
 /*
  * Offsets for the spell indices
  */
 #define RF4_OFFSET 32 * 3
@@ -594,15 +712,19 @@
 		/* Keep only the interesting spells */
 		f4 &= f4_mask;
 		f5 &= f5_mask;
 		f6 &= f6_mask;
-
-		/* Anything left? */
-		if (!(f4 || f5 || f6)) return (0);
 	}
 
 #endif /* MONSTER_AI */
 
+	/* Don't try to shout for help if there's none around */
+	if ((f4 & RF4_SCREAM) && !should_wake_friends(m_idx))
+		f4 &= ~RF4_SCREAM;
+
+	/* Anything left? */
+	if (!(f4 || f5 || f6)) return (0);
+
 	/* Extract the "innate" spells */
 	for (i = 0; i < 32; i++)
 	{
 		if (f4 & (1L << i)) spells[num++] = i + RF4_OFFSET;
@@ -755,20 +877,18 @@
 
 #endif /* MONSTER_AI */
 
 
-
 	/* Hack -- require projectable player */
 	if (normal)
 	{
 		/* Check range */
-		if (m_ptr->cdis > MAX_RANGE) return (FALSE);
+		if (m_ptr->cdis > MAX_RANGE) direct = FALSE;
 
 		/* Check path */
-		if (!projectable(m_ptr->fy, m_ptr->fx, py, px)) return (FALSE);
+		if (!projectable(m_ptr->fy, m_ptr->fx, py, px)) direct = FALSE;
 	}
 
-
 	/* Extract the monster level */
 	rlev = ((r_ptr->level >= 1) ? r_ptr->level : 1);
 
 
@@ -789,8 +909,52 @@
 	}
 
 #endif /* MONSTER_AI */
 
+
+#ifdef MONSTER_AI
+
+	if (!direct)
+	{
+#if 0
+		/* Summoners are nasty */
+		if (f4 & (RF4_SUMMON_MASK) ||
+			f5 & (RF5_SUMMON_MASK) ||
+			f6 & (RF6_SUMMON_MASK))
+		{
+			/* Only summon sometimes */
+			if (rand_int(3) != 0) return (FALSE);
+
+			/* Must be nearby */
+			if (m_ptr->cdis > r_ptr->aaf) return (FALSE);
+			if (m_ptr->cdis > MAX_RANGE) return (FALSE);
+
+			x = m_ptr->fx;
+			y = m_ptr->fy;
+		}
+#endif
+		/* Pack monsters can sometimes fire on the player indirectly */
+		if (smart_packs && (r_ptr->flags1 & RF1_GROUP_MASK) &&
+			(f4 & (RF4_INDIRECT_MASK) || 
+			 f5 & (RF5_INDIRECT_MASK) ||
+			 f6 & (RF6_INDIRECT_MASK)) && 
+			pack_indirect_fire_okay(m_idx, py, px))
+		{
+			if (!find_indirect_fire(m_idx, &py, &px)) return (FALSE);
+		}
+		else
+		{
+			return (FALSE);
+		}
+	}
+
+#else /* MONSTER_AI */
+
+	if (!direct) return (FALSE);
+
+#endif /* MONSTER_AI */
+
+
 	/* Hack -- allow "desperate" spells */
 	if ((r_ptr->flags2 & (RF2_SMART)) &&
 	    (m_ptr->hp < m_ptr->maxhp / 10) &&
 	    (rand_int(100) < 50))
@@ -804,8 +968,19 @@
 		if (!f4 && !f5 && !f6) return (FALSE);
 	}
 
 
+	/* Only allow breaths & balls to use indirect fire */
+	if (!direct)
+	{
+		f4 &= (RF4_INDIRECT_MASK) | (RF4_SUMMON_MASK);
+		f5 &= (RF5_INDIRECT_MASK) | (RF5_SUMMON_MASK);
+		f6 &= (RF6_INDIRECT_MASK) | (RF6_SUMMON_MASK);
+
+		if (!f4 && !f5 && !f6) return (FALSE);
+	}
+
+
 #ifdef DRS_SMART_OPTIONS
 
 	/* Remove the "ineffective" spells */
 	remove_bad_spells(m_idx, &f4, &f5, &f6);
@@ -895,11 +1070,14 @@
 			aggravate_monsters(m_idx);
 			break;
 		}
 
-		/* RF4_XXX2X4 */
+		/* RF4_SCREAM */
 		case RF4_OFFSET+1:
 		{
+			disturb(1, 0);
+			msg_format("%^s screams for help.", m_name);
+			wake_monsters(m_idx);
 			break;
 		}
 
 		/* RF4_XXX3X4 */
@@ -959,9 +1137,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes acid.", m_name);
-			breath(m_idx, GF_ACID,
+			breath(m_idx, py, px,  GF_ACID,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_ACID);
 			break;
 		}
@@ -971,9 +1149,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes lightning.", m_name);
-			breath(m_idx, GF_ELEC,
+			breath(m_idx, py, px, GF_ELEC,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_ELEC);
 			break;
 		}
@@ -983,9 +1161,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes fire.", m_name);
-			breath(m_idx, GF_FIRE,
+			breath(m_idx, py, px, GF_FIRE,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_FIRE);
 			break;
 		}
@@ -995,9 +1173,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes frost.", m_name);
-			breath(m_idx, GF_COLD,
+			breath(m_idx, py, px, GF_COLD,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_COLD);
 			break;
 		}
@@ -1007,9 +1185,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes gas.", m_name);
-			breath(m_idx, GF_POIS,
+			breath(m_idx, py, px, GF_POIS,
 			       ((m_ptr->hp / 3) > 800 ? 800 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_POIS);
 			break;
 		}
@@ -1019,9 +1197,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes nether.", m_name);
-			breath(m_idx, GF_NETHER,
+			breath(m_idx, py, px, GF_NETHER,
 			       ((m_ptr->hp / 6) > 550 ? 550 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_NETHR);
 			break;
 		}
@@ -1031,9 +1209,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes light.", m_name);
-			breath(m_idx, GF_LITE,
+			breath(m_idx, py, px, GF_LITE,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_LITE);
 			break;
 		}
@@ -1043,9 +1221,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes darkness.", m_name);
-			breath(m_idx, GF_DARK,
+			breath(m_idx, py, px, GF_DARK,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_DARK);
 			break;
 		}
@@ -1055,9 +1233,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes confusion.", m_name);
-			breath(m_idx, GF_CONFUSION,
+			breath(m_idx, py, px, GF_CONFUSION,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_CONFU);
 			break;
 		}
@@ -1067,9 +1245,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes sound.", m_name);
-			breath(m_idx, GF_SOUND,
+			breath(m_idx, py, px, GF_SOUND,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_SOUND);
 			break;
 		}
@@ -1079,9 +1257,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes chaos.", m_name);
-			breath(m_idx, GF_CHAOS,
+			breath(m_idx, py, px, GF_CHAOS,
 			       ((m_ptr->hp / 6) > 600 ? 600 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_CHAOS);
 			break;
 		}
@@ -1091,9 +1269,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes disenchantment.", m_name);
-			breath(m_idx, GF_DISENCHANT,
+			breath(m_idx, py, px, GF_DISENCHANT,
 			       ((m_ptr->hp / 6) > 500 ? 500 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_DISEN);
 			break;
 		}
@@ -1103,9 +1281,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes nexus.", m_name);
-			breath(m_idx, GF_NEXUS,
+			breath(m_idx, py, px, GF_NEXUS,
 			       ((m_ptr->hp / 3) > 250 ? 250 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_NEXUS);
 			break;
 		}
@@ -1115,9 +1293,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes time.", m_name);
-			breath(m_idx, GF_TIME,
+			breath(m_idx, py, px, GF_TIME,
 			       ((m_ptr->hp / 3) > 150 ? 150 : (m_ptr->hp / 3)));
 			break;
 		}
 
@@ -1126,9 +1304,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes inertia.", m_name);
-			breath(m_idx, GF_INERTIA,
+			breath(m_idx, py, px, GF_INERTIA,
 			       ((m_ptr->hp / 6) > 200 ? 200 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1137,9 +1315,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes gravity.", m_name);
-			breath(m_idx, GF_GRAVITY,
+			breath(m_idx, py, px, GF_GRAVITY,
 			       ((m_ptr->hp / 3) > 200 ? 200 : (m_ptr->hp / 3)));
 			break;
 		}
 
@@ -1148,9 +1326,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes shards.", m_name);
-			breath(m_idx, GF_SHARD,
+			breath(m_idx, py, px, GF_SHARD,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_SHARD);
 			break;
 		}
@@ -1160,9 +1338,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes plasma.", m_name);
-			breath(m_idx, GF_PLASMA,
+			breath(m_idx, py, px, GF_PLASMA,
 			       ((m_ptr->hp / 6) > 150 ? 150 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1171,9 +1349,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes force.", m_name);
-			breath(m_idx, GF_FORCE,
+			breath(m_idx, py, px, GF_FORCE,
 			       ((m_ptr->hp / 6) > 200 ? 200 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1215,9 +1393,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts an acid ball.", m_name);
-			breath(m_idx, GF_ACID,
+			breath(m_idx, py, px, GF_ACID,
 			       randint(rlev * 3) + 15);
 			update_smart_learn(m_idx, DRS_RES_ACID);
 			break;
 		}
@@ -1227,9 +1405,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a lightning ball.", m_name);
-			breath(m_idx, GF_ELEC,
+			breath(m_idx, py, px, GF_ELEC,
 			       randint(rlev * 3 / 2) + 8);
 			update_smart_learn(m_idx, DRS_RES_ELEC);
 			break;
 		}
@@ -1239,9 +1417,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a fire ball.", m_name);
-			breath(m_idx, GF_FIRE,
+			breath(m_idx, py, px, GF_FIRE,
 			       randint(rlev * 7 / 2) + 10);
 			update_smart_learn(m_idx, DRS_RES_FIRE);
 			break;
 		}
@@ -1251,9 +1429,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a frost ball.", m_name);
-			breath(m_idx, GF_COLD,
+			breath(m_idx, py, px, GF_COLD,
 			       randint(rlev * 3 / 2) + 10);
 			update_smart_learn(m_idx, DRS_RES_COLD);
 			break;
 		}
@@ -1263,9 +1441,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a stinking cloud.", m_name);
-			breath(m_idx, GF_POIS,
+			breath(m_idx, py, px, GF_POIS,
 			       damroll(12, 2));
 			update_smart_learn(m_idx, DRS_RES_POIS);
 			break;
 		}
@@ -1275,9 +1453,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a nether ball.", m_name);
-			breath(m_idx, GF_NETHER,
+			breath(m_idx, py, px, GF_NETHER,
 			       (50 + damroll(10, 10) + rlev));
 			update_smart_learn(m_idx, DRS_RES_NETHR);
 			break;
 		}
@@ -1288,9 +1466,9 @@
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s gestures fluidly.", m_name);
 			msg_print("You are engulfed in a whirlpool.");
-			breath(m_idx, GF_WATER,
+			breath(m_idx, py, px, GF_WATER,
 			       randint(rlev * 5 / 2) + 50);
 			break;
 		}
 
@@ -1299,9 +1477,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles powerfully.", m_name);
 			else msg_format("%^s invokes a mana storm.", m_name);
-			breath(m_idx, GF_MANA,
+			breath(m_idx, py, px, GF_MANA,
 			       (rlev * 5) + damroll(10, 10));
 			break;
 		}
 
@@ -1310,9 +1488,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles powerfully.", m_name);
 			else msg_format("%^s invokes a darkness storm.", m_name);
-			breath(m_idx, GF_DARK,
+			breath(m_idx, py, px, GF_DARK,
 			       (rlev * 5) + damroll(10, 10));
 			update_smart_learn(m_idx, DRS_RES_DARK);
 			break;
 		}
@@ -1793,8 +1971,10 @@
 
 		/* RF6_HEAL */
 		case RF6_OFFSET+2:
 		{
+			int healing;
+
 			disturb(1, 0);
 
 			/* Message */
 			if (blind)
@@ -1806,9 +1986,12 @@
 				msg_format("%^s concentrates on %s wounds.", m_name, m_poss);
 			}
 
 			/* Heal some */
-			m_ptr->hp += (rlev * 6);
+			healing = m_ptr->maxhp * randint(10) / 15;
+			if (healing > rlev * 6) healing = rlev * 6;
+			if (healing < rlev) healing = rlev;
+			m_ptr->hp += healing;
 
 			/* Fully healed */
 			if (m_ptr->hp >= m_ptr->maxhp)
 			{
@@ -2941,8 +3124,9 @@
 
 
 #ifdef MONSTER_AI
 
+#if 0
 	/* Normal animal packs try to get the player out of corridors. */
 	if (smart_packs &&
 	    (r_ptr->flags1 & RF1_FRIENDS) && (r_ptr->flags3 & RF3_ANIMAL) &&
 	    !((r_ptr->flags2 & (RF2_PASS_WALL)) || (r_ptr->flags2 & (RF2_KILL_WALL))))
@@ -2966,8 +3150,9 @@
 			/* Find hiding place */
 			if (find_hiding(m_idx, &y, &x)) done = TRUE;
 		}
 	}
+#endif
 
 #endif /* MONSTER_AI */
 
 	/* Apply fear */
@@ -3002,39 +3187,73 @@
 
 #ifdef MONSTER_AI
 
 	/* Monster groups try to surround the player */
-	if (!done && smart_packs && (r_ptr->flags1 & RF1_FRIENDS))
+	if (!done && smart_packs && (r_ptr->flags1 & RF1_GROUP_MASK))
 	{
-		int i;
+		int i, i2;
+		int tx, ty, tx2, ty2;
+ 		int count = 0, count2;
+		int found = 0;
 
-		/* Find an empty square near the player to fill */
+		/* Count monsters near current position */
 		for (i = 0; i < 8; i++)
 		{
-			/* Pick squares near player (semi-randomly) */
-			y2 = py + ddy_ddd[(m_idx + i) & 7];
-			x2 = px + ddx_ddd[(m_idx + i) & 7];
+			tx = m_ptr->fx + ddx_ddd[i];
+			ty = m_ptr->fy + ddy_ddd[i];
+
+			if (tx == px && ty == py)
+				continue;
 
-			/* Already there? */
-			if ((m_ptr->fy == y2) && (m_ptr->fx == x2))
+			if (cave_m_idx[ty][tx])
 			{
-				/* Attack the player */
-				y2 = py;
-				x2 = px;
+				bool blocked = TRUE;
 
-				break;
-			}
+				/* Check if this monster can reach the player easily */
+				for (i2 = 0; i2 < 8; i2++)
+				{
+					tx2 = tx + ddx_ddd[i2];
+					ty2 = ty + ddy_ddd[i2];
 
-			/* Ignore filled grids */
-			if (!cave_empty_bold(y2, x2)) continue;
+					if (!cave_empty_bold(ty2, tx2))
+						continue;
 
-			/* Try to fill this hole */
-			break;
+					if (ABS(tx2 - px) > 1 || ABS(ty2 - py) > 1)
+						continue;
+
+					blocked = FALSE;
+					break;
+				}
+
+				if (blocked)
+					count++;
+			}
 		}
 
-		/* Extract the new "pseudo-direction" */
-		y = m_ptr->fy - y2;
-		x = m_ptr->fx - x2;
+		if (count)
+		{
+			/* Check options */
+			for (i = 0; i < 8; i++)
+			{
+				tx = m_ptr->fx + ddx_ddd[i];
+				ty = m_ptr->fy + ddy_ddd[i];
+
+				if (tx == px && ty == py)
+					continue;
+
+				if (!cave_empty_bold(ty, tx))
+					continue;
+
+				if (ABS(tx - px) > 1 || ABS(ty - py) > 1)
+					continue;
+
+				if (rand_int(++found) == 0)
+				{
+					y = -ddy_ddd[i];
+					x = -ddx_ddd[i];
+				}
+			}
+		}
 
 		/* Done */
 		done = TRUE;
 	}
diff --recursive --unified=4 angband-291/src/monster2.c antiband/src/monster2.c
--- angband-291/src/monster2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/monster2.c	Thu Nov 15 01:43:34 2001
@@ -415,22 +415,30 @@
 		/* Occasional "nasty" monster */
 		if (rand_int(NASTY_MON) == 0)
 		{
 			/* Pick a level bonus */
-			int d = level / 4 + 2;
+			int d = randint(level / 2 + 3);
+
+			/* Reduce very dangerous monsters a bit */
+			while (d > 5 && rand_int(3) != 0)
+				d--;
 
 			/* Boost the level */
-			level += ((d < 5) ? d : 5);
+			level += d;
 		}
 
 		/* Occasional "nasty" monster */
 		if (rand_int(NASTY_MON) == 0)
 		{
 			/* Pick a level bonus */
-			int d = level / 4 + 2;
+			int d = randint(level / 2 + 3);
+
+			/* Reduce very dangerous monsters a bit */
+			while (d > 5 && rand_int(3) != 0)
+				d--;
 
 			/* Boost the level */
-			level += ((d < 5) ? d : 5);
+			level += d;
 		}
 	}
 
 
@@ -2025,9 +2033,9 @@
 	/* Look for a location */
 	for (i = 0; i < 20; ++i)
 	{
 		/* Pick a distance */
-		int d = (i / 15) + 1;
+		int d = (i / 3) + 3;
 
 		/* Pick a location */
 		scatter(&y, &x, y1, x1, d, 0);
 
diff --recursive --unified=4 angband-291/src/object1.c antiband/src/object1.c
--- angband-291/src/object1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/object1.c	Thu Nov 15 02:17:00 2001


+/*
+ * Fill an array with a description of the item flags.
+ *
+ * "info" must point to a cptr array that is big enough to store all
+ * descriptions.
+ *
+ * Returns the number of lines.
+ *
+ * ToDo: Check the len of the array to prevent buffer overflows
+ * (yes, this is paranoid).
+ *
+ * ToDo: Allow dynamic generation of strings.
+ */
+static bool identify_fully_aux2(object_type *o_ptr, int mode)
+{
+	char buffer[80];
+
+	u32b f1, f2, f3;
+
+	int i;
+
+	int vn;
+	cptr vp[64];
+
+	bool worked = FALSE;
+	bool f;
+	bool has_brand = FALSE;
+	bool has_slay = FALSE;
+
+	/* Calculate average damage */
+	if ((p_ptr->pclass == CLASS_WARRIOR || p_ptr->wizard) &&
+		wield_slot(o_ptr) == INVEN_WIELD)
+	{
+		int dam2;
+
+		dam2 = o_ptr->dd * (o_ptr->ds + 1);
+		if (o_ptr->ident & (IDENT_KNOWN))
+			dam2 += 2 * o_ptr->to_d;
+		if (has_brand)
+			dam2 = dam2 * 3 / 2;
+		dam2 += 2 * p_ptr->to_d;
+
+		roff(format("It does about %i damage on an average hit against ", dam2 / 2));
+		if (has_slay || has_brand)
+			roff("most monsters.  ");
+		else
+			roff("all monsters.  ");
+
+		worked = TRUE;
+	}
+	/* Hack - determine type of ammo needed */
+	if ((p_ptr->pclass == CLASS_RANGER || p_ptr->wizard) &&
+		inventory[INVEN_BOW].number &&
+		o_ptr->tval == TV_SHOT + inventory[INVEN_BOW].sval / 10)
+	{
+		int dam2;
+
+		dam2 = o_ptr->dd * (o_ptr->ds + 1);
+		if (o_ptr->ident & (IDENT_KNOWN))
+			dam2 += 2 * o_ptr->to_d;
+		if (inventory[INVEN_BOW].ident & (IDENT_KNOWN))
+			dam2 += 2 * inventory[INVEN_BOW].to_d;
+
+		roff(format("It does about %i damage with your current missile weapon ", dam2 / 2));
+		if (has_slay || has_brand)
+			roff("on an average shot against most monsters.  ");
+		else
+			roff("on an average shot against all monsters.  ");
+
+		worked = TRUE;
+	}
+
+
+	/* Collect sustains */
+	vn = 0;
+	if (f2 & (TR2_SUST_STR)) vp[vn++] = "strength";
+	if (f2 & (TR2_SUST_INT)) vp[vn++] = "intelligence";
+	if (f2 & (TR2_SUST_WIS)) vp[vn++] = "wisdom";
+	if (f2 & (TR2_SUST_DEX)) vp[vn++] = "dexterity";
+	if (f2 & (TR2_SUST_CON)) vp[vn++] = "constitution";
+	if (f2 & (TR2_SUST_CHR)) vp[vn++] = "charisma";
+	/* Hack - shorten to "all stats" if appropriate */
+	if (vn == 6)
+		roff("It sustains all your stats.  ");
+	else if (vn > 0)
+	{
+		roff("It sustains your ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+

+	/* Collect minor powers */
+	vn = 0;
+	if (f3 & (TR3_SLOW_DIGEST)) vp[vn++] = "slows your metabolism";
+	if (f3 & (TR3_FEATHER))     vp[vn++] = "induces feather falling";
+	if (f3 & (TR3_LITE))        vp[vn++] = "provides permanent light";
+	if (f3 & (TR3_REGEN))       vp[vn++] = "speeds your regenerative powers";
+	if (f3 & (TR3_TELEPATHY))   vp[vn++] = "gives telepathic powers";
+	if (f3 & (TR3_SEE_INVIS))   vp[vn++] = "allows you to see invisible monsters";
+	if (f3 & (TR3_FREE_ACT))    vp[vn++] = "provides immunity to paralysis";
+	if (f3 & (TR3_HOLD_LIFE))   vp[vn++] = "provides resistance to life draining";
+	if (vn > 0)
+	{
+		roff("It ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	/* Collect curses */
+	vn = 0;
+	if (f3 & (TR3_TELEPORT))  vp[vn++] = "induces random teleportation";
+	if (f3 & (TR3_AGGRAVATE)) vp[vn++] = "aggravates nearby creatures";
+	if (f3 & (TR3_DRAIN_EXP)) vp[vn++] = "drains experience";
+
+	if (vn > 0)
+	{
+		roff("It ");
+
+		for (i = 0; i < vn; i++)
 		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
 		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	if (f3 & (TR3_BLESSED))
+	{
+		roff("It has been blessed by the gods.  ");
+		worked = TRUE;
+	}
+
+	if (object_known_p(o_ptr) && cursed_p(o_ptr))
+	{
+		if (f3 & (TR3_PERMA_CURSE))
+			roff("It is permanently cursed.  ");
+		else if (f3 & (TR3_HEAVY_CURSE))
+			roff("It is heavily cursed.  ");
+		else
+			roff("It is cursed.  ");
+		worked = TRUE;
+	}
+
+	/* Collect immunities */
+	vn = 0;
+	if (f3 & (TR3_IGNORE_ACID)) vp[vn++] = "acid";
+	if (f3 & (TR3_IGNORE_ELEC)) vp[vn++] = "electricity";
+	if (f3 & (TR3_IGNORE_FIRE)) vp[vn++] = "fire";
+	if (f3 & (TR3_IGNORE_COLD)) vp[vn++] = "cold";
+	/* Hack - shorten to "the elements" if appropriate */
+	if (vn == 4)
+	{
+		vn = 0;
+		vp[vn++] = "the elements";
+	}
+
+	if (object_known_p(o_ptr) && artifact_p(o_ptr))
+	{
+		roff("It is an artifact.  ");
+		worked = TRUE;
+	}
+	else if (vn > 0)
+	{
+		roff("It cannot be harmed by ");
+
+		for (i = 0; i < vn; i++)
 		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" or ");
 		}
+
+		roff(".  ");
+		worked = TRUE;
 	}
 
+	if (p_ptr->pclass == CLASS_ROGUE || p_ptr->wizard)
+	{
+		s32b value = object_value(o_ptr);

+		if (value > 0)
+			roff(format("It is worth about %i gold.  ", value));
+		else
+			roff("It is worthless.  ");
+
+		worked = TRUE;
+	}
+
+	if (p_ptr->wizard && object_known_p(o_ptr) && (o_ptr->ident & IDENT_MENTAL) && o_ptr->name3)
+	{
+		roff(format("Current power is %i.  ", artifact_power(o_ptr)));
+		worked = TRUE;
+	}
+
+	/* Unknown extra powers (ego-item with random extras or artifact) */
+	if (object_known_p(o_ptr) &&
+		(!(o_ptr->ident & IDENT_MENTAL)) &&
+	    ((o_ptr->xtra1) || artifact_p(o_ptr)))
+	{
+		roff("It has hidden powers.  ");
+		worked = TRUE;
+	}
+
+	/* All done */
+	roff("\n");
+
+
+	/* Return the number of lines */
+	return (worked);
 }

+/* XXX XXX XXX Hack */
+static char id_aux3_buffer[80];

+static bool identify_fully_aux3(object_type *o_ptr, int mode, cptr *info, int len)
 {
 	int i = 0;

 	u32b f1, f2, f3;

diff --recursive --unified=4 angband-291/src/save.c antiband/src/save.c
--- angband-291/src/save.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/save.c	Thu Nov  1 23:23:32 2001
@@ -1030,8 +1060,9 @@
 
 	/* Dump the stats (maximum and current) */
 	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_max[i]);
 	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_cur[i]);
+	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_lim[i]);
 
 	/* Ignore the transient stats */
 	for (i = 0; i < 12; ++i) wr_s16b(0);

diff --recursive --unified=4 angband-291/src/spells1.c antiband/src/spells1.c
--- angband-291/src/spells1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/spells1.c	Thu Nov 15 01:43:34 2001
@@ -950,9 +954,9 @@
 	/* Then augment the current/max stat */
 	value = p_ptr->stat_cur[stat];
 
 	/* Cannot go above 18/100 */
-	if (value < 18+100)
+	if (value < p_ptr->stat_lim[stat])
 	{
 		/* Gain one (sometimes two) points */
 		if (value < 18)
 		{
@@ -960,21 +964,21 @@
 			value += gain;
 		}
 
 		/* Gain 1/6 to 1/3 of distance to 18/100 */
-		else if (value < 18+98)
+		else if (value < p_ptr->stat_lim[stat] - 2)
 		{
 			/* Approximate gain value */
-			gain = (((18+100) - value) / 2 + 3) / 2;
+			gain = ((p_ptr->stat_lim[stat] - value) / 2 + 3) / 2;
 
 			/* Paranoia */
 			if (gain < 1) gain = 1;
 
 			/* Apply the bonus */
 			value += randint(gain) + gain / 2;
 
 			/* Maximal value */
-			if (value > 18+99) value = 18 + 99;
+			if (value > p_ptr->stat_lim[stat] - 1) value = p_ptr->stat_lim[stat] - 1;
 		}
 
 		/* Gain one point at a time */
 		else
@@ -1241,9 +1245,9 @@
  * Apply Nexus
  */
 static void apply_nexus(monster_type *m_ptr)
 {
-	int max1, cur1, max2, cur2, ii, jj;
+	int max1, cur1, max2, cur2, lim1, lim2, ii, jj;
 
 	switch (randint(7))
 	{
 		case 1: case 2: case 3:
@@ -1286,15 +1290,19 @@
 			for (jj = ii; jj == ii; jj = rand_int(6)) /* loop */;
 
 			max1 = p_ptr->stat_max[ii];
 			cur1 = p_ptr->stat_cur[ii];
+			lim1 = p_ptr->stat_lim[ii];
 			max2 = p_ptr->stat_max[jj];
 			cur2 = p_ptr->stat_cur[jj];
+			lim2 = p_ptr->stat_lim[jj];
 
 			p_ptr->stat_max[ii] = max2;
 			p_ptr->stat_cur[ii] = cur2;
+			p_ptr->stat_lim[ii] = lim2;
 			p_ptr->stat_max[jj] = max1;
 			p_ptr->stat_cur[jj] = cur1;
+			p_ptr->stat_lim[jj] = lim1;
 
 			p_ptr->update |= (PU_BONUS);
 
 			break;
@@ -1964,9 +1972,9 @@
  * also set "notice" to FALSE, or the player will learn what the spell does.
  *
  * We attempt to return "TRUE" if the player saw anything "useful" happen.
  */
-static bool project_m(int who, int r, int y, int x, int dam, int typ)
+static bool project_m(int who, int r, int y, int x, int dam, int typ, bool breath)
 {
 	int tmp;
 
 	monster_type *m_ptr;
@@ -2031,8 +2039,14 @@
 	l_ptr = &l_list[m_ptr->r_idx];
 	name = (r_name + r_ptr->name);
 	if (m_ptr->ml) seen = TRUE;
 
+#if 0
+	/* Never affect other monsters in same pack with breath weapons */
+	if (breath && (r_ptr->flags1 & RF1_GROUP_MASK) && who && m_list[who].r_idx == m_ptr->r_idx)
+		return (FALSE);
+#endif
+
 
 	/* Reduce damage by distance */
 	dam = (dam + r) / (r + 1);
 
@@ -3368,9 +3382,9 @@
 			if (p_ptr->resist_chaos)
 			{
 				dam *= 6; dam /= (randint(6) + 6);
 			}
-			if (!p_ptr->resist_confu)
+			if (!p_ptr->resist_confu && !p_ptr->resist_chaos)
 			{
 				(void)set_confused(p_ptr->confused + rand_int(20) + 10);
 			}
 			if (!p_ptr->resist_chaos)
@@ -4179,9 +4193,9 @@
 			y = gy[i];
 			x = gx[i];
 
 			/* Affect the monster in the grid */
-			if (project_m(who, dist, y, x, dam, typ)) notice = TRUE;
+			if (project_m(who, dist, y, x, dam, typ, rad > 0)) notice = TRUE;
 		}
 
 		/* Player affected one monster (without "jumping") */
 		if ((who < 0) && (project_m_n == 1) && !(flg & (PROJECT_JUMP)))
diff --recursive --unified=4 angband-291/src/spells2.c antiband/src/spells2.c
--- angband-291/src/spells2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/spells2.c	Thu Nov 15 01:46:46 2001
 	/* Analyze the weapon */
 	if (o_ptr->k_idx)
 	{
 		/* Special "Attack Bonuses" */
+		if (f1 & (TR1_BRAND_NETHR))
+		{
+			info[i++] = "Your weapon drains your foes of life.";
+		}
+		if (f1 & (TR1_BRAND_NEXUS))
+		{
+			info[i++] = "Your weapon warps space around your foes.";
+		}
+		if (f1 & (TR1_BRAND_CHAOS))
+		{
+			info[i++] = "Your weapon smites your foes with chaos.";
+		}
 		if (f1 & (TR1_BRAND_ACID))
 		{
 			info[i++] = "Your weapon melts your foes.";
 		}
@@ -2346,8 +2468,55 @@
 	if (speed) msg_print("You feel a sudden stirring nearby!");
 	else if (sleep) msg_print("You hear a sudden stirring in the distance!");
 }
 
+/*
+ * Wake up "los" monsters.
+ */
+void wake_monsters(int who)
+{
+	int i;
+
+	/* Aggravate everyone nearby */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Wake up sleeping monsters in los of shouting monster */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			/* Wake up */
+			if (m_ptr->csleep)
+			{
+				/* Wake up */
+				m_ptr->csleep = 0;
+
+				/* Notice the "waking up" */
+				if (m_ptr->ml)
+				{
+					char m_name[80];
+
+					/* Get the monster name */
+					monster_desc(m_name, m_ptr, 0);
+
+					/* Dump a message */
+					msg_format("%^s wakes up.", m_name);
+
+					/* Hack -- Update the health bar */
+					if (p_ptr->health_who == who) p_ptr->redraw |= (PR_HEALTH);
+				}
+			}
+		}
+	}
+}
+
 
 
 /*
  * Delete all non-unique monsters of a given "type" from the level
@@ -3262,8 +3431,11 @@
 bool fire_ball(int typ, int dir, int dam, int rad)
 {
 	int py = p_ptr->py;
 	int px = p_ptr->px;
+	int sx, sy;
+
+	int d;
 
 	int ty, tx;
 
 	int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
@@ -3282,8 +3454,60 @@
 	}
 
 	/* Analyze the "dir" and the "target".  Hurt items on floor. */
 	return (project(-1, rad, ty, tx, dam, typ, flg));
+}
+
+bool fire_meteor(int typ, int dir, int dam, int rad, int scatter, int num)
+{
+	int py = p_ptr->py;
+	int px = p_ptr->px;
+	int sx, sy;
+
+	int d, i;
+
+	int ty, tx;
+	int fx, fy;
+	bool result = FALSE;
+
+	int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
+
+	/* Use the given direction */
+	ty = py + 99 * ddy[dir];
+	tx = px + 99 * ddx[dir];
+
+	/* Hack -- Use an actual "target" */
+	if ((dir == 5) && target_okay())
+	{
+		flg &= ~(PROJECT_STOP);
+
+		ty = p_ptr->target_row;
+		tx = p_ptr->target_col;
+	}
+
+	for (i = 0; i < num; i++)
+	{
+		fx = tx;
+		fy = ty;
+
+		/* Scatter a bit */
+		d = (distance(py, px, ty, tx) * scatter + 9) / 10;
+		if (d > 0)
+		{
+			do
+			{
+				sx = rand_int(2 * d + 1) - d;
+				sy = rand_int(2 * d + 1) - d;
+			}
+			while (distance(ty, tx, ty + sy, tx + sx) > d);
+			fy += sy;
+			fx += sx;
+		}
+
+		/* Analyze the "dir" and the "target".  Hurt items on floor. */
+		if (project(-1, rad, fy, fx, dam, typ, flg)) result = TRUE;
+	}
+	return (result);
 }
 
 
 /*
diff --recursive --unified=4 angband-291/src/store.c antiband/src/store.c
--- angband-291/src/store.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/store.c	Thu Nov  8 20:05:22 2001
@@ -1161,21 +1167,29 @@
 
 	object_type *i_ptr;
 	object_type object_type_body;
 
+	bool random;
+
+	random = (rand_int(100) < 20);
 
 	/* Paranoia -- no room left */
 	if (st_ptr->stock_num >= st_ptr->stock_size) return;
 
 
-	/* Hack -- consider up to four items */
-	for (tries = 0; tries < 4; tries++)
+	/* Hack -- consider up to four items, fifty if random */
+	for (tries = 0; tries < random ? 50 : 4; tries++)
 	{
 		/* Black Market */
 		if (store_num == STORE_B_MARKET)
 		{
 			/* Pick a level for object/magic */
-			level = 25 + rand_int(25);
+			/* ANTIBAND: Increased maximum level for BM items */
+			level = 20 + rand_int(50);
+
+			/* Deliberate cruelty - stock some terrific stuff at the beginning */
+			if (turn < 50 && rand_int(4) == 0)
+				level = 120;
 
 			/* Random object kind (usually of given level) */
 			k_idx = get_obj_num(level);
 
@@ -1185,13 +1199,29 @@
 
 		/* Normal Store */
 		else
 		{
-			/* Hack -- Pick an object kind to sell */
-			k_idx = st_ptr->table[rand_int(st_ptr->table_num)];
+			/* ANTIBAND: Sometimes create random items of a type the store will buy */
+			if (random)
+			{
+				/* Pick a level for object/magic */
+				/* ANTIBAND: Increased maximum level for BM items, reduced minimum */
+				level = 5 + rand_int(30);
+
+				/* Random object kind (usually of given level) */
+				k_idx = get_obj_num(level);
+
+				/* Handle failure */
+				if (!k_idx) continue;
+			}
+			else
+			{
+				/* Hack -- Pick an object kind to sell */
+				k_idx = st_ptr->table[rand_int(st_ptr->table_num)];
 
-			/* Hack -- fake level for apply_magic() */
-			level = rand_range(1, STORE_OBJ_LEVEL);
+				/* Hack -- fake level for apply_magic() */
+				level = rand_range(1, STORE_OBJ_LEVEL);
+			}
 		}
 
 
 		/* Get local object */
@@ -1236,8 +1270,11 @@
 			/* No "worthless" items */
 			if (object_value(i_ptr) <= 0) continue;
 		}
 
+		/* Prune all stores */
+		if (!store_will_buy(i_ptr)) continue;
+
 
 		/* Mass produce and/or Apply discount */
 		mass_produce(i_ptr);
 
diff --recursive --unified=4 angband-291/src/wizard1.c antiband/src/wizard1.c
--- angband-291/src/wizard1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/wizard1.c	Tue Oct 30 11:10:48 2001
@@ -486,8 +486,11 @@
  * Elemental brands for weapons
  */
 static flag_desc brand_flags_desc[] =
 {
+	{ TR1_BRAND_NETHR,		  "Nether Brand" },
+	{ TR1_BRAND_NEXUS,		  "Nexus Brand" },
+	{ TR1_BRAND_CHAOS,		  "Chaos Brand" },
 	{ TR1_BRAND_ACID,         "Acid Brand" },
 	{ TR1_BRAND_ELEC,         "Lightning Brand" },
 	{ TR1_BRAND_FIRE,         "Flame Tongue" },
 	{ TR1_BRAND_COLD,         "Frost Brand" },
@@ -562,9 +565,9 @@
 	{ TR3_HOLD_LIFE,          "Hold Life" },
 	{ TR3_BLESSED,            "Blessed Blade" },
 	{ TR3_IMPACT,             "Earthquake impact on hit" },
 	{ TR3_AGGRAVATE,          "Aggravates" },
-	{ TR3_DRAIN_EXP,          "Drains Experience" }
+	{ TR3_DRAIN_EXP,          "Drains Experience" },
 };
 
 /*
  * A special type used just for deailing with pvals
@@ -927,8 +930,10 @@
  */
 
 static void object_analyze(object_type *o_ptr, obj_desc_list *desc_x_ptr)
 {
+	static char buffer[80];
+
 	analyze_general(o_ptr, desc_x_ptr->description);
 
 	analyze_pval(o_ptr, &desc_x_ptr->pval_info);
 
@@ -945,18 +950,18 @@
 	analyze_misc_magic(o_ptr, desc_x_ptr->misc_magic);
 
 	analyze_misc(o_ptr, desc_x_ptr->misc_desc);
 
-	desc_x_ptr->activation = item_activation(o_ptr);
+	desc_x_ptr->activation = item_activation(o_ptr, buffer);
 }
 
 
 static void print_header(void)
 {
 	char buf[80];
 
-	sprintf(buf, "Artifact Spoilers for Angband Version %d.%d.%d",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	sprintf(buf, "Artifact Spoilers for Antiband Version %d.%d.%d",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	spoiler_underline(buf);
 }
 
 /*
@@ -1169,8 +1174,12 @@
 	o_ptr->to_h = a_ptr->to_h;
 	o_ptr->to_d = a_ptr->to_d;
 	o_ptr->weight = a_ptr->weight;
 
+	/* Curse it if needed */
+	if (a_ptr->flags3 & TR3_LIGHT_CURSE)
+		o_ptr->ident |= IDENT_CURSED;
+
 	/* Success */
 	return (TRUE);
 }
 
@@ -1297,10 +1306,10 @@
 		return;
 	}
 
 	/* Dump the header */
-	fprintf(fff, "Monster Spoilers for Angband Version %d.%d.%d\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	fprintf(fff, "Monster Spoilers for Antiband Version %d.%d.%d\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	fprintf(fff, "------------------------------------------\n\n");
 
 	/* Dump the header */
 	fprintf(fff, "%-40.40s%4s%4s%6s%8s%4s  %11.11s\n",
@@ -1529,10 +1538,10 @@
 	}
 
 
 	/* Dump the header */
-	sprintf(buf, "Monster Spoilers for Angband Version %d.%d.%d\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	sprintf(buf, "Monster Spoilers for Antiband Version %d.%d.%d\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	spoil_out(buf);
 	spoil_out("------------------------------------------\n\n");
 
 	/* Allocate the "who" array */
@@ -1726,9 +1735,9 @@
 
 		/* Collect inate attacks */
 		vn = 0;
 		if (flags4 & (RF4_SHRIEK)) vp[vn++] = "shriek for help";
-		if (flags4 & (RF4_XXX2)) vp[vn++] = "do something";
+		if (flags4 & (RF4_SCREAM)) vp[vn++] = "scream for help";
 		if (flags4 & (RF4_XXX3)) vp[vn++] = "do something";
 		if (flags4 & (RF4_XXX4)) vp[vn++] = "do something";
 		if (flags4 & (RF4_ARROW_1)) vp[vn++] = "fire arrows";
 		if (flags4 & (RF4_ARROW_2)) vp[vn++] = "fire arrows";
diff --recursive --unified=4 angband-291/src/wizard2.c antiband/src/wizard2.c
--- angband-291/src/wizard2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/wizard2.c	Sun Nov  4 13:34:40 2001
@@ -150,9 +150,9 @@
 	/* Query the stats */
 	for (i = 0; i < A_MAX; i++)
 	{
 		/* Prompt */
-		sprintf(ppp, "%s (3-118): ", stat_names[i]);
+		sprintf(ppp, "%s (3-%i): ", stat_names[i], p_ptr->stat_lim[i]);
 
 		/* Default */
 		sprintf(tmp_val, "%d", p_ptr->stat_max[i]);
 
@@ -162,9 +162,9 @@
 		/* Extract */
 		tmp_int = atoi(tmp_val);
 
 		/* Verify */
-		if (tmp_int > 18+100) tmp_int = 18+100;
+		if (tmp_int > p_ptr->stat_lim[i]) tmp_int = p_ptr->stat_lim[i];
 		else if (tmp_int < 3) tmp_int = 3;
 
 		/* Save it */
 		p_ptr->stat_cur[i] = p_ptr->stat_max[i] = tmp_int;

diff --recursive --unified=4 angband-291/src/xtra1.c antiband/src/xtra1.c
--- angband-291/src/xtra1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/xtra1.c	Thu Nov 15 01:39:52 2001
@@ -22,9 +22,13 @@
 	if (val > 18)
 	{
 		int bonus = (val - 18);
 
-		if (bonus >= 100)
+		if (bonus > 999)
+		{
+			strcpy(out_val, "18/***");
+		}
+		else if (bonus >= 100)
 		{
 			sprintf(out_val, "18/%03d", bonus);
 		}
 		else
@@ -130,9 +134,9 @@
 		c_put_str(TERM_L_GREEN, tmp, ROW_STAT + stat, COL_STAT + 6);
 	}
 
 	/* Indicate natural maximum */
-	if (p_ptr->stat_max[stat] == 18+100)
+	if (p_ptr->stat_max[stat] == p_ptr->stat_lim[stat])
 	{
 		put_str("!", ROW_STAT + stat, 3);
 	}
 }

diff --recursive --unified=4 angband-291/src/xtra2.c antiband/src/xtra2.c
--- angband-291/src/xtra2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/xtra2.c	Sun Nov  4 12:55:04 2001
@@ -1772,10 +1772,10 @@
 static int get_coin_type(monster_race *r_ptr)
 {
 	cptr name = (r_name + r_ptr->name);
 
-	/* Analyze "coin" monsters */
-	if (r_ptr->d_char == '$')
+	/* Analyze "coin" monsters and golems */
+	if (strchr("$g", r_ptr->d_char))
 	{
 		/* Look for textual clues */
 		if (strstr(name, " copper ")) return (2);
 		if (strstr(name, " silver ")) return (5);
