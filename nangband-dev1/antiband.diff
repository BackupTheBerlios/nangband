diff [unapplied] from object.txt; a few objects to add

+N:170:Clairvoyance
+G:":d
+I:40:9:0
+W:20:0:3:500
+A:20/3
+F:TELEPATHY | EASY_KNOW

+N:633:the Planes
+G:":d
+I:40:10:0
+W:50:0:3:30000
+A:50/4
+F:SEE_INVIS | REGEN | HOLD_LIFE | RES_NEXUS | RES_DARK | 
+F:IGNORE_ACID | IGNORE_ELEC | IGNORE_FIRE | IGNORE_COLD | EASY_KNOW
+
+N:634:Resist Confusion
+G:":d
+I:40:11:0
+W:30:0:3:750
+A:40/2
+F:RES_CONFU | EASY_KNOW

diff --recursive --unified=4 angband-291/lib/edit/r_info.txt antiband/lib/edit/r_info.txt
--- angband-291/lib/edit/r_info.txt	Tue Jul 25 19:57:47 2000
+++ antiband/lib/edit/r_info.txt	Sat Nov 10 11:35:12 2001
@@ -155,9 +155,9 @@


 # Version stamp (required)

-V:2.9.1
+V:12.9.1


 ##### Non-race (contains the "player" picture) #####

@@ -949,9 +949,9 @@
 B:HIT:HURT:1d4
 B:TOUCH:POISON:2d4
 F:ONLY_GOLD | DROP_1D2 |
 F:COLD_BLOOD | BASH_DOOR |
-F:ANIMAL | IM_POIS |
+F:IM_POIS |
 F:NO_CONF | NO_SLEEP
 D:It is a pile of coins.
 
 N:73:Giant white rat
@@ -1210,9 +1210,9 @@
 B:HIT:HURT:1d6
 B:TOUCH:POISON:2d6
 F:ONLY_GOLD | DROP_60 | DROP_1D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | IM_POIS | NO_CONF | NO_SLEEP
+F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, crawling forward on thousands of tiny legs.
 
 N:96:Snaga
 G:o:U
@@ -1222,8 +1222,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_10 | 
+S:SCREAM
 D:He is one of the many weaker 'slave' orcs, often mistakenly known as a 
 D:goblin.
 
 N:97:Rattlesnake
@@ -1245,8 +1247,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_8 | 
+S:SCREAM
 D:He is often found in huge numbers in deep caves.
 
 N:99:Wood spider
 G:S:U
@@ -1512,8 +1516,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC
+S:1_IN_6 | 
+S:SCREAM
 D:He is a hardy well-weathered survivor.
 
 N:121:Bandit
 G:p:b
@@ -1856,9 +1862,8 @@
 B:HIT:HURT:2d5
 B:TOUCH:POISON:3d5
 F:ONLY_GOLD | DROP_90 | DROP_1D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, crawling forward on thousands of tiny legs.
 
 N:147:Wolf
@@ -2212,8 +2217,10 @@
 F:FRIENDS | 
 F:DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_10 | 
+S:SCREAM
 D:A hideous, smallish giant that is often found near or with orcs.
 
 N:175:Creeping mithril coins
 G:$:B
@@ -2222,9 +2229,8 @@
 B:HIT:HURT:2d5
 B:TOUCH:POISON:3d5
 F:ONLY_GOLD | DROP_90 | DROP_2D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, shambling forward on thousands of tiny legs.
 
 N:176:Illusionist
@@ -2263,8 +2269,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_6 | 
+S:SCREAM
 D:He is a large orc with powerful arms and deep black skin.
 
 N:179:Ochre jelly
 G:j:U
@@ -2418,8 +2426,10 @@
 F:RAND_25 | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_10 | 
+S:SCREAM
 D:A massive orc-like figure with black skin and powerful arms.
 
 N:191:Magic mushroom patch
 G:,:B
@@ -2481,8 +2491,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC
+S:1_IN_4 | 
+S:SCREAM
 D:He is a hideous deformed cross-breed with man and orc, combining man's 
 D:strength and cunning with orcish evil.
 
 N:196:Giant tarantula
@@ -2729,8 +2741,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | HURT_LITE
+S:1_IN_16 | 
+S:SCREAM
 D:He is green skinned and ugly.
 
 N:215:Nar, the Dwarf
 G:h:y
@@ -2865,9 +2879,9 @@
 W:18:3:0:60
 B:HIT:POISON:3d4
 B:HIT:HURT:2d3
 B:HIT:HURT:2d3
-F:CHAR_MULTI | 
+F:CHAR_MULTI | ATTR_RANDOM |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_6 | 
@@ -2898,8 +2912,10 @@
 F:MALE | 
 F:FORCE_MAXHP | FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:He is a cunning orc of power, as tall as a man, and stronger.  It fears 
 D:little.
 
 N:227:Shagrat, the Orc Captain
@@ -3250,9 +3266,9 @@
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:HURT:2d3
 B:HIT:HURT:2d3
-F:CHAR_MULTI | 
+F:CHAR_MULTI |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_5 | 
@@ -3626,8 +3642,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | HURT_LITE | HURT_ROCK
+S:1_IN_12 | 
+S:SCREAM
 D:He is a giant troll with scabrous black skin.
 
 N:279:Troll priest
 G:T:G
@@ -3733,8 +3751,10 @@
 B:HIT:HURT:3d8
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_8 | 
+S:SCREAM
 D:A giant orc-like figure with an awesomely muscled frame.
 
 N:288:White wraith
 G:W:w
@@ -3807,9 +3827,8 @@
 B:HIT:HURT:1d12
 B:HIT:HURT:1d12
 F:ONLY_GOLD | DROP_90 | DROP_2D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, slithering forward on thousands of tiny legs.
 
 N:293:Algroth
@@ -3821,8 +3840,10 @@
 B:BITE:HURT:1d6
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL
+S:1_IN_8 | 
+S:SCREAM
 D:A powerful troll form.  Venom drips from its needlelike claws.
 
 N:294:Vibration hound
 G:Z:y
@@ -3858,9 +3879,9 @@
 D:A locus of conflicting points coalesce to form the vague shape of a huge 
 D:hound.  Or is it just your imagination?
 
 N:296:Ogre mage
-G:O:r
+G:O:R
 I:110:30d12:20:40:30
 W:27:2:0:300
 B:HIT:HURT:3d8
 B:HIT:HURT:3d8
@@ -4081,8 +4102,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_COLD | HURT_LITE
+S:1_IN_8 | 
+S:SCREAM
 D:He is a white troll with powerfully clawed hands.
 
 N:310:Giant purple worm
 G:w:v
@@ -4134,9 +4157,9 @@
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
-F:CHAR_MULTI | 
+F:CHAR_MULTI | ATTR_RANDOM |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_4 | 
@@ -4449,8 +4472,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS | HURT_LITE
+S:1_IN_6 | 
+S:SCREAM
 D:He is a vicious monster, feared for his ferocity.
 
 N:335:Half-troll
 G:T:U
@@ -4464,8 +4489,10 @@
 F:FRIENDS | 
 F:ONLY_ITEM | DROP_90 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:A huge, ugly, half-human in search of plunder.
 
 N:336:Mystic
 G:p:o
@@ -4683,8 +4710,10 @@
 F:FORCE_MAXHP | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_COLD | IM_POIS | HURT_LITE
+S:1_IN_10 | 
+S:SCREAM
 D:He is a troll that reeks of brine.
 
 N:349:Fire elemental
 G:E:r
@@ -4909,8 +4938,10 @@
 B:BITE:HURT:2d3
 F:FORCE_MAXHP | OPEN_DOOR | FRIENDS | DROP_60 | 
 F:SMART | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:It is a massive intelligent troll with needle sharp fangs.
 
 N:364:Dagashi
 G:p:y
@@ -6004,9 +6035,8 @@
 I:120:16d10:20:1:0
 W:40:1:0:1500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TPORT | 
 S:S_UNDEAD
@@ -7041,9 +7071,8 @@
 I:120:48d10:20:1:0
 W:51:1:0:3000
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TPORT | 
 S:S_DEMON
@@ -7775,9 +7804,8 @@
 I:120:20d100:20:1:0
 W:71:3:0:12000
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:S_MONSTER | S_MONSTERS | S_UNDEAD | S_DRAGON | S_HI_UNDEAD |
 S:S_HI_DRAGON | S_HI_DEMON
@@ -7788,9 +7816,8 @@
 I:120:15d100:20:1:0
 W:71:3:0:10500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TELE_TO | 
 S:S_HI_DRAGON
@@ -7802,9 +7829,8 @@
 I:120:15d100:20:1:0
 W:71:3:0:10500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TELE_TO | 
 S:S_HI_UNDEAD
@@ -7929,9 +7955,8 @@
 F:UNIQUE | 
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:ONLY_ITEM | DROP_4D2 | 
 F:INVISIBLE | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BRAIN_SMASH | 
 S:S_HI_UNDEAD | S_HI_DRAGON | S_HI_DEMON
@@ -7946,9 +7971,8 @@
 F:UNIQUE | 
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:ONLY_ITEM | DROP_4D2 | 
 F:INVISIBLE | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_1 | 
 S:S_MONSTER | S_MONSTERS | S_UNDEAD | S_DEMON | S_DRAGON | S_ANGEL | 
 S:S_HYDRA | S_SPIDER | S_ANT | S_HOUND | S_UNIQUE | S_WRAITH | 
@@ -8250,4 +8274,128 @@
 D:two remaining Silmarils forever burning him.  Grond, the mighty Hammer of 
 D:the Underworld, cries defiance as he strides towards you to crush you to a 
 D:pulp!
 
+N:548:Mimic (chest)
+G:~:s
+I:120:20d80:30:90:5
+W:35:3:0:600
+B:HIT:POISON:8d6
+B:HIT:POISON:8d6
+B:TOUCH:PARALYZE:6d4
+B:TOUCH:PARALYZE:6d4
+F:CHAR_MULTI | 
+F:FORCE_SLEEP | NEVER_MOVE | 
+F:EMPTY_MIND | COLD_BLOOD | 
+F:DROP_2D2 | 
+F:SMART | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_4 | 
+S:BLIND | CONF | BRAIN_SMASH | TELE_TO
+D:A strange creature that disguises itself as discarded objects to lure 
+D:unsuspecting adventurers within reach of its venomous claws.
+
+N:549:Animated armor
+G:[:W
+I:100:60d20:10:150:20
+W:28:4:0:500
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+F:EMPTY_MIND | COLD_BLOOD | BASH_DOOR | 
+F:IM_FIRE | IM_COLD | IM_ELEC | IM_POIS | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+D:It is a huge suit of armor animated by magic.
+
+N:550:Neeker-breeker
+G:I:v
+I:110:1d1:5:0:20
+W:2:6:0:1
+F:WEIRD_MIND | COLD_BLOOD |
+F:MULTIPLY | NO_FEAR | RAND_25 | RAND_50
+S:1_IN_10 |
+S:CONF
+D:You never thought such a small insect could make such noise.
+
+N:551:Psychic quylthulg
+G:Q:v
+I:110:13d10:10:1:0
+W:35:2:0:360
+F:FORCE_SLEEP | NEVER_MOVE | NEVER_BLOW | 
+F:INVISIBLE | WEIRD_MIND | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_1 | 
+S:BLINK | TPORT | BRAIN_SMASH | FORGET | DRAIN_MANA
+D:It is a strange brain-like pulsing mound of flesh.
+
+N:552:Chaos quylthulg
+G:Q:v
+I:120:24d10:20:1:0
+W:45:2:0:1500
+F:ATTR_MULTI | 
+F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
+F:INVISIBLE | EMPTY_MIND | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_2 | 
+S:BLINK | TPORT | BR_CHAO
+D:It is a pulsing flesh mound that changes form as you watch.
+
+N:553:Fire ogre
+G:O:r
+I:110:30d12:20:33:30
+W:28:1:0:70
+B:HIT:FIRE:3d10
+B:HIT:FIRE:3d10
+F:FRIENDS | DROP_60 | 
+F:OPEN_DOOR | BASH_DOOR | 
+F:EVIL | GIANT | IM_FIRE
+S:1_IN_8 | 
+S:SCREAM
+D:A huge ogre covered in dark red fur.
+
+N:554:Faerie dragon
+G:d:v
+I:110:8d10:20:25:15
+W:8:2:0:30
+B:BITE:HURT:1d5
+F:FORCE_MAXHP | FORCE_SLEEP | 
+F:ONLY_GOLD | DROP_90 | 
+F:OPEN_DOOR | BASH_DOOR | 
+F:DRAGON
+S:1_IN_8 | 
+S:BR_LITE | 
+S:HASTE | BLINK | BLIND | CONF | DARKNESS
+D:This tiny dragon appears and disappears in great agitation.
+
+N:555:Quickling
+G:h:W
+I:130:4d6:16:5:3
+W:5:3:0:15
+B:HIT:HURT:1d2
+F:MALE | 
+F:ONLY_GOLD | DROP_90 | 
+F:OPEN_DOOR
+S:1_IN_4 | 
+S:ARROW_1 | MISSILE | BLINK
+D:A tiny elf-like figure moving incredibly quickly.
+
+N:556:Giant slime mold
+G:,:g
+I:100:2d10:5:3:20
+W:1:1:0:2
+B:HIT:HURT:1d4
+B:TOUCH:ACID:1d2
+F:EMPTY_MIND | BASH_DOOR | 
+F:ANIMAL
+D:A giant green blob searching mindlessly for food.
+
+N:557:Carnivorous slime mold
+G:,:y
+I:100:3d8:5:8:20
+W:2:1:0:3
+B:HIT:HURT:1d4
+B:HIT:HURT:1d4
+B:TOUCH:ACID:1d3
+F:EMPTY_MIND | BASH_DOOR | 
+F:ANIMAL
+D:A giant yellow blob searching mindlessly for food.

diff --recursive --unified=4 angband-291/src/cave.c antiband/src/cave.c
--- angband-291/src/cave.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cave.c	Tue Oct 30 11:10:46 2001
@@ -967,8 +967,18 @@
 				/* Normal char */
 				c = dc;
 			}
 
+			/* Random-hued monster */
+			else if (r_ptr->flags2 & (RF2_ATTR_RANDOM))
+			{
+				/* Random-hued attr */
+				a = m_idx % 15 + 1;
+
+				/* Normal char */
+				c = dc;
+			}
+
 			/* Normal monster (not "clear" in any way) */
 			else if (!(r_ptr->flags1 & (RF1_ATTR_CLEAR | RF1_CHAR_CLEAR)))
 			{
 				/* Use attr */
diff --recursive --unified=4 angband-291/src/cmd2.c antiband/src/cmd2.c
--- angband-291/src/cmd2.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd2.c	Sun Nov  4 12:43:44 2001
@@ -234,9 +234,9 @@
 		/* Otherwise drop an item */
 		else
 		{
 			/* Make an object */
-			if (!make_object(i_ptr, FALSE, FALSE)) continue;
+			if (!make_object(i_ptr, FALSE, FALSE, FALSE)) continue;
 		}
 
 		/* Drop it in the dungeon */
 		drop_near(i_ptr, -1, y, x);
diff --recursive --unified=4 angband-291/src/cmd3.c antiband/src/cmd3.c
--- angband-291/src/cmd3.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd3.c	Tue Nov 20 12:35:58 2001
@@ -497,9 +497,9 @@
 	int item;
 
 	object_type *o_ptr;
 
-	char o_name[80];
+	char o_name[120];
 
 	cptr q, s;
 
 
@@ -523,12 +523,28 @@
 	/* Description */
 	object_desc(o_name, o_ptr, TRUE, 3);
 
 	/* Describe */
-	msg_format("Examining %s...", o_name);
+	if (item >= INVEN_WIELD)
+	{
+		strcpy(o_name, format("%^s: %s (%c)", describe_use(item), o_name, index_to_label(item)));
+	}
+	else if (item >= 0)
+	{
+		strcpy(o_name, format("In pack: %s (%c)", o_name, index_to_label(item)));
+	}
+	else
+	{
+		strcpy(o_name, format("On ground: %s", o_name));
+	}
 
 	/* Describe it fully */
-	if (!identify_fully_aux(o_ptr)) msg_print("You see nothing special.");
+	if (!identify_fully_aux(o_ptr, o_name)) 
+	{
+		/* Redescribe */
+		object_desc(o_name, o_ptr, TRUE, 3);
+		msg_format("Examining %s... you see nothing special.", o_name);
+	}
 }
 
 
 
@@ -1157,18 +1173,26 @@
 bool ang_sort_comp_hook(vptr u, vptr v, int a, int b)
 {
 	u16b *who = (u16b*)(u);
 
-	u16b *why = (u16b*)(v);
+	u16b why = *(u16b*)(v);
 
 	int w1 = who[a];
 	int w2 = who[b];
 
 	int z1, z2;
 
+	if (why & 16)
+	{
+		int t;
+		t = w1;
+		w1 = w2;
+		w2 = t;
+		why &= ~16;
+	}
 
 	/* Sort by player kills */
-	if (*why >= 4)
+	if (why >= 4)
 	{
 		/* Extract player kills */
 		z1 = l_list[w1].r_pkills;
 		z2 = l_list[w2].r_pkills;
@@ -1179,9 +1203,9 @@
 	}
 
 
 	/* Sort by total kills */
-	if (*why >= 3)
+	if (why >= 3)
 	{
 		/* Extract total kills */
 		z1 = l_list[w1].r_tkills;
 		z2 = l_list[w2].r_tkills;
@@ -1192,9 +1216,9 @@
 	}
 
 
 	/* Sort by monster level */
-	if (*why >= 2)
+	if (why >= 2)
 	{
 		/* Extract levels */
 		z1 = r_info[w1].level;
 		z2 = r_info[w2].level;
@@ -1205,9 +1229,9 @@
 	}
 
 
 	/* Sort by monster experience */
-	if (*why >= 1)
+	if (why >= 1)
 	{
 		/* Extract experience */
 		z1 = r_info[w1].mexp;
 		z2 = r_info[w2].mexp;
@@ -1310,8 +1334,9 @@
 
 	bool all = FALSE;
 	bool uniq = FALSE;
 	bool norm = FALSE;
+	bool kill = TRUE;
 
 	bool recall = FALSE;
 
 	u16b why = 0;
@@ -1342,8 +1367,13 @@
 	{
 		all = norm = TRUE;
 		strcpy(buf, "Non-unique monster list.");
 	}
+	else if (sym == KTRL('K'))
+	{
+		all = kill = TRUE;
+		strcpy(buf, "Killed monster list.");
+	}
 	else if (ident_info[i])
 	{
 		sprintf(buf, "%c - %s.", sym, ident_info[i] + 2);
 	}
@@ -1367,14 +1397,20 @@
 
 		/* Nothing to recall */
 		if (!cheat_know && !l_ptr->r_sights) continue;
 
+		/* Skip unused monsters */
+		if (!(r_ptr->hdice)) continue;
+
 		/* Require non-unique monsters if needed */
 		if (norm && (r_ptr->flags1 & (RF1_UNIQUE))) continue;
 
 		/* Require unique monsters if needed */
 		if (uniq && !(r_ptr->flags1 & (RF1_UNIQUE))) continue;
 
+		/* Require killed if needed */
+		if (kill && !(l_ptr->r_pkills)) continue;
+
 		/* Collect "appropriate" monsters */
 		if (all || (r_ptr->d_char == sym)) who[n++] = i;
 	}
 
@@ -1388,9 +1424,9 @@
 	}
 
 
 	/* Prompt */
-	put_str("Recall details? (k/p/y/n): ", 0, 40);
+	put_str("Recall details? (k/K/p/P/a/A/y/n): ", 0, 40);
 
 	/* Query */
 	query = inkey();
 
@@ -1403,13 +1439,35 @@
 	{
 		why = 4;
 		query = 'y';
 	}
+	if (query == 'K')
+	{
+		why = 4+16;
+		query = 'y';
+	}
 
-	/* Sort by level */
+	/* Sort by total kills (and level) */
+	if (query == 'a')
+	{
+		why = 3;
+		query = 'y';
+	}
+	if (query == 'A')
+	{
+		why = 3+16;
+		query = 'y';
+	}
+
+	/* Sort by level (and experience) */
 	if (query == 'p')
 	{
 		why = 2;
+		query = 'y';
+	}
+	if (query == 'P')
+	{
+		why = 2+16;
 		query = 'y';
 	}
 
 	/* Catch "escape" */
diff --recursive --unified=4 angband-291/src/cmd4.c antiband/src/cmd4.c
--- angband-291/src/cmd4.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd4.c	Thu Nov  1 18:21:18 2001
@@ -2367,10 +2367,10 @@
  */
 void do_cmd_version(void)
 {
 	/* Silly message */
-	msg_format("You are playing Angband %d.%d.%d.  Type '?' for more info.",
-	           VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	msg_format("You are playing Antiband %d.%d.%d.  Type '?' for more info.",
+	           VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 }
 
 
 
@@ -2685,8 +2685,11 @@
 
 				/* Ignore non-artifacts */
 				if (!artifact_p(o_ptr)) continue;
 
+				/* Ignore randarts */
+				if (!o_ptr->name1) continue;
+
 				/* Ignore known items */
 				if (object_known_p(o_ptr)) continue;
 
 				/* Note the artifact */
@@ -2704,8 +2707,11 @@
 		if (!o_ptr->k_idx) continue;
 
 		/* Ignore non-artifacts */
 		if (!artifact_p(o_ptr)) continue;
+
+		/* Ignore randarts */
+		if (!o_ptr->name1) continue;
 
 		/* Ignore known items */
 		if (object_known_p(o_ptr)) continue;
 
diff --recursive --unified=4 angband-291/src/cmd5.c antiband/src/cmd5.c
--- angband-291/src/cmd5.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd5.c	Wed Oct 31 16:46:56 2001
@@ -28,9 +28,9 @@
 
 	int spell;
 	int num = 0;
 
-	byte spells[64];
+	u16b spell_table[64];
 
 	bool verify;
 
 	bool flag, redraw, okay;
@@ -57,18 +57,12 @@
 
 #endif /* ALLOW_REPEAT */
 
 	/* Extract spells */
-	for (spell = 0; spell < 64; spell++)
+	for (i = 0; i < 12; i++)
 	{
-		/* Check for this spell */
-		if ((spell < 32) ?
-		    (spell_flags[mp_ptr->spell_type][sval][0] & (1L << spell)) :
-		    (spell_flags[mp_ptr->spell_type][sval][1] & (1L << (spell - 32))))
-		{
-			/* Collect this spell */
-			spells[num++] = spell;
-		}
+		if (spell_list[mp_ptr->spell_type][sval][i] >= 0)
+			spell_table[num++] = spell_list[mp_ptr->spell_type][sval][i];
 	}
 
 
 	/* Assume no usable spells */
@@ -80,9 +74,9 @@
 	/* Check for "okay" spells */
 	for (i = 0; i < num; i++)
 	{
 		/* Look for "okay" spells */
-		if (spell_okay(spells[i], known)) okay = TRUE;
+		if (spell_okay(spell_table[i], known)) okay = TRUE;
 	}
 
 	/* No "okay" spells */
 	if (!okay) return (FALSE);
@@ -104,9 +98,9 @@
 		/* Save screen */
 		screen_save();
 
 		/* Display a list of spells */
-		print_spells(spells, num, 1, 20);
+		print_spells(spell_table, num, 1, 20);
 	}
 
 #endif
 
@@ -140,9 +134,9 @@
 				/* Save screen */
 				screen_save();
 
 				/* Display a list of spells */
-				print_spells(spells, num, 1, 20);
+				print_spells(spell_table, num, 1, 20);
 			}
 
 			/* Ask again */
 			continue;
@@ -165,9 +159,9 @@
 			continue;
 		}
 
 		/* Save the spell index */
-		spell = spells[i];
+		spell = spell_table[i];
 
 		/* Require "okay" spells */
 		if (!spell_okay(spell, known))
 		{
@@ -181,13 +175,13 @@
 		{
 			char tmp_val[160];
 
 			/* Get the spell */
-			s_ptr = &mp_ptr->info[spell];
+			s_ptr = &spells[mp_ptr->spell_type][spell].casters[p_ptr->pclass];
 
 			/* Prompt */
 			strnfmt(tmp_val, 78, "%^s %s (%d mana, %d%% fail)? ",
-			        prompt, spell_names[mp_ptr->spell_type][spell],
+			        prompt, spells[mp_ptr->spell_type][spell].name,
 			        s_ptr->smana, spell_chance(spell));
 
 			/* Belay that order */
 			if (!get_check(tmp_val)) continue;
@@ -242,14 +236,15 @@
 
 	int spell;
 	int num = 0;
 
-	byte spells[64];
+	u16b spell_table[64];
 
 	object_type *o_ptr;
 
 	cptr q, s;
 
+	int i;
 
 	/* Warriors are illiterate */
 	if (!mp_ptr->spell_book)
 	{
@@ -306,26 +301,20 @@
 	handle_stuff();
 
 
 	/* Extract spells */
-	for (spell = 0; spell < 64; spell++)
+	for (i = 0; i < 12; i++)
 	{
-		/* Check for this spell */
-		if ((spell < 32) ?
-		    (spell_flags[mp_ptr->spell_type][sval][0] & (1L << spell)) :
-		    (spell_flags[mp_ptr->spell_type][sval][1] & (1L << (spell - 32))))
-		{
-			/* Collect this spell */
-			spells[num++] = spell;
-		}
+		if (spell_list[mp_ptr->spell_type][sval][i] >= 0)
+			spell_table[num++] = spell_list[mp_ptr->spell_type][sval][i];
 	}
 
 
 	/* Save screen */
 	screen_save();
 
 	/* Display the spells */
-	print_spells(spells, num, 1, 20);
+	print_spells(spell_table, num, 1, 20);
 
 	/* Prompt for a command */
 	put_str("(Browsing) Command: ", 0, 0);
 
@@ -433,15 +422,14 @@
 
 		int gift = -1;
 
 		/* Extract spells */
-		for (spell = 0; spell < 64; spell++)
+		for (i = 0; i < 12; i++)
 		{
-			/* Check spells in the book */
-			if ((spell < 32) ?
-			    (spell_flags[mp_ptr->spell_type][sval][0] & (1L << spell)) :
-			    (spell_flags[mp_ptr->spell_type][sval][1] & (1L << (spell - 32))))
+			if (spell_list[mp_ptr->spell_type][sval][i] >= 0)
 			{
+				int spell = spell_list[mp_ptr->spell_type][sval][i];
+
 				/* Skip non "okay" prayers */
 				if (!spell_okay(spell, FALSE)) continue;
 
 				/* Apply the randomizer */
@@ -491,9 +479,9 @@
 	p_ptr->spell_order[i] = spell;
 
 	/* Mention the result */
 	message_format(MSG_STUDY, 0, "You have learned the %s of %s.",
-	           p, spell_names[mp_ptr->spell_type][spell]);
+	           p, spells[mp_ptr->spell_type][spell].name);
 
 	/* One less spell available */
 	p_ptr->new_spells--;
 
@@ -528,8 +516,10 @@
 
 	int item, sval, spell, dir;
 	int chance, beam;
 
+	int i;
+
 	int plev = p_ptr->lev;
 
 	object_type *o_ptr;
 
@@ -599,9 +589,9 @@
 	}
 
 
 	/* Get the spell */
-	s_ptr = &mp_ptr->info[spell];
+	s_ptr = &spells[mp_ptr->spell_type][spell].casters[p_ptr->pclass];
 
 
 	/* Verify "dangerous" spells */
 	if (s_ptr->smana > p_ptr->csp)
@@ -928,10 +918,10 @@
 
 			case 42:
 			{
 				if (!get_aim_dir(&dir)) return;
-				fire_ball(GF_METEOR, dir,
-				          65 + (plev), 3);
+				fire_meteor(GF_METEOR, dir,
+									33 + (plev) / 2, 3, 2, 1 + randint(5));
 				break;
 			}
 
 			case 43:
@@ -1245,9 +1235,9 @@
 	}
 
 
 	/* Get the spell */
-	s_ptr = &mp_ptr->info[spell];
+	s_ptr = &spells[mp_ptr->spell_type][spell].casters[p_ptr->pclass];
 
 
 	/* Verify "dangerous" prayers */
 	if (s_ptr->smana > p_ptr->csp)
@@ -1603,15 +1593,15 @@
 			}
 
 			case 49:
 			{
-				(void)enchant_spell(rand_int(4) + 1, rand_int(4) + 1, 0);
+				(void)enchant_spell(rand_int(4) + 1, rand_int(4) + 1, 0, FALSE);
 				break;
 			}
 
 			case 50:
 			{
-				(void)enchant_spell(0, 0, rand_int(3) + 2);
+				(void)enchant_spell(0, 0, rand_int(3) + 2, FALSE);
 				break;
 			}
 
 			case 51:
diff --recursive --unified=4 angband-291/src/cmd6.c antiband/src/cmd6.c
--- angband-291/src/cmd6.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd6.c	Thu Nov  1 22:42:28 2001
@@ -934,8 +934,9 @@
 
 		/* Blast the armor */
 		o_ptr->name1 = 0;
 		o_ptr->name2 = EGO_BLASTED;
+		o_ptr->name3 = 0;
 		o_ptr->to_a = 0 - randint(5) - randint(5);
 		o_ptr->to_h = 0;
 		o_ptr->to_d = 0;
 		o_ptr->ac = 0;
@@ -998,8 +999,9 @@
 
 		/* Shatter the weapon */
 		o_ptr->name1 = 0;
 		o_ptr->name2 = EGO_SHATTERED;
+		o_ptr->name3 = 0;
 		o_ptr->to_h = 0 - randint(5) - randint(5);
 		o_ptr->to_d = 0 - randint(5) - randint(5);
 		o_ptr->to_a = 0;
 		o_ptr->ac = 0;
@@ -1221,36 +1223,36 @@
 
 		case SV_SCROLL_ENCHANT_ARMOR:
 		{
 			ident = TRUE;
-			if (!enchant_spell(0, 0, 1)) used_up = FALSE;
+			if (!enchant_spell(0, 0, 1, FALSE)) used_up = FALSE;
 			break;
 		}
 
 		case SV_SCROLL_ENCHANT_WEAPON_TO_HIT:
 		{
-			if (!enchant_spell(1, 0, 0)) used_up = FALSE;
+			if (!enchant_spell(1, 0, 0, FALSE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_ENCHANT_WEAPON_TO_DAM:
 		{
-			if (!enchant_spell(0, 1, 0)) used_up = FALSE;
+			if (!enchant_spell(0, 1, 0, FALSE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_STAR_ENCHANT_ARMOR:
 		{
-			if (!enchant_spell(0, 0, randint(3) + 2)) used_up = FALSE;
+			if (!enchant_spell(0, 0, randint(3) + 2, TRUE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_STAR_ENCHANT_WEAPON:
 		{
-			if (!enchant_spell(randint(3), randint(3), 0)) used_up = FALSE;
+			if (!enchant_spell(randint(3), randint(3), 0, TRUE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
@@ -2654,8 +2656,11 @@
 
 	/* Not known */
 	if (!object_known_p(o_ptr)) return (FALSE);
 
+	/* Cursed non-artifact items can't be activated */
+	if (cursed_p(o_ptr) && !artifact_p(o_ptr)) return (FALSE);
+
 	/* Extract the flags */
 	object_flags(o_ptr, &f1, &f2, &f3);
 
 	/* Check activation flag */
@@ -2809,8 +2814,12 @@
 	object_type *o_ptr;
 
 	cptr q, s;
 
+	int activation = -1, time = 0, randtime = 0;
+
+	char o_name[80];
+
 
 	/* Prepare the hook */
 	item_tester_hook = item_tester_hook_activate;
 
@@ -2838,9 +2847,10 @@
 	/* Extract the item level */
 	lev = k_info[o_ptr->k_idx].level;
 
 	/* Hack -- use artifact level instead */
-	if (artifact_p(o_ptr)) lev = a_info[o_ptr->name1].level;
+	if (o_ptr->name1) lev = a_info[o_ptr->name1].level;
+	if (o_ptr->name3) lev = x_info[o_ptr->name3].level;
 
 	/* Base chance of success */
 	chance = p_ptr->skill_dev;
 
@@ -2873,18 +2883,27 @@
 
 	/* Activate the artifact */
 	message(MSG_ZAP, 0, "You activate it...");
 
+	/* Get the basic name of the object */
+	object_desc(o_name, o_ptr, FALSE, 0);
+
 	/* Artifacts */
 	if (o_ptr->name1)
 	{
 		artifact_type *a_ptr = &a_info[o_ptr->name1];
-		char o_name[80];
 
-		/* Get the basic name of the object */
-		object_desc(o_name, o_ptr, FALSE, 0);
+		/* Get the activation */
+		activation = a_ptr->activation;
 
-		switch (a_ptr->activation)
+		/* Get the timeout */
+		time = a_ptr->time;
+		randtime = a_ptr->time;
+	}
+
+	if (activation >= 0)
+	{
+		switch (activation)
 		{
 			case ACT_ILLUMINATION:
 			{
 				msg_format("The %s wells with clear light...", o_name);
@@ -3279,15 +3298,23 @@
 				msg_format("Your %s glows deep red...", o_name);
 				(void)brand_bolts();
 				break;
 			}
+
+			case ACT_ELEMENTS:
+			{
+				msg_format("Your %s glows brilliant white...", o_name);
+				if (!get_aim_dir(&dir)) return;
+				fire_ball(GF_MISSILE, dir, 400, 3);
+				break;
+			}
 		}
 
 		/* Set the recharge time */
-		if (a_ptr->randtime)
-			o_ptr->timeout = a_ptr->time + (byte)randint(a_ptr->randtime);
+		if (randtime)
+			o_ptr->timeout = time + (byte)randint(randtime);
 		else
-			o_ptr->timeout = a_ptr->time;
+			o_ptr->timeout = time;
 
 		/* Window stuff */
 		p_ptr->window |= (PW_INVEN | PW_EQUIP);
 
@@ -3429,8 +3456,80 @@
 			{
 				msg_print("You breathe the elements.");
 				fire_ball(GF_MISSILE, dir, 300, 2);
 				o_ptr->timeout = rand_int(300) + 300;
+				break;
+			}
+		}
+
+		/* Window stuff */
+		p_ptr->window |= (PW_INVEN | PW_EQUIP);
+
+		/* Success */
+		return;
+	}
+
+	/* Some rings can be activated */
+	if (o_ptr->tval == TV_RING)
+	{
+		char o_name[80];
+
+		/* Get the basic name of the object */
+		object_desc(o_name, o_ptr, FALSE, 0);
+
+		/* Branch on the sub-type */
+		switch (o_ptr->sval)
+		{
+		case SV_RING_ACID:
+			{
+				msg_format("Your %s releases a blast of acid.", o_name);
+				if (!get_aim_dir(&dir)) return;
+				fire_bolt(GF_ACID, dir, damroll(12, 8));
+				o_ptr->timeout = rand_int(20) + 20;
+				break;
+			}
+
+		case SV_RING_FLAMES:
+			{
+				msg_format("Your %s releases a blast of fire.", o_name);
+				if (!get_aim_dir(&dir)) return;
+				fire_bolt(GF_FIRE, dir, damroll(12, 8));
+				o_ptr->timeout = rand_int(20) + 20;
+				break;
+			}
+
+		case SV_RING_ICE:
+			{
+				msg_format("Your %s releases a blast of frost.", o_name);
+				if (!get_aim_dir(&dir)) return;
+				fire_bolt(GF_COLD, dir, damroll(12, 8));
+				o_ptr->timeout = rand_int(20) + 20;
+				break;
+			}
+
+		case SV_RING_TELEPORTATION:
+			{
+				msg_format("Your %s twists space around you...", o_name);
+				teleport_player(100);
+				o_ptr->timeout = rand_int(50) + 50;
+				break;
+			}
+
+		case SV_RING_MASTERY:
+			{
+				msg_format("Your %s glows brilliant white.", o_name);
+				dispel_monsters(100);
+				o_ptr->timeout = rand_int(1000)+1000;
+				break;
+			}
+
+		case SV_RING_METEORS:
+			{
+				msg_format("Your %s releases a swarm of meteors.", o_name);
+				if (!get_aim_dir(&dir)) return;
+				fire_meteor(GF_METEOR, dir,
+									30, 2, 2, 1 + randint(7));
+				o_ptr->timeout = rand_int(15) + 15;
 				break;
 			}
 		}
 
diff --recursive --unified=4 angband-291/src/config.h antiband/src/config.h
--- angband-291/src/config.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/config.h	Fri Nov  2 12:19:30 2001
@@ -304,9 +304,9 @@
 
 /*
  * Allow "Borgs" to yield "high scores"
  */
-/* #define SCORE_BORGS */
+#define SCORE_BORGS
 
 /*
  * Allow "Cheaters" to yield "high scores"
  */
@@ -381,17 +381,11 @@
 #define DRS_SMART_OPTIONS
 
 
 /*
- * OPTION: Allow the use of random artifacts (see "randart.c").
- */
-#define GJW_RANDART
-
-
-/*
  * OPTION: Allow the use of "sound" in various places.
  */
-#define USE_SOUND
+/* #define USE_SOUND */
 
 /*
  * OPTION: Allow the use of "graphics" in various places
  */
@@ -540,9 +534,8 @@
 # undef MONSTER_FLOW
 # undef ALLOW_TERROR
 # undef WDT_TRACK_OPTIONS
 # undef DRS_SMART_OPTIONS
-# undef GJW_RANDART
 # undef ALLOW_OLD_SAVEFILES
 # undef ALLOW_BORG
 # undef ALLOW_DEBUG
 # undef ALLOW_SPOILERS
diff --recursive --unified=4 angband-291/src/defines.h antiband/src/defines.h
--- angband-291/src/defines.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/defines.h	Tue Nov 20 19:33:38 2001
@@ -40,23 +40,23 @@
 
 /*
  * Current version string
  */
-#define VERSION_STRING	"2.9.1"
+#define VERSION_STRING	"an2.9.1"
 
 /*
  * Current version numbers
  */
-#define VERSION_MAJOR	2
+#define VERSION_MAJOR	12
 #define VERSION_MINOR	9
 #define VERSION_PATCH	1
 #define VERSION_EXTRA	0
 
 
 /*
  * Version of random artifact code.
  */
-#define RANDART_VERSION	62
+#define RANDART_VERSION	63
 
 
 /*
  * Number of grids in each block (vertically)
@@ -241,13 +241,13 @@
 #define MON_DRAIN_LIFE	2		/* Percent of player exp drained per hit */
 #define USE_DEVICE      3		/* x> Harder devices x< Easier devices     */
 
 /*
- * There is a 1/20 (5%) chance of inflating the requested object_level
+ * There is a 1/12 (8.3%) chance of inflating the requested object_level
  * during the creation of an object (see "get_obj_num()" in "object.c").
  * Lower values yield better objects more often.
  */
-#define GREAT_OBJ	20
+#define GREAT_OBJ	12
 
 /*
  * There is a 1/20 (5%) chance that ego-items with an inflated base-level are
  * generated when an object is turned into an ego-item (see make_ego_item()
@@ -255,13 +255,13 @@
  */
 #define GREAT_EGO	20
 
 /*
- * There is a 1/50 (2%) chance of inflating the requested monster_level
+ * There is a 1/25 (4%) chance of inflating the requested monster_level
  * during the creation of a monsters (see "get_mon_num()" in "monster.c").
  * Lower values yield harder monsters more often.
  */
-#define NASTY_MON	50		/* 1/chance of inflated monster level */
+#define NASTY_MON	25		/* 1/chance of inflated monster level */
 
 
 
 /*
@@ -827,8 +827,12 @@
  * rings, amulets), and the ones from 16 to 127 are "normal".
  */
 #define ART_MIN_NORMAL		16
 
+/*
+ * Hack -- start of the random artifacts
+ */
+#define ART_MIN_RANDART		128
 
 
 /*** Ego-Item indexes (see "lib/edit/e_info.txt") ***/
 
@@ -904,9 +908,9 @@
 #define EGO_SLOW_DESCENT	56
 #define EGO_QUIET			57
 #define EGO_MOTION			58
 #define EGO_SPEED			59
-/* xxx */
+#define EGO_ELVENKIND_2		60
 #define EGO_NOISE			61
 #define EGO_SLOWNESS		62
 #define EGO_ANNOYANCE		63
 
@@ -922,11 +926,11 @@
 #define EGO_BRAND_ACID		72
 #define EGO_BRAND_ELEC		73
 #define EGO_BRAND_FIRE		74
 #define EGO_BRAND_COLD		75
-/* xxx */
-/* xxx */
-/* xxx */
+#define EGO_BRAND_NETHR		76
+#define EGO_BRAND_NEXUS		77
+#define EGO_BRAND_CHAOS		78
 /* xxx */
 #define EGO_SLAY_ANIMAL		80
 #define EGO_SLAY_EVIL		81
 #define EGO_SLAY_UNDEAD		82
@@ -943,10 +947,10 @@
 #define EGO_KILL_TROLL		85
 #define EGO_KILL_GIANT		86
 #define EGO_KILL_DRAGON		95
 /* xxx */
-/* xxx */
-/* xxx */
+#define EGO_PIERCING		97
+#define EGO_SLAYING_2		98
 /* xxx */
 #define EGO_DIGGING			100
 /* xxx */
 #define EGO_MORGUL			102
@@ -958,10 +962,10 @@
 /* xxx */
 /* xxx */
 #define EGO_EXTRA_MIGHT		108
 #define EGO_EXTRA_SHOTS		109
-/* xxx */
-/* xxx */
+#define EGO_ELVENKIND_3		110
+#define EGO_POWER_2			111
 
 /* Ammo */
 #define EGO_HURT_ANIMAL		112
 #define EGO_HURT_EVIL		113
@@ -1030,9 +1034,9 @@
 #define TV_SCROLL       70
 #define TV_POTION       75
 #define TV_FLASK        77
 #define TV_FOOD         80
-#define TV_MAGIC_BOOK   90
+#define TV_MAGIC_BOOK   90	
 #define TV_PRAYER_BOOK  91
 #define TV_GOLD         100	/* Gold can only be picked up by players */
 
 
@@ -1186,26 +1190,28 @@
 #define SV_LITE_THRAIN		6
 
 /* The "sval" codes for TV_AMULET */
 #define SV_AMULET_DOOM			0
-#define SV_AMULET_TELEPORT		1
+#define SV_AMULET_AGGRAVATION	1
 #define SV_AMULET_ADORNMENT		2
 #define SV_AMULET_SLOW_DIGEST	3
 #define SV_AMULET_RESIST_ACID	4
 #define SV_AMULET_SEARCHING		5
 #define SV_AMULET_WISDOM		6
 #define SV_AMULET_CHARISMA		7
 #define SV_AMULET_THE_MAGI		8
-/* xxx */
-#define SV_AMULET_CARLAMMAS		10
-#define SV_AMULET_INGWE			11
-#define SV_AMULET_DWARVES		12
+#define SV_AMULET_CLAIRVOYANCE	9
+#define SV_AMULET_THE_PLANES	10
+#define SV_AMULET_RESIST_CONFU	11
+#define SV_AMULET_CARLAMMAS		15
+#define SV_AMULET_INGWE			16
+#define SV_AMULET_DWARVES		17
 
 /* The sval codes for TV_RING */
 #define SV_RING_WOE				0
 #define SV_RING_AGGRAVATION		1
-#define SV_RING_WEAKNESS		2
-#define SV_RING_STUPIDITY		3
+/* xxx */
+/* xxx */
 #define SV_RING_TELEPORTATION	4
 /* xxx */
 #define SV_RING_SLOW_DIGESTION	6
 #define SV_RING_FEATHER_FALL	7
@@ -1238,8 +1244,14 @@
 #define SV_RING_NARYA			34
 #define SV_RING_NENYA			35
 #define SV_RING_VILYA			36
 #define SV_RING_POWER			37
+#define SV_RING_RESISTANCE		38
+#define SV_RING_MASTERY			39
+#define SV_RING_METEORS			40
+#define SV_RING_ELEMENTS		41 /* The Ring of Elemental Mastery */
+#define SV_RING_ELVENKIND		42
+#define SV_RING_DWARVENKIND		43
 
 
 /* The "sval" codes for TV_STAFF */
 #define SV_STAFF_DARKNESS		0
@@ -1497,9 +1509,9 @@
 
 /*
  * Special "sval" limit -- first "good" magic/prayer book
  */
-#define SV_BOOK_MIN_GOOD	4
+#define SV_BOOK_MIN_GOOD	8
 
 
 
 /*** Monster blow constants ***/
@@ -1869,11 +1881,11 @@
 #define TR1_SLAY_TROLL		0x00200000L	/* Weapon slays troll */
 #define TR1_SLAY_GIANT		0x00400000L	/* Weapon slays giant */
 #define TR1_SLAY_DRAGON		0x00800000L	/* Weapon slays dragon */
 #define TR1_KILL_DRAGON		0x01000000L	/* Weapon kills dragon */
-#define TR1_XXX5			0x02000000L
-#define TR1_XXX6			0x04000000L
-#define TR1_XXX7			0x08000000L
+#define TR1_BRAND_NETHR		0x02000000L	/* Weapon has nether brand */
+#define TR1_BRAND_NEXUS		0x04000000L	/* Weapon has nexus brand */
+#define TR1_BRAND_CHAOS		0x08000000L /* Weapon has chaos brand */
 #define TR1_BRAND_ACID		0x10000000L	/* Weapon has acid brand */
 #define TR1_BRAND_ELEC		0x20000000L	/* Weapon has elec brand */
 #define TR1_BRAND_FIRE		0x40000000L	/* Weapon has fire brand */
 #define TR1_BRAND_COLD		0x80000000L	/* Weapon has cold brand */
@@ -1961,8 +1973,14 @@
 #define TR3_IGNORE_MASK \
 	(TR3_IGNORE_ACID | TR3_IGNORE_ELEC | TR3_IGNORE_FIRE | \
 	 TR3_IGNORE_COLD )
 
+/*
+ * Flag set 3 -- mask for "curse" flags.
+ */
+#define TR3_CURSED_MASK \
+	(TR3_LIGHT_CURSE | TR3_HEAVY_CURSE | TR3_PERMA_CURSE)
+
 
 /*
  * Hack -- special "xtra" object flag info (type)
  */
@@ -2047,9 +2065,9 @@
  * New monster race bit flags
  */
 #define RF2_STUPID			0x00000001	/* Monster is stupid */
 #define RF2_SMART			0x00000002	/* Monster is smart */
-#define RF2_XXX1			0x00000004	/* (?) */
+#define RF2_ATTR_RANDOM		0x00000004	/* Random color */
 #define RF2_XXX2			0x00000008	/* (?) */
 #define RF2_INVISIBLE		0x00000010	/* Monster avoids vision */
 #define RF2_COLD_BLOOD		0x00000020	/* Monster avoids infra */
 #define RF2_EMPTY_MIND		0x00000040	/* Monster avoids telepathy */
@@ -2118,9 +2136,9 @@
 /*
  * New monster race bit flags
  */
 #define RF4_SHRIEK			0x00000001	/* Shriek for help */
-#define RF4_XXX2			0x00000002	/* (?) */
+#define RF4_SCREAM			0x00000002	/* Scream for help */
 #define RF4_XXX3			0x00000004	/* (?) */
 #define RF4_XXX4			0x00000008	/* (?) */
 #define RF4_ARROW_1			0x00000010	/* Fire an arrow (light) */
 #define RF4_ARROW_2			0x00000020	/* Fire an arrow (heavy) */
@@ -2296,9 +2314,8 @@
 
 #define RF6_ATTACK_MASK \
 	(0L)
 
-
 /*
  * Summoning spells
  */
 #define RF4_SUMMON_MASK \
@@ -2382,8 +2399,29 @@
 
 #define RF6_INNATE_MASK \
 	(0L)
 
+/*
+ * Breath attacks
+ */
+#define RF4_INDIRECT_MASK \
+	(RF4_BR_ACID | RF4_BR_ELEC | RF4_BR_FIRE | RF4_BR_COLD | RF4_BR_POIS | \
+	 RF4_BR_NETH | RF4_BR_LITE | RF4_BR_DARK | RF4_BR_CONF | RF4_BR_SOUN | \
+	 RF4_BR_CHAO | RF4_BR_DISE | RF4_BR_NEXU | RF4_BR_TIME | RF4_BR_INER | \
+	 RF4_BR_GRAV | RF4_BR_SHAR | RF4_BR_PLAS | RF4_BR_WALL | RF4_BR_MANA)
+
+#define RF5_INDIRECT_MASK \
+	(RF5_BA_ACID | RF5_BA_ELEC | RF5_BA_FIRE | RF5_BA_COLD | RF5_BA_POIS | \
+	 RF5_BA_NETH | RF5_BA_WATE | RF5_BA_MANA | RF5_BA_DARK)
+
+#define RF6_INDIRECT_MASK \
+	(0L)
+
+/* 
+ * Monsters that come in groups
+ */
+#define RF1_GROUP_MASK \
+	(RF1_ESCORT | RF1_ESCORTS | RF1_FRIEND | RF1_FRIENDS)
 
 
 /*** Option Definitions ***/
 
@@ -2707,11 +2745,12 @@
 
 
 /*
  * Artifacts use the "name1" field
+ * Randarts use the "name3" field
  */
 #define artifact_p(T) \
-	((T)->name1 ? TRUE : FALSE)
+	(((T)->name1 || (T)->name3) ? TRUE : FALSE)
 
 /*
  * Ego-Items use the "name2" field
  */
@@ -3097,6 +3136,126 @@
 #define ACT_WOR                 43
 #define ACT_CONFUSE             44
 #define ACT_PROBE               45
 #define ACT_FIREBRAND           46
+#define ACT_ELEMENTS			47
+
+#define ACT_MAX                 48
 
-#define ACT_MAX                 47
+#define SPELL_MAGIC_MISSILE					0
+#define SPELL_DETECT_MONSTERS				1
+#define SPELL_PHASE_DOOR					2
+#define SPELL_LIGHT_AREA					3
+#define SPELL_TREASURE_DETECTION			4
+#define SPELL_CURE_LIGHT_WOUNDS				5
+#define SPELL_OBJECT_DETECTION				6
+#define SPELL_FIND_HIDDEN_TRAPS_AND_DOORS	7
+#define SPELL_STINKING_CLOUD				8
+#define SPELL_CONFUSE_MONSTER				9
+#define SPELL_LIGHTNING_BOLT				10
+#define SPELL_TRAP_AND_DOOR_DESTRUCTION		11
+#define SPELL_SLEEP							12
+#define SPELL_CURE_POISON					13
+#define SPELL_TELEPORT_SELF					14
+#define SPELL_SPEAR_OF_LIGHT				15
+#define SPELL_FROST_BOLT					16
+#define SPELL_TURN_STONE_TO_MUD				17
+#define SPELL_SATISFY_HUNGER				18
+#define SPELL_RECHARGE_ITEM					19
+#define SPELL_SLEEP_2						20
+#define SPELL_POLYMORPH_OTHER				21
+#define SPELL_IDENTIFY						22
+#define SPELL_SLEEP_3						23
+#define SPELL_FIRE_BOLT						24
+#define SPELL_SLOW_MONSTER					25
+#define SPELL_FROST_BALL					26
+#define SPELL_RECHARGE_ITEM_2				27
+#define SPELL_TELEPORT_OTHER				28
+#define SPELL_HASTE_SELF					29
+#define SPELL_FIRE_BALL						30
+#define SPELL_WORD_OF_DESTRUCTION			31
+#define SPELL_GENOCIDE						32
+#define SPELL_DOOR_CREATION					33
+#define SPELL_STAIR_CREATION				34
+#define SPELL_TELEPORT_LEVEL				35
+#define SPELL_EARTHQUAKE					36
+#define SPELL_WORD_OF_RECALL				37
+#define SPELL_ACID_BOLT						38
+#define SPELL_CLOUD_KILL					39
+#define SPELL_ACID_BALL						40
+#define SPELL_ICE_STORM						41
+#define SPELL_METEOR_SWARM					42
+#define SPELL_MANA_STORM					43
+#define SPELL_DETECT_EVIL					44
+#define SPELL_DETECT_ENCHANTMENT			45
+#define SPELL_RECHARGE_ITEM_3				46
+#define SPELL_GENOCIDE2						47
+#define SPELL_MASS_GENOCIDE					48
+#define SPELL_RESIST_FIRE					49
+#define SPELL_RESIST_COLD					50
+#define SPELL_RESIST_ACID					51
+#define SPELL_RESIST_POISON					52
+#define SPELL_RESISTANCE					53
+#define SPELL_HEROISM						54
+#define SPELL_SHIELD						55
+#define SPELL_BERSERKER						56
+#define SPELL_ESSENCE_OF_SPEED				57
+#define SPELL_GLOBE_OF_INVULNERABILITY		58
+
+#define PRAYER_DETECT_EVIL					0
+#define PRAYER_CURE_LIGHT_WOUNDS			1
+#define PRAYER_BLESS						2
+#define PRAYER_REMOVE_FEAR					3
+#define PRAYER_CALL_LIGHT					4
+#define PRAYER_FIND_TRAPS					5
+#define PRAYER_DETECT_DOORS_AND_STAIRS		6
+#define PRAYER_SLOW_POISON					7
+#define PRAYER_SCARE_MONSTER				8
+#define PRAYER_PORTAL						9
+#define PRAYER_CURE_SERIOUS_WOUNDS			10
+#define PRAYER_CHANT						11
+#define PRAYER_SANCTUARY					12
+#define PRAYER_SATISFY_HUNGER				13
+#define PRAYER_REMOVE_CURSE					14
+#define PRAYER_RESIST_HEAT_AND_COLD			15
+#define PRAYER_NEUTRALIZE_POISON			16
+#define PRAYER_ORB_OF_DRAINING				17
+#define PRAYER_CURE_CRITICAL_WOUNDS			18
+#define PRAYER_SENSE_INVISIBLE				19
+#define PRAYER_PROTECTION_FROM_EVIL			20
+#define PRAYER_EARTHQUAKE					21
+#define PRAYER_SENSE_SURROUNDINGS			22
+#define PRAYER_CURE_MORTAL_WOUNDS			23
+#define PRAYER_TURN_UNDEAD					24
+#define PRAYER_PRAYER						25
+#define PRAYER_DISPEL_UNDEAD				26
+#define PRAYER_HEAL							27
+#define PRAYER_DISPEL_EVIL					28
+#define PRAYER_GLYPH_OF_WARDING				29
+#define PRAYER_HOLY_WORD					30
+#define PRAYER_DETECT_MONSTERS				31
+#define PRAYER_DETECTION					32
+#define PRAYER_PERCEPTION					33
+#define PRAYER_PROBING						34
+#define PRAYER_CLAIRVOYANCE					35
+#define PRAYER_CURE_SERIOUS_WOUNDS2			36
+#define PRAYER_CURE_MORTAL_WOUNDS2			37
+#define PRAYER_HEALING						38
+#define PRAYER_RESTORATION					39
+#define PRAYER_REMEMBERANCE					40
+#define PRAYER_DISPEL_UNDEAD2				41
+#define PRAYER_DISPEL_EVIL2					42
+#define PRAYER_BANISHMENT					43
+#define PRAYER_WORD_OF_DESTRUCTION			44
+#define PRAYER_ANNIHILATION					45
+#define PRAYER_UNBARRING_WAYS				46
+#define PRAYER_RECHARGING					47
+#define PRAYER_DISPEL_CURSE					48
+#define PRAYER_ENCHANT_WEAPON				49
+#define PRAYER_ENCHANT_ARMOR				50
+#define PRAYER_ELEMENTAL_BRAND				51
+#define PRAYER_BLINK						52
+#define PRAYER_TELEPORT_SELF				53
+#define PRAYER_TELEPORT_OTHER				54
+#define PRAYER_TELEPORT_LEVEL				55
+#define PRAYER_WORD_OF_RECALL				56
+#define PRAYER_ALTER_REALITY				57
diff --recursive --unified=4 angband-291/src/dungeon.c antiband/src/dungeon.c
--- angband-291/src/dungeon.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/dungeon.c	Fri Nov  2 12:19:30 2001
@@ -704,8 +704,11 @@
 	if (p_ptr->poisoned) regen_amount = 0;
 	if (p_ptr->stun) regen_amount = 0;
 	if (p_ptr->cut) regen_amount = 0;
 
+	/* Nether brand is bad for you */
+	if (p_ptr->nethr_brand) regen_amount /= 3;
+
 	/* Regenerate Hit Points if needed */
 	if (p_ptr->chp < p_ptr->mhp)
 	{
 		regenhp(regen_amount);
@@ -2706,28 +2709,11 @@
 
 		/* Hack -- seed for town layout */
 		seed_town = rand_int(0x10000000);
 
-#ifdef GJW_RANDART
-
-		/* Hack -- seed for random artifacts */
-		seed_randart = rand_int(0x10000000);
-
-#endif
-
 		/* Roll up a new character */
 		player_birth();
 
-#ifdef GJW_RANDART
-
-		/* Randomize the artifacts */
-		if (adult_rand_artifacts)
-		{
-			do_randart(seed_randart);
-		}
-
-#endif
-
 		/* Hack -- enter the world */
 		turn = 1;
 	}
 
@@ -2856,10 +2842,11 @@
 
 				/* Increase age */
 				p_ptr->age++;
 
-				/* Mark savefile */
-				p_ptr->noscore |= 0x0001;
+				/* Mark savefile, except for borgs */
+				if (!p_ptr->noscore & 0x00F0)
+					p_ptr->noscore |= 0x0001;
 
 				/* Message */
 				msg_print("You invoke wizard mode and cheat death.");
 				msg_print(NULL);
diff --recursive --unified=4 angband-291/src/externs.h antiband/src/externs.h
--- angband-291/src/externs.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/externs.h	Sun Nov  4 12:55:04 2001
@@ -13,9 +13,8 @@
  * Note that some files have their own header files
  * (z-virt.h, z-util.h, z-form.h, term.h, random.h)
  */
 
-
 /*
  * Automatically generated "variable" declarations
  */
 
@@ -52,10 +51,13 @@
 extern s32b player_exp[PY_MAX_LEVEL];
 extern player_sex sex_info[MAX_SEXES];
 extern player_class class_info[MAX_CLASS];
 extern player_magic magic_info[MAX_CLASS];
+extern s16b spell_list[2][12][12];
+#if 0
 extern u32b spell_flags[2][9][2];
-extern cptr spell_names[2][64];
+#endif
+extern spell_data spells[2][64];
 extern byte chest_traps[64];
 extern cptr player_title[MAX_CLASS][PY_MAX_LEVEL/5];
 extern cptr color_names[16];
 extern cptr stat_names[6];
@@ -199,8 +201,9 @@
 extern header *a_head;
 extern artifact_type *a_info;
 extern char *a_name;
 extern char *a_text;
+extern randart_type *x_info;
 extern header *e_head;
 extern ego_item_type *e_info;
 extern char *e_name;
 extern char *e_text;
@@ -294,13 +297,13 @@
 extern bool test_hit_fire(int chance, int ac, int vis);
 extern bool test_hit_norm(int chance, int ac, int vis);
 extern sint critical_shot(int weight, int plus, int dam);
 extern sint critical_norm(int weight, int plus, int dam);
-extern sint tot_dam_aux(object_type *o_ptr, int tdam, monster_type *m_ptr);
+extern sint tot_dam_aux(object_type *o_ptr, s32b tdam, monster_type *m_ptr);
 extern void search(void);
 extern void py_pickup(int pickup);
 extern void hit_trap(int y, int x);
-extern void py_attack(int y, int x);
+extern int py_attack(int y, int x);
 extern void move_player(int dir, int jumping);
 extern void run_step(int dir);
 
 /* cmd2.c */
@@ -477,11 +480,11 @@
 extern void object_flags(object_type *o_ptr, u32b *f1, u32b *f2, u32b *f3);
 extern void object_flags_known(object_type *o_ptr, u32b *f1, u32b *f2, u32b *f3);
 extern void object_desc(char *buf, object_type *o_ptr, int pref, int mode);
 extern void object_desc_store(char *buf, object_type *o_ptr, int pref, int mode);
-extern cptr item_activation(object_type *o_ptr);
+extern cptr item_activation(object_type *o_ptr, char *buffer);
 extern int identify_random_gen(object_type *o_ptr, cptr *info, int len);
-extern bool identify_fully_aux(object_type *o_ptr);
+extern bool identify_fully_aux(object_type *o_ptr, char *o_name);
 extern char index_to_label(int i);
 extern s16b label_to_inven(int c);
 extern s16b label_to_equip(int c);
 extern s16b wield_slot(object_type *o_ptr);
@@ -514,10 +517,10 @@
 extern s16b lookup_kind(int tval, int sval);
 extern void object_wipe(object_type *o_ptr);
 extern void object_copy(object_type *o_ptr, object_type *j_ptr);
 extern void object_prep(object_type *o_ptr, int k_idx);
-extern void apply_magic(object_type *o_ptr, int lev, bool okay, bool good, bool great);
-extern bool make_object(object_type *j_ptr, bool good, bool great);
+extern void apply_magic(object_type *o_ptr, int lev, bool okay, bool good, bool great, bool force_randart);
+extern bool make_object(object_type *j_ptr, bool good, bool great, bool force_randart);
 extern bool make_gold(object_type *j_ptr);
 extern s16b floor_carry(int y, int x, object_type *j_ptr);
 extern void drop_near(object_type *j_ptr, int chance, int y, int x);
 extern void acquirement(int y1, int x1, int num, bool great);
@@ -545,10 +548,16 @@
 extern void display_spell_list(void);
 extern s16b spell_chance(int spell);
 extern bool spell_okay(int spell, bool known);
 extern void spell_info(char *p, int spell);
-extern void print_spells(byte *spells, int num, int y, int x);
+extern void print_spells(u16b *spells, int num, int y, int x);
 extern void display_koff(int k_idx);
+extern bool make_ego_item(object_type *o_ptr, bool cursed, int level);
+
+/* randart.c */
+extern s32b artifact_power(object_type *o_ptr);
+extern bool make_randart_stupid(object_type *o_ptr);
+extern bool make_randart(object_type *o_ptr, bool curse);
 
 /* save.c */
 extern bool save_player(void);
 extern bool load_player(void);
@@ -595,9 +604,9 @@
 extern bool detect_monsters_evil(void);
 extern bool detect_all(void);
 extern void stair_creation(void);
 extern bool enchant(object_type *o_ptr, int n, int eflag);
-extern bool enchant_spell(int num_hit, int num_dam, int num_ac);
+extern bool enchant_spell(int num_hit, int num_dam, int num_ac, bool ego);
 extern bool ident_spell(void);
 extern bool identify_fully(void);
 extern bool recharge(int num);
 extern bool speed_monsters(void);
@@ -608,8 +617,9 @@
 extern bool dispel_undead(int dam);
 extern bool dispel_evil(int dam);
 extern bool dispel_monsters(int dam);
 extern void aggravate_monsters(int who);
+extern void wake_monsters(int who);
 extern bool genocide(void);
 extern bool mass_genocide(void);
 extern bool probing(void);
 extern void destroy_area(int y1, int x1, int r, bool full);
@@ -618,8 +628,9 @@
 extern void unlite_room(int y1, int x1);
 extern bool lite_area(int dam, int rad);
 extern bool unlite_area(int dam, int rad);
 extern bool fire_ball(int typ, int dir, int dam, int rad);
+extern bool fire_meteor(int typ, int dir, int dam, int rad, int scatter, int num);
 extern bool fire_bolt(int typ, int dir, int dam);
 extern bool fire_beam(int typ, int dir, int dam);
 extern bool fire_bolt_or_beam(int prob, int typ, int dir, int dam);
 extern bool lite_line(int dir);
@@ -822,11 +833,4 @@
 /* object1.c */
 extern void show_floor(int *floor_list, int floor_num);
 
 #endif /* ALLOW_EASY_FLOOR */
-
-#ifdef GJW_RANDART
-
-/* randart.c */
-extern int do_randart(u32b randart_seed);
-
-#endif /* GJW_RANDART */
diff --recursive --unified=4 angband-291/src/files.c antiband/src/files.c
--- angband-291/src/files.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/files.c	Tue Nov 20 12:09:14 2001
@@ -1222,9 +1222,9 @@
 	char buf[160];
 
 
 	/* Upper middle */
-	col = 26;
+	col = 19;
 
 
 	/* Age */
 	Term_putstr(col, 3, -1, TERM_WHITE, "Age");
@@ -1659,8 +1659,27 @@
 				{
 					c_put_str(TERM_WHITE, "*", row, col+n);
 				}
 
+				/* Check bonus flags */
+				else if ((x == 3) && (f[set] & flag))
+				{
+					byte a;
+					char c;
+
+					if (o_ptr->pval >= 0)
+						a = TERM_L_GREEN;
+					else
+						a = TERM_RED;
+
+					if (ABS(o_ptr->pval) < 10)
+						c = '0' + ABS(o_ptr->pval);
+					else
+						c = '*';
+
+					Term_putch(row, col+n, a, c);
+				}
+
 				/* Check flags */
 				else if (f[set] & flag)
 				{
 					c_put_str(TERM_WHITE, "+", row, col+n);
@@ -1678,10 +1697,19 @@
 
 			/* Default */
 			c_put_str(TERM_SLATE, ".", row, col+n);
 
+			/* Hack - basic resists are special */
+			if ((x == 0) && (y < 4) && (f[set] & flag))
+			{
+				c_put_str(TERM_WHITE, "!", row, col+n);
+			}
+
 			/* Check flags */
-			if (f[set] & flag) c_put_str(TERM_WHITE, "+", row, col+n);
+			else if (f[set] & flag)
+			{
+				c_put_str(TERM_WHITE, "+", row, col+n);
+			}
 
 			/* Advance */
 			row++;
 		}
@@ -1776,20 +1804,24 @@
 	/* Row */
 	row = 3;
 
 	/* Column */
-	col = 42;
+	col = 35;
 
 	/* Print out the labels for the columns */
 	c_put_str(TERM_WHITE, "  Self", row-1, col+5);
 	c_put_str(TERM_WHITE, " RB", row-1, col+12);
 	c_put_str(TERM_WHITE, " CB", row-1, col+16);
 	c_put_str(TERM_WHITE, " EB", row-1, col+20);
 	c_put_str(TERM_WHITE, "  Best", row-1, col+24);
+	c_put_str(TERM_WHITE, " Limit", row-1, col+31);
 
 	/* Display the stats */
 	for (i = 0; i < A_MAX; i++)
 	{
+		int limit;
+		int bonus;
+
 		/* Reduced */
 		if (p_ptr->stat_use[i] < p_ptr->stat_top[i])
 		{
 			/* Use lowercase stat name */
@@ -1803,9 +1835,9 @@
 			put_str(stat_names[i], row+i, col);
 		}
 
 		/* Indicate natural maximum */
-		if (p_ptr->stat_max[i] == 18+100)
+		if (p_ptr->stat_max[i] == p_ptr->stat_lim[i])
 		{
 			put_str("!", row+i, col+3);
 		}
 
@@ -1828,13 +1860,23 @@
 		/* Resulting "modified" maximum value */
 		cnv_stat(p_ptr->stat_top[i], buf);
 		c_put_str(TERM_L_GREEN, buf, row+i, col+24);
 
+		/* Absolute limit */
+		if (adult_maximize)
+			bonus = rp_ptr->r_adj[i] + cp_ptr->c_adj[i];
+		else
+			bonus = 0;
+		limit = modify_stat_value(p_ptr->stat_lim[i], p_ptr->stat_add[i] + bonus);
+
+		cnv_stat(limit, buf);
+		c_put_str(TERM_L_GREEN, buf, row+i, col+31);
+
 		/* Only display stat_use if not maximal */
 		if (p_ptr->stat_use[i] < p_ptr->stat_top[i])
 		{
 			cnv_stat(p_ptr->stat_use[i], buf);
-			c_put_str(TERM_YELLOW, buf, row+i, col+31);
+			c_put_str(TERM_YELLOW, buf, row+i, col+38);
 		}
 	}
 }
 
@@ -1865,9 +1907,9 @@
 	/* Row */
 	row = 3;
 
 	/* Column */
-	col = 26;
+	col = 19;
 
 	/* Header */
 	c_put_str(TERM_WHITE, "abcdefghijkl@", row-1, col);
 
@@ -1957,9 +1999,9 @@
 		Term_putch(col, row+stat, a, c);
 	}
 
 	/* Column */
-	col = 26;
+	col = 19;
 
 	/* Footer */
 	c_put_str(TERM_WHITE, "abcdefghijkl@", row+6, col);
 
@@ -2077,10 +2119,10 @@
 	if (!fff) return (-1);
 
 
 	/* Begin dump */
-	fprintf(fff, "  [Angband %d.%d.%d Character Dump]\n\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	fprintf(fff, "  [Antiband %d.%d.%d Character Dump]\n\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 
 
 	/* Display player */
 	display_player(0);
@@ -2509,10 +2551,10 @@
 		}
 
 
 		/* Show a general "title" */
-		prt(format("[Angband %d.%d.%d, %s, Line %d/%d]",
-		           VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH,
+		prt(format("[Antiband %d.%d.%d, %s, Line %d/%d]",
+		           VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH,
 		           caption, line, size), 0, 0);
 
 
 		/* Prompt -- menu screen */
@@ -2856,9 +2898,9 @@
 	/* Refresh */
 	Term_fresh();
 
 	/* The player is not dead */
-	strcpy(p_ptr->died_from, "(saved)");
+ 	strcpy(p_ptr->died_from, "(saved)");
 
 	/* Forbid suspend */
 	signals_ignore_tstp();
 
@@ -3258,15 +3300,15 @@
 
 	/* Description */
 	object_desc(o_name, o_ptr, TRUE, 3);
 
-	/* Describe */
-	msg_format("Examining %s...", o_name);
-
 	/* Describe it fully */
-	if (!identify_fully_aux(o_ptr))
+	if (!identify_fully_aux(o_ptr, o_name))
 	{
-		msg_print("You see nothing special.");
+		/* Redescribe */
+		object_desc(o_name, o_ptr, TRUE, 3);
+
+		msg_format("Examining %s... you see nothing special.", o_name);
 		msg_print(NULL);
 	}
 }
 
@@ -3599,55 +3641,83 @@
 	int j;
 
 	high_score the_score;
 
+	bool is_wizard = FALSE;
+	bool is_borg = FALSE;
+	bool is_cheater = FALSE;
+
 
 	/* No score file */
 	if (highscore_fd < 0)
 	{
 		return (0);
 	}
 
-#ifndef SCORE_WIZARDS
 
 	/* Wizard-mode pre-empts scoring */
 	if (p_ptr->noscore & 0x000F)
 	{
+
+#ifdef SCORE_WIZARDS
+
+		is_wizard = TRUE;
+
+#else
+
 		msg_print("Score not registered for wizards.");
 		msg_print(NULL);
 		score_idx = -1;
 		return (0);
-	}
 
 #endif
-
-#ifndef SCORE_BORGS
+	
+	}
 
 	/* Borg-mode pre-empts scoring */
 	if (p_ptr->noscore & 0x00F0)
 	{
+
+#ifdef SCORE_BORGS
+
+		is_borg = TRUE;
+
+#else
+
 		msg_print("Score not registered for borgs.");
 		msg_print(NULL);
 		score_idx = -1;
 		return (0);
-	}
+
 #endif
 
-#ifndef SCORE_CHEATERS
+	}
 
 	/* Cheaters are not scored */
 	for (j = OPT_SCORE; j < OPT_MAX; ++j)
 	{
 		if (!op_ptr->opt[j]) continue;
 
+		/* Do score borgs in auto-restart mode */
+		if (j == OPT_score_live && (p_ptr->noscore & 0x00F0))
+			continue;
+
+#ifdef SCORE_CHEATERS
+
+		is_cheater = TRUE;
+
+#else
+
 		msg_print("Score not registered for cheaters.");
 		msg_print(NULL);
 		score_idx = -1;
 		return (0);
-	}
 
 #endif
 
+	}
+
+
 	/* Hack -- Interupted */
 	if (!p_ptr->total_winner && streq(p_ptr->died_from, "Interrupting"))
 	{
 		msg_print("Score not registered due to interruption.");
@@ -3670,9 +3740,9 @@
 	(void)WIPE(&the_score, high_score);
 
 	/* Save the version */
 	sprintf(the_score.what, "%u.%u.%u",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 
 	/* Calculate and save the points */
 	sprintf(the_score.pts, "%9lu", (long)total_points());
 	the_score.pts[9] = '\0';
@@ -3694,9 +3764,29 @@
 	strftime(the_score.day, 10, "@%Y%m%d", localtime(&death_time));
 #endif
 
 	/* Save the player name (15 chars) */
-	sprintf(the_score.who, "%-.15s", op_ptr->full_name);
+	if (!is_wizard && !is_borg && !is_cheater)
+	{
+		sprintf(the_score.who, "%-.15s", op_ptr->full_name);
+	}
+	else
+	{
+		int tab = 0;
+
+		if (is_wizard)
+			the_score.who[tab++] = 'W';
+
+		if (is_borg)
+			the_score.who[tab++] = 'B';
+
+		if (is_cheater)
+			the_score.who[tab++] = 'C';
+
+		the_score.who[tab++] = '-';
+
+		sprintf(the_score.who + tab, "%.*s", 15 - tab, op_ptr->full_name);
+	}
 
 	/* Save the player info XXX XXX XXX */
 	sprintf(the_score.uid, "%7u", player_uid);
 	sprintf(the_score.sex, "%c", (p_ptr->psex ? 'm' : 'f'));
@@ -3727,8 +3817,34 @@
 	return (0);
 }
 
 
+/*
+ * Add the current character to the high score file (used by the borg to simulate
+ * a death)
+ */
+errr score_current(void)
+{
+	char buf[1024];
+	errr result;
+
+	/* Build the filename */
+	path_build(buf, 1024, ANGBAND_DIR_APEX, "scores.raw");
+
+	/* Open the high score file, for reading/writing */
+	highscore_fd = fd_open(buf, O_RDWR);
+
+	/* Get time of death */
+	(void)time(&death_time);
+
+	result = enter_score();
+
+	/* Shut the high score file */
+	fd_close(highscore_fd);
+
+	return result;
+}
+
 
 /*
  * Enters a players name on a hi-score table, if "legal", and in any
  * case, displays some relevant portion of the high score list.
@@ -3794,9 +3910,9 @@
 
 
 	/* Save the version */
 	sprintf(the_score.what, "%u.%u.%u",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 
 	/* Calculate and save the points */
 	sprintf(the_score.pts, "%9lu", (long)total_points());
 
diff --recursive --unified=4 angband-291/src/generate.c antiband/src/generate.c
--- angband-291/src/generate.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/generate.c	Thu Nov 15 02:19:28 2001
@@ -103,9 +103,9 @@
 /*
  * Dungeon generation values
  */
 #define DUN_ROOMS	50	/* Number of rooms to attempt */
-#define DUN_UNUSUAL	200	/* Level/chance of unusual room */
+#define DUN_UNUSUAL	150	/* Level/chance of unusual room */
 #define DUN_DEST	30	/* 1/chance of having a destroyed level */
 
 /*
  * Dungeon tunnel generation values
@@ -993,30 +993,41 @@
 
 	/* Hack -- Occasional pillar room */
 	if (rand_int(20) == 0)
 	{
-		for (y = y1; y <= y2; y += 2)
+		int pillar_p = 5 + rand_int(20);
+
+		for (y = y1 + 1; y <= y2 - 1; y++)
 		{
-			for (x = x1; x <= x2; x += 2)
+			for (x = x1 + 1; x <= x2 - 1; x++)
 			{
-				cave_set_feat(y, x, FEAT_WALL_INNER);
+				if (!cave_naked_bold(y - 1, x - 1)) continue;
+				if (!cave_naked_bold(y - 1, x)) continue;
+				if (!cave_naked_bold(y - 1, x + 1)) continue;
+				if (!cave_naked_bold(y, x - 1)) continue;
+				if (rand_int(100) < ((x == x1 + 1 || y == y1 + 1) ? pillar_p : pillar_p * 2))
+					cave_set_feat(y, x, FEAT_WALL_INNER);
 			}
 		}
 	}
 
 	/* Hack -- Occasional ragged-edge room */
-	else if (rand_int(50) == 0)
+	if (rand_int(50) == 0)
 	{
-		for (y = y1 + 2; y <= y2 - 2; y += 2)
+		for (y = y1 + 2; y <= y2 - 2; y++)
 		{
-			cave_set_feat(y, x1, FEAT_WALL_INNER);
-			cave_set_feat(y, x2, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y, x1, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y, x2, FEAT_WALL_INNER);
 		}
 
-		for (x = x1 + 2; x <= x2 - 2; x += 2)
+		for (x = x1 + 2; x <= x2 - 2; x++)
 		{
-			cave_set_feat(y1, x, FEAT_WALL_INNER);
-			cave_set_feat(y2, x, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y1, x, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y2, x, FEAT_WALL_INNER);
 		}
 	}
 }
 
@@ -1377,20 +1388,20 @@
 			break;
 		}
 
 
-		/* An inner room with a checkerboard */
+		/* An inner room with an odd layout */
 		case 4:
 		{
 			/* Open the inner room with a secret door */
 			generate_hole(y1-1, x1-1, y2+1, x2+1, FEAT_SECRET);
 
-			/* Checkerboard */
+			/* Random */
 			for (y = y1; y <= y2; y++)
 			{
 				for (x = x1; x <= x2; x++)
 				{
-					if ((x + y) & 0x01)
+					if (rand_int(100) < 40)
 					{
 						cave_set_feat(y, x, FEAT_WALL_INNER);
 					}
 				}
@@ -1500,8 +1511,25 @@
 	/* Okay */
 	return (TRUE);
 }
 
+/*
+ * Helper function for "monster nest (kennel)"
+ */
+static bool vault_aux_kennel(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require canine or hound */
+	if (!strchr("CZ", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
 
 /*
  * Helper function for "monster nest (undead)"
  */
@@ -1518,8 +1546,83 @@
 	/* Okay */
 	return (TRUE);
 }
 
+/*
+ * Helper function for "monster nest (terrarium)"
+ */
+static bool vault_aux_terrarium(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require reptile */
+	if (!strchr("JRM", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (elemental)"
+ */
+static bool vault_aux_elemental(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require elemental or vortex */
+	if (!strchr("Ev", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (hive)"
+ */
+static bool vault_aux_hive(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require insect or spider */
+	if (!strchr("FSIlcaK", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (greater dragon)"
+ */
+static bool vault_aux_greater_dragon(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require greater dragon */
+	if (!strchr("D", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
 
 /*
  * Helper function for "monster pit (orc)"
  */
@@ -1538,8 +1641,26 @@
 }
 
 
 /*
+ * Helper function for "monster pit (yeek)"
+ */
+static bool vault_aux_yeek(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "y" monsters */
+	if (!strchr("y", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+/*
  * Helper function for "monster pit (troll)"
  */
 static bool vault_aux_troll(int r_idx)
 {
@@ -1620,8 +1741,103 @@
 
 
 
 /*
+ * Helper function for "monster pit (human)"
+ */
+static bool vault_aux_human(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "p" monsters */
+	if (!strchr("p", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (mimic)"
+ */
+static bool vault_aux_mimic(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require mimic monsters */
+	if (!strchr("$?!=~[", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (ogre)"
+ */
+static bool vault_aux_ogre(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require ogre */
+	if (!strchr("O", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (chapel)"
+ */
+static bool vault_aux_chapel(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "A" monsters or priests */
+	if (!strchr("A", r_ptr->d_char) && !strstr((r_name + r_ptr->name), "riest")) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (dark elf)"
+ */
+static bool vault_aux_dark_elf(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require dark elves */
+	if (!strstr((r_name + r_ptr->name), "ark el")) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
  * Type 5 -- Monster nests
  *
  * A monster nest is a "big" room, with an "inner" room, containing
  * a "collection" of monsters of a given type strewn about the room.
@@ -1691,38 +1907,102 @@
 
 	/* Hack -- Choose a nest type */
 	tmp = randint(p_ptr->depth);
 
+	/* Sometimes boost depth */
+	while (rand_int(5) == 0)
+		tmp += randint(10);
+
+	/* Monster nest (hive) */
+	if (tmp < 10)
+	{
+		/* Describe */
+		name = "hive";
+
+		/* Restrict to insect */
+		get_mon_num_hook = vault_aux_hive;
+	}
+
 	/* Monster nest (jelly) */
-	if (tmp < 30)
+	else if (tmp < 15)
 	{
 		/* Describe */
 		name = "jelly";
 
 		/* Restrict to jelly */
 		get_mon_num_hook = vault_aux_jelly;
 	}
 
+	/* Monster nest (terrarium) */
+	else if (tmp < 20)
+	{
+		/* Describe */
+		name = "terrarium";
+
+		/* Restrict to reptiles */
+		get_mon_num_hook = vault_aux_terrarium;
+	}
+
+	/* Monster nest (mimic) */
+	else if (tmp < 25)
+	{
+		/* Message */
+		name = "mimic";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_mimic;
+	}
+	
 	/* Monster nest (animal) */
-	else if (tmp < 50)
+	else if (tmp < 35)
 	{
 		/* Describe */
 		name = "animal";
 
 		/* Restrict to animal */
 		get_mon_num_hook = vault_aux_animal;
 	}
 
+	/* Monster nest (kennel) */
+	else if (tmp < 40)
+	{
+		/* Describe */
+		name = "kennel";
+
+		/* Restrict to kennel */
+		get_mon_num_hook = vault_aux_kennel;
+	}
+
+	/* Monster nest (elemental) */
+	else if (tmp < 45)
+	{
+		/* Describe */
+		name = "elemental";
+
+		/* Restrict to elemental */
+		get_mon_num_hook = vault_aux_elemental;
+	}
+
 	/* Monster nest (undead) */
-	else
+	else if (tmp < 70)
 	{
 		/* Describe */
 		name = "undead";
 
 		/* Restrict to undead */
 		get_mon_num_hook = vault_aux_undead;
 	}
 
+	/* Monster nest (greater dragon) */
+	else
+	{
+		/* Describe */
+		name = "greater dragon";
+
+		/* Restrict to greater dragons */
+		get_mon_num_hook = vault_aux_greater_dragon;
+	}
+
 	/* Prepare allocation table */
 	get_mon_num_prep();
 
 
@@ -1756,9 +2036,9 @@
 	}
 
 
 	/* Increase the level rating */
-	rating += 10;
+	/* rating += 10; */
 
 	/* (Sometimes) Cause a "special feeling" (for "Monster Nests") */
 	if ((p_ptr->depth <= 40) &&
 	    (randint(p_ptr->depth * p_ptr->depth + 1) < 300))
@@ -1870,18 +2150,62 @@
 
 	/* Choose a pit type */
 	tmp = randint(p_ptr->depth);
 
+	/* Sometimes boost depth */
+	while (rand_int(5) == 0)
+		tmp += randint(10);
+
+	/* Yeek pit */
+	if (tmp < 3)
+	{
+		/* Message */
+		name = "yeek";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_yeek;
+	}
+
 	/* Orc pit */
-	if (tmp < 20)
+	else if (tmp < 20)
 	{
 		/* Message */
 		name = "orc";
 
 		/* Restrict monster selection */
 		get_mon_num_hook = vault_aux_orc;
 	}
 
+	/* Ogre pit */
+	else if (tmp < 25)
+	{
+		/* Message */
+		name = "ogre";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_ogre;
+	}
+
+	/* Human pit */
+	else if (tmp < 30)
+	{
+		/* Message */
+		name = "human";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_human;
+	}
+
+	/* Dark elf pit */
+	else if (tmp < 35)
+	{
+		/* Message */
+		name = "dark elf";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_dark_elf;
+	}
+
 	/* Troll pit */
 	else if (tmp < 40)
 	{
 		/* Message */
@@ -1901,9 +2225,9 @@
 		get_mon_num_hook = vault_aux_giant;
 	}
 
 	/* Dragon pit */
-	else if (tmp < 80)
+	else if (tmp < 75)
 	{
 		/* Pick dragon type */
 		switch (rand_int(6))
 		{
@@ -1992,8 +2316,18 @@
 		/* Restrict monster selection */
 		get_mon_num_hook = vault_aux_dragon;
 	}
 
+	/* Chapel */
+	else if (tmp < 80)
+	{
+		/* Message */
+		name = "chapel";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_chapel;
+	}
+
 	/* Demon pit */
 	else
 	{
 		/* Message */
@@ -2067,9 +2401,9 @@
 	}
 
 
 	/* Increase the level rating */
-	rating += 10;
+	/* rating += 10; */
 
 	/* (Sometimes) Cause a "special feeling" (for "Monster Pits") */
 	if ((p_ptr->depth <= 40) &&
 	    (randint(p_ptr->depth * p_ptr->depth + 1) < 300))
@@ -2312,9 +2646,9 @@
 		if (v_ptr->typ == 7) break;
 	}
 
 	/* Message */
-	if (cheat_room) msg_print("Lesser Vault");
+	if (cheat_room) msg_format("Lesser Vault (%s)", v_ptr->name + v_name);
 
 	/* Boost the rating */
 	rating += v_ptr->rat;
 
@@ -2348,9 +2682,9 @@
 		if (v_ptr->typ == 8) break;
 	}
 
 	/* Message */
-	if (cheat_room) msg_print("Greater Vault");
+	if (cheat_room) msg_format("Greater Vault (%s)", v_ptr->name + v_name);
 
 	/* Boost the rating */
 	rating += v_ptr->rat;
 
@@ -2728,8 +3062,10 @@
 
 	/* Restrict level */
 	if (p_ptr->depth < room[typ].level) return (FALSE);
 
+	dun->crowded = (z_info->m_max - m_max < 400);
+
 	/* Restrict "crowded" rooms */
 	if (dun->crowded && ((typ == 5) || (typ == 6))) return (FALSE);
 
 	/* Extract blocks */
@@ -2861,8 +3197,16 @@
 
 	/* Build some rooms */
 	for (i = 0; i < DUN_ROOMS; i++)
 	{
+		int unusual = DUN_UNUSUAL;
+
+		/* Generate some interesting levels */
+		if (p_ptr->depth % 7 == 0)
+			unusual = unusual * 4 / 5;
+		if (p_ptr->depth % 13 == 0)
+			unusual = unusual * 3 / 4;
+
 		/* Pick a block for the room */
 		by = rand_int(dun->row_rooms);
 		bx = rand_int(dun->col_rooms);
 
@@ -2886,27 +3230,34 @@
 			continue;
 		}
 
 		/* Attempt an "unusual" room */
-		if (rand_int(DUN_UNUSUAL) < p_ptr->depth)
+		if (rand_int(unusual) < p_ptr->depth)
 		{
 			/* Roll for room type */
 			k = rand_int(100);
 
+			/* Try to fit a greater vault on the level by placing it early */
+			if (i < 2)
+				k = rand_int(35);
+			/* Some extra-interesting levels */
+			else if (p_ptr->depth % 13 == 0)
+				k = rand_int(95 - p_ptr->depth / 13 * 5);
+
 			/* Attempt a very unusual room */
-			if (rand_int(DUN_UNUSUAL) < p_ptr->depth)
+			if (rand_int(unusual) < p_ptr->depth)
 			{
-				/* Type 8 -- Greater vault (10%) */
-				if ((k < 10) && room_build(by, bx, 8)) continue;
+				/* Type 8 -- Greater vault (15%) */
+				if ((k < 15) && room_build(by, bx, 8)) continue;
 
-				/* Type 7 -- Lesser vault (15%) */
-				if ((k < 25) && room_build(by, bx, 7)) continue;
+				/* Type 7 -- Lesser vault (20%) */
+				if ((k < 35) && room_build(by, bx, 7)) continue;
 
-				/* Type 6 -- Monster pit (15%) */
-				if ((k < 40) && room_build(by, bx, 6)) continue;
+				/* Type 6 -- Monster pit (20%) */
+				if ((k < 55) && room_build(by, bx, 6)) continue;
 
-				/* Type 5 -- Monster nest (10%) */
-				if ((k < 50) && room_build(by, bx, 5)) continue;
+				/* Type 5 -- Monster nest (15%) */
+				if ((k < 70) && room_build(by, bx, 5)) continue;
 			}
 
 			/* Type 4 -- Large room (25%) */
 			if ((k < 25) && room_build(by, bx, 4)) continue;
@@ -3026,9 +3377,9 @@
 	/* Place 3 or 4 down stairs near some walls */
 	alloc_stairs(FEAT_MORE, rand_range(3, 4), 3);
 
 	/* Place 1 or 2 up stairs near some walls */
-	alloc_stairs(FEAT_LESS, rand_range(1, 2), 3);
+	alloc_stairs(FEAT_LESS, rand_range(2, 3), 3);
 
 
 	/* Basic "amount" */
 	k = (p_ptr->depth / 3);
@@ -3447,23 +3798,23 @@
 		}
 
 
 		/* Extract the feeling */
-		if (rating > 100) feeling = 2;
-		else if (rating > 80) feeling = 3;
-		else if (rating > 60) feeling = 4;
-		else if (rating > 40) feeling = 5;
-		else if (rating > 30) feeling = 6;
-		else if (rating > 20) feeling = 7;
-		else if (rating > 10) feeling = 8;
+		if (rating > 150) feeling = 2;
+		else if (rating > 120) feeling = 3;
+		else if (rating > 90) feeling = 4;
+		else if (rating > 60) feeling = 5;
+		else if (rating > 45) feeling = 6;
+		else if (rating > 30) feeling = 7;
+		else if (rating > 15) feeling = 8;
 		else if (rating > 0) feeling = 9;
 		else feeling = 10;
 
 		/* Hack -- Have a special feeling sometimes */
 		if (good_item_flag && !adult_preserve) feeling = 1;
 
 		/* It takes 1000 game turns for "feelings" to recharge */
-		if ((turn - old_turn) < 1000) feeling = 0;
+		/* if ((turn - old_turn) < 1000) feeling = 0; */
 
 		/* Hack -- no feeling in the town */
 		if (!p_ptr->depth) feeling = 0;
 
@@ -3490,14 +3841,15 @@
 
 		/* Mega-Hack -- "auto-scum" */
 		if (auto_scum && (num < 100))
 		{
+			int req = 2 * p_ptr->depth;
+
+			if (p_ptr->depth > 20) req = p_ptr->depth + 20;
+			if (req > 90) req = 90;
+
 			/* Require "goodness" */
-			if ((feeling > 9) ||
-			    ((p_ptr->depth >= 5) && (feeling > 8)) ||
-			    ((p_ptr->depth >= 10) && (feeling > 7)) ||
-			    ((p_ptr->depth >= 20) && (feeling > 6)) ||
-			    ((p_ptr->depth >= 40) && (feeling > 5)))
+			if (rating < req)
 			{
 				/* Give message to cheaters */
 				if (cheat_room || cheat_hear ||
 				    cheat_peek || cheat_xtra)
diff --recursive --unified=4 angband-291/src/h-define.h antiband/src/h-define.h
--- angband-291/src/h-define.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/h-define.h	Tue Oct 30 11:10:48 2001
@@ -120,11 +120,11 @@
 #  define KTRL(X)	((X) & 0x1F)
 #  define ESCAPE	'\033'
 #else
 #  define A2I(X)	((X) - 'a')
-#  define I2A(X)	((X) + 'a')
+#  define I2A(X)	((char)((X) + 'a'))
 #  define D2I(X)	((X) - '0')
-#  define I2D(X)	((X) + '0')
+#  define I2D(X)	((char)((X) + '0'))
 #  define KTRL(X)	((X) & 0x1F)
 #  define ESCAPE	'\033'
 #endif
 
diff --recursive --unified=4 angband-291/src/init1.c antiband/src/init1.c
--- angband-291/src/init1.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/init1.c	Thu Nov  1 18:15:22 2001
@@ -202,9 +202,9 @@
 static cptr r_info_flags2[] =
 {
 	"STUPID",
 	"SMART",
-	"XXX1X2",
+	"ATTR_RANDOM",
 	"XXX2X2",
 	"INVISIBLE",
 	"COLD_BLOOD",
 	"EMPTY_MIND",
@@ -279,9 +279,9 @@
  */
 static cptr r_info_flags4[] =
 {
 	"SHRIEK",
-	"XXX2X4",
+	"SCREAM",
 	"XXX3X4",
 	"XXX4X4",
 	"ARROW_1",
 	"ARROW_2",
@@ -421,11 +421,11 @@
 	"SLAY_TROLL",
 	"SLAY_GIANT",
 	"SLAY_DRAGON",
 	"KILL_DRAGON",
-	"XXX5",
-	"XXX6",
-	"XXX7",
+	"BRAND_NETHR",
+	"BRAND_NEXUS",
+	"BRAND_CHAOS",
 	"BRAND_ACID",
 	"BRAND_ELEC",
 	"BRAND_FIRE",
 	"BRAND_COLD"
@@ -560,9 +560,10 @@
 	"TELE_AWAY",
 	"WOR",
 	"CONFUSE",
 	"PROBE",
-	"FIREBRAND"
+	"FIREBRAND",
+	"ELEMENTS"
 };
 
 
 
@@ -676,8 +677,24 @@
 			continue;
 		}
 
 
+		/* Process 'X' for "Maximum x_info[] index" */
+		if (buf[2] == 'X')
+		{
+			int max;
+
+			/* Scan for the value */
+			if (1 != sscanf(buf+4, "%d", &max)) return (PARSE_ERROR_GENERIC);
+
+			/* Save the value */
+			z_info->x_max = max;
+
+			/* Next... */
+			continue;
+		}
+
+
 		/* Process 'E' for "Maximum e_info[] index" */
 		if (buf[2] == 'E')
 		{
 			int max;
@@ -1368,10 +1385,12 @@
 
 			/* Get the index */
 			i = atoi(buf+2);
 
+#if 0
 			/* Verify information */
 			if (i <= error_idx) return (PARSE_ERROR_NON_SEQUENTIAL_RECORDS);
+#endif
 
 			/* Verify information */
 			if (i >= k_head->info_num) return (PARSE_ERROR_OBSOLETE_FILE);
 
diff --recursive --unified=4 angband-291/src/init2.c antiband/src/init2.c
--- angband-291/src/init2.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/init2.c	Sun Nov  4 23:45:04 2001
@@ -3060,10 +3060,10 @@
 		{ TV_SCROLL, SV_SCROLL_WORD_OF_RECALL },
 		{ TV_SCROLL, SV_SCROLL_WORD_OF_RECALL },
 		{ TV_SCROLL, SV_SCROLL_WORD_OF_RECALL },
 
-		{ TV_POTION, SV_POTION_RESIST_HEAT },
-		{ TV_POTION, SV_POTION_RESIST_COLD },
+		{ TV_POTION, SV_SCROLL_TELEPORT },
+		{ TV_POTION, SV_POTION_SPEED },
 		{ TV_POTION, SV_POTION_RES_STR },
 		{ TV_POTION, SV_POTION_RES_INT },
 		{ TV_POTION, SV_POTION_RES_WIS },
 		{ TV_POTION, SV_POTION_RES_DEX },
@@ -3144,8 +3144,11 @@
 	/* Hack -- use some memory twice */
 	temp_y = ((byte*)(temp_g)) + 0;
 	temp_x = ((byte*)(temp_g)) + TEMP_MAX;
 
+	/*** Prepare randart ***/
+	C_MAKE(x_info, z_info->x_max, randart_type);
+
 
 	/*** Prepare dungeon arrays ***/
 
 	/* Padded into array */
@@ -3190,8 +3193,14 @@
 	/*** Prepare quest array ***/
 
 	/* Quests */
 	C_MAKE(q_list, MAX_Q_IDX, quest);
+
+
+	/*** Prepare randart array ***/
+
+	/* Randarts */
+	C_MAKE(x_info, z_info->x_max, randart_type);
 
 
 	/*** Prepare the inventory ***/
 
diff --recursive --unified=4 angband-291/src/load1.c antiband/src/load1.c
--- angband-291/src/load1.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/load1.c	Thu Nov  1 18:11:20 2001
@@ -1319,8 +1319,9 @@
 	if (!wearable_p(o_ptr))
 	{
 		/* Paranoia */
 		o_ptr->name1 = o_ptr->name2 = 0;
+		o_ptr->name3 = 0;
 
 		/* Assume normal bonuses */
 		o_ptr->to_h = k_ptr->to_h;
 		o_ptr->to_d = k_ptr->to_d;
@@ -1757,8 +1758,10 @@
 		p_ptr->stat_cur[i] = p_ptr->stat_max[i];
 
 		/* Hack -- use that stat */
 		p_ptr->stat_use[i] = p_ptr->stat_cur[i];
+
+		p_ptr->stat_lim[i] = 18+100;
 	}
 
 	/* Strip the old "current stats" */
 	if (older_than(2, 5, 7))
diff --recursive --unified=4 angband-291/src/load2.c antiband/src/load2.c
--- angband-291/src/load2.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/load2.c	Fri Nov  2 12:19:32 2001
@@ -434,8 +434,33 @@
 	EGO_BLASTED			/* 127 = EGO_BLASTED (XXX) */
 };
 
 
+/*
+ * Read a "randart" record
+ */
+static void rd_randart(randart_type *x_ptr)
+{
+	int i;
+	byte len;
+	
+	rd_byte(&len);
+	for (i = 0; i < len; i++)
+		rd_byte(&x_ptr->name[i]);
+
+	rd_s32b(&x_ptr->cost);
+
+	rd_u32b(&x_ptr->flags1);
+	rd_u32b(&x_ptr->flags2);
+	rd_u32b(&x_ptr->flags3);
+
+	rd_byte(&x_ptr->level);
+
+	rd_byte(&x_ptr->activation);
+	rd_u16b(&x_ptr->time);
+	rd_u16b(&x_ptr->randtime);
+}
+
 
 /*
  * Read an object
  *
@@ -517,8 +542,13 @@
 
 		rd_byte(&o_ptr->name1);
 		rd_byte(&o_ptr->name2);
 
+		if (!older_than(12, 9, 1))
+		{
+			rd_byte(&o_ptr->name3);
+		}
+
 		rd_s16b(&o_ptr->timeout);
 
 		rd_s16b(&o_ptr->to_h);
 		rd_s16b(&o_ptr->to_d);
@@ -531,8 +561,12 @@
 
 		rd_byte(&o_ptr->ident);
 
 		rd_byte(&o_ptr->marked);
+
+		/* Special hack - read randart info now */
+		if (o_ptr->name3)
+			rd_randart(&x_info[o_ptr->name3]);
 	}
 
 	/* Old flags */
 	strip_bytes(12);
@@ -616,8 +650,9 @@
 		o_ptr->weight = k_ptr->weight;
 
 		/* Paranoia */
 		o_ptr->name1 = o_ptr->name2 = 0;
+		o_ptr->name3 = 0;
 
 		/* All done */
 		return;
 	}
@@ -760,8 +795,20 @@
 		/* Verify that ego-item */
 		if (!e_ptr->name) o_ptr->name2 = 0;
 	}
 
+	/* Paranoia */
+	if (o_ptr->name3)
+	{
+		randart_type *x_ptr;
+
+		/* Obtain the ego-item info */
+		x_ptr = &x_info[o_ptr->name3];
+
+		/* Verify that ego-item */
+		if (!x_ptr->name[0]) o_ptr->name3 = 0;
+	}
+
 
 	/* Get the standard fields */
 	o_ptr->ac = k_ptr->ac;
 	o_ptr->dd = k_ptr->dd;
@@ -1275,8 +1322,18 @@
 	/* Read the stat info */
 	for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_max[i]);
 	for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_cur[i]);
 
+	/* Read stat limits */
+	if (older_than(12,9,1))
+	{
+		for (i = 0; i < A_MAX; i++) p_ptr->stat_lim[i] = 18+100;
+	}
+	else
+	{
+		for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_lim[i]);
+	}
+
 	strip_bytes(24);	/* oops */
 
 	rd_s32b(&p_ptr->au);
 
@@ -1387,37 +1444,10 @@
 
 	/* Initialize random artifacts */
 	if (adult_rand_artifacts && !(p_ptr->is_dead))
 	{
-#ifdef GJW_RANDART
-
-		/*
-		 * XXX XXX XXX
-		 * Importing old savefiles with random artifacts is dangerous
-		 * since the randart-generators differ and produce different
-		 * artifacts from the same random seed.
-		 *
-		 * Switching off the check for incompatible randart versions
-		 * allows to import such a savefile - do it at your own risk.
-		 */
-
-		/* Check for incompatible randart version */
-		if (randart_version != RANDART_VERSION)
-		{
-			note(format("Incompatible random artifacts version!"));
-			return (25);
-		}
-
-		/* Initialize randarts */
-		do_randart(seed_randart);
-
-#else /* GJW_RANDART */
-
 		note("Random artifacts are disabled in this binary.");
 		return (25);
-
-#endif /* GJW_RANDART */
-
 	}
 
 	/* Read "feeling" */
 	rd_byte(&tmp8u);
diff --recursive --unified=4 angband-291/src/melee2.c antiband/src/melee2.c
--- angband-291/src/melee2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/melee2.c	Thu Nov 15 02:26:04 2001
@@ -116,12 +116,12 @@
 		if (p_ptr->oppose_cold) smart |= (SM_OPP_COLD);
 		if (p_ptr->oppose_pois) smart |= (SM_OPP_POIS);
 
 		/* Know resistances */
-		if (p_ptr->resist_acid) smart |= (SM_RES_ACID);
-		if (p_ptr->resist_elec) smart |= (SM_RES_ELEC);
-		if (p_ptr->resist_fire) smart |= (SM_RES_FIRE);
-		if (p_ptr->resist_cold) smart |= (SM_RES_COLD);
+		if (p_ptr->resist_acid || p_ptr->xresist_acid) smart |= (SM_RES_ACID);
+		if (p_ptr->resist_elec || p_ptr->xresist_elec) smart |= (SM_RES_ELEC);
+		if (p_ptr->resist_fire || p_ptr->xresist_fire) smart |= (SM_RES_FIRE);
+		if (p_ptr->resist_cold || p_ptr->xresist_cold) smart |= (SM_RES_COLD);
 		if (p_ptr->resist_pois) smart |= (SM_RES_POIS);
 		if (p_ptr->resist_fear) smart |= (SM_RES_FEAR);
 		if (p_ptr->resist_lite) smart |= (SM_RES_LITE);
 		if (p_ptr->resist_dark) smart |= (SM_RES_DARK);
@@ -417,13 +417,10 @@
  * Cast a breath (or ball) attack at the player
  * Pass over any monsters that may be in the way
  * Affect grids, objects, monsters, and the player
  */
-static void breath(int m_idx, int typ, int dam_hp)
+static void breath(int m_idx, int py, int px, int typ, int dam_hp)
 {
-	int py = p_ptr->py;
-	int px = p_ptr->px;
-
 	int rad;
 
 	int flg = PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
 
@@ -437,8 +434,129 @@
 	(void)project(m_idx, rad, py, px, dam_hp, typ, flg);
 }
 
 
+static bool should_wake_friends(int who)
+{
+	int i;
+
+	/* Aggravate everyone nearby */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Skip monsters of a different race (should check 'symbol'?) */
+		if (m_ptr->r_idx != m_list[who].r_idx) continue;
+
+		/* Check for sleeping monsters in los of shouting monster */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			if (m_ptr->csleep)
+			{
+				return TRUE;
+			}
+		}
+	}
+	
+	return FALSE;
+}
+
+static bool pack_indirect_fire_okay(int who, int py, int px)
+{
+	int i;
+
+	/* If the monster has los, it can still try to hit an out-of-range player */
+	if (los(m_list[who].fy, m_list[who].fy, py, px))
+		return TRUE;
+
+	/* Check all monsters of same race */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Skip monsters of a different race (should check 'symbol'?) */
+		if (m_ptr->r_idx != m_list[who].r_idx) continue;
+
+		/* Check for monsters in los who themselves have los to the player */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			if (los(m_ptr->fy, m_ptr->fx, py, px))
+			{
+  				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+
+static bool find_indirect_fire(int who, int *py, int *px)
+{
+	int cur_r, x, y;
+	int fx = m_list[who].fx, fy = m_list[who].fy;
+	int found = 0;
+	int best_x, best_y;
+	int rad;
+
+	monster_type *m_ptr = &m_list[who];
+	monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+	/* Determine the radius of the blast */
+	rad = (r_ptr->flags2 & (RF2_POWERFUL)) ? 3 : 2;
+
+	for (cur_r = 1; cur_r <= rad; cur_r++)
+	{
+		for (y = *py - cur_r; y <= *py + cur_r; y++)
+		{
+			for (x = *px - cur_r; x <= *px + cur_r; x++)
+			{
+				if (!in_bounds(y, x) || !cave_floor_bold(y, x))
+					continue;
+
+				if (distance(*py, *px, y, x) > cur_r)
+					continue;
+
+				if (distance(fy, fx, y, x) > MAX_RANGE)
+					continue;
+
+				if (!projectable(fy, fx, y, x))
+					continue;
+
+				if (rand_int(++found) == 0)
+				{
+					best_x = x;
+					best_y = y;
+				}
+			}
+		}
+
+		if (found > 0)
+		{
+			*px = best_x;
+			*py = best_y;
+			return (TRUE);
+		}
+	}
+
+	return (FALSE);
+}
+
+
 /*
  * Offsets for the spell indices
  */
 #define RF4_OFFSET 32 * 3
@@ -594,15 +712,19 @@
 		/* Keep only the interesting spells */
 		f4 &= f4_mask;
 		f5 &= f5_mask;
 		f6 &= f6_mask;
-
-		/* Anything left? */
-		if (!(f4 || f5 || f6)) return (0);
 	}
 
 #endif /* MONSTER_AI */
 
+	/* Don't try to shout for help if there's none around */
+	if ((f4 & RF4_SCREAM) && !should_wake_friends(m_idx))
+		f4 &= ~RF4_SCREAM;
+
+	/* Anything left? */
+	if (!(f4 || f5 || f6)) return (0);
+
 	/* Extract the "innate" spells */
 	for (i = 0; i < 32; i++)
 	{
 		if (f4 & (1L << i)) spells[num++] = i + RF4_OFFSET;
@@ -755,20 +877,18 @@
 
 #endif /* MONSTER_AI */
 
 
-
 	/* Hack -- require projectable player */
 	if (normal)
 	{
 		/* Check range */
-		if (m_ptr->cdis > MAX_RANGE) return (FALSE);
+		if (m_ptr->cdis > MAX_RANGE) direct = FALSE;
 
 		/* Check path */
-		if (!projectable(m_ptr->fy, m_ptr->fx, py, px)) return (FALSE);
+		if (!projectable(m_ptr->fy, m_ptr->fx, py, px)) direct = FALSE;
 	}
 
-
 	/* Extract the monster level */
 	rlev = ((r_ptr->level >= 1) ? r_ptr->level : 1);
 
 
@@ -789,8 +909,52 @@
 	}
 
 #endif /* MONSTER_AI */
 
+
+#ifdef MONSTER_AI
+
+	if (!direct)
+	{
+#if 0
+		/* Summoners are nasty */
+		if (f4 & (RF4_SUMMON_MASK) ||
+			f5 & (RF5_SUMMON_MASK) ||
+			f6 & (RF6_SUMMON_MASK))
+		{
+			/* Only summon sometimes */
+			if (rand_int(3) != 0) return (FALSE);
+
+			/* Must be nearby */
+			if (m_ptr->cdis > r_ptr->aaf) return (FALSE);
+			if (m_ptr->cdis > MAX_RANGE) return (FALSE);
+
+			x = m_ptr->fx;
+			y = m_ptr->fy;
+		}
+#endif
+		/* Pack monsters can sometimes fire on the player indirectly */
+		if (smart_packs && (r_ptr->flags1 & RF1_GROUP_MASK) &&
+			(f4 & (RF4_INDIRECT_MASK) || 
+			 f5 & (RF5_INDIRECT_MASK) ||
+			 f6 & (RF6_INDIRECT_MASK)) && 
+			pack_indirect_fire_okay(m_idx, py, px))
+		{
+			if (!find_indirect_fire(m_idx, &py, &px)) return (FALSE);
+		}
+		else
+		{
+			return (FALSE);
+		}
+	}
+
+#else /* MONSTER_AI */
+
+	if (!direct) return (FALSE);
+
+#endif /* MONSTER_AI */
+
+
 	/* Hack -- allow "desperate" spells */
 	if ((r_ptr->flags2 & (RF2_SMART)) &&
 	    (m_ptr->hp < m_ptr->maxhp / 10) &&
 	    (rand_int(100) < 50))
@@ -804,8 +968,19 @@
 		if (!f4 && !f5 && !f6) return (FALSE);
 	}
 
 
+	/* Only allow breaths & balls to use indirect fire */
+	if (!direct)
+	{
+		f4 &= (RF4_INDIRECT_MASK) | (RF4_SUMMON_MASK);
+		f5 &= (RF5_INDIRECT_MASK) | (RF5_SUMMON_MASK);
+		f6 &= (RF6_INDIRECT_MASK) | (RF6_SUMMON_MASK);
+
+		if (!f4 && !f5 && !f6) return (FALSE);
+	}
+
+
 #ifdef DRS_SMART_OPTIONS
 
 	/* Remove the "ineffective" spells */
 	remove_bad_spells(m_idx, &f4, &f5, &f6);
@@ -895,11 +1070,14 @@
 			aggravate_monsters(m_idx);
 			break;
 		}
 
-		/* RF4_XXX2X4 */
+		/* RF4_SCREAM */
 		case RF4_OFFSET+1:
 		{
+			disturb(1, 0);
+			msg_format("%^s screams for help.", m_name);
+			wake_monsters(m_idx);
 			break;
 		}
 
 		/* RF4_XXX3X4 */
@@ -959,9 +1137,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes acid.", m_name);
-			breath(m_idx, GF_ACID,
+			breath(m_idx, py, px,  GF_ACID,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_ACID);
 			break;
 		}
@@ -971,9 +1149,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes lightning.", m_name);
-			breath(m_idx, GF_ELEC,
+			breath(m_idx, py, px, GF_ELEC,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_ELEC);
 			break;
 		}
@@ -983,9 +1161,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes fire.", m_name);
-			breath(m_idx, GF_FIRE,
+			breath(m_idx, py, px, GF_FIRE,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_FIRE);
 			break;
 		}
@@ -995,9 +1173,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes frost.", m_name);
-			breath(m_idx, GF_COLD,
+			breath(m_idx, py, px, GF_COLD,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_COLD);
 			break;
 		}
@@ -1007,9 +1185,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes gas.", m_name);
-			breath(m_idx, GF_POIS,
+			breath(m_idx, py, px, GF_POIS,
 			       ((m_ptr->hp / 3) > 800 ? 800 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_POIS);
 			break;
 		}
@@ -1019,9 +1197,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes nether.", m_name);
-			breath(m_idx, GF_NETHER,
+			breath(m_idx, py, px, GF_NETHER,
 			       ((m_ptr->hp / 6) > 550 ? 550 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_NETHR);
 			break;
 		}
@@ -1031,9 +1209,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes light.", m_name);
-			breath(m_idx, GF_LITE,
+			breath(m_idx, py, px, GF_LITE,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_LITE);
 			break;
 		}
@@ -1043,9 +1221,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes darkness.", m_name);
-			breath(m_idx, GF_DARK,
+			breath(m_idx, py, px, GF_DARK,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_DARK);
 			break;
 		}
@@ -1055,9 +1233,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes confusion.", m_name);
-			breath(m_idx, GF_CONFUSION,
+			breath(m_idx, py, px, GF_CONFUSION,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_CONFU);
 			break;
 		}
@@ -1067,9 +1245,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes sound.", m_name);
-			breath(m_idx, GF_SOUND,
+			breath(m_idx, py, px, GF_SOUND,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_SOUND);
 			break;
 		}
@@ -1079,9 +1257,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes chaos.", m_name);
-			breath(m_idx, GF_CHAOS,
+			breath(m_idx, py, px, GF_CHAOS,
 			       ((m_ptr->hp / 6) > 600 ? 600 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_CHAOS);
 			break;
 		}
@@ -1091,9 +1269,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes disenchantment.", m_name);
-			breath(m_idx, GF_DISENCHANT,
+			breath(m_idx, py, px, GF_DISENCHANT,
 			       ((m_ptr->hp / 6) > 500 ? 500 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_DISEN);
 			break;
 		}
@@ -1103,9 +1281,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes nexus.", m_name);
-			breath(m_idx, GF_NEXUS,
+			breath(m_idx, py, px, GF_NEXUS,
 			       ((m_ptr->hp / 3) > 250 ? 250 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_NEXUS);
 			break;
 		}
@@ -1115,9 +1293,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes time.", m_name);
-			breath(m_idx, GF_TIME,
+			breath(m_idx, py, px, GF_TIME,
 			       ((m_ptr->hp / 3) > 150 ? 150 : (m_ptr->hp / 3)));
 			break;
 		}
 
@@ -1126,9 +1304,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes inertia.", m_name);
-			breath(m_idx, GF_INERTIA,
+			breath(m_idx, py, px, GF_INERTIA,
 			       ((m_ptr->hp / 6) > 200 ? 200 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1137,9 +1315,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes gravity.", m_name);
-			breath(m_idx, GF_GRAVITY,
+			breath(m_idx, py, px, GF_GRAVITY,
 			       ((m_ptr->hp / 3) > 200 ? 200 : (m_ptr->hp / 3)));
 			break;
 		}
 
@@ -1148,9 +1326,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes shards.", m_name);
-			breath(m_idx, GF_SHARD,
+			breath(m_idx, py, px, GF_SHARD,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_SHARD);
 			break;
 		}
@@ -1160,9 +1338,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes plasma.", m_name);
-			breath(m_idx, GF_PLASMA,
+			breath(m_idx, py, px, GF_PLASMA,
 			       ((m_ptr->hp / 6) > 150 ? 150 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1171,9 +1349,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes force.", m_name);
-			breath(m_idx, GF_FORCE,
+			breath(m_idx, py, px, GF_FORCE,
 			       ((m_ptr->hp / 6) > 200 ? 200 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1215,9 +1393,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts an acid ball.", m_name);
-			breath(m_idx, GF_ACID,
+			breath(m_idx, py, px, GF_ACID,
 			       randint(rlev * 3) + 15);
 			update_smart_learn(m_idx, DRS_RES_ACID);
 			break;
 		}
@@ -1227,9 +1405,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a lightning ball.", m_name);
-			breath(m_idx, GF_ELEC,
+			breath(m_idx, py, px, GF_ELEC,
 			       randint(rlev * 3 / 2) + 8);
 			update_smart_learn(m_idx, DRS_RES_ELEC);
 			break;
 		}
@@ -1239,9 +1417,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a fire ball.", m_name);
-			breath(m_idx, GF_FIRE,
+			breath(m_idx, py, px, GF_FIRE,
 			       randint(rlev * 7 / 2) + 10);
 			update_smart_learn(m_idx, DRS_RES_FIRE);
 			break;
 		}
@@ -1251,9 +1429,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a frost ball.", m_name);
-			breath(m_idx, GF_COLD,
+			breath(m_idx, py, px, GF_COLD,
 			       randint(rlev * 3 / 2) + 10);
 			update_smart_learn(m_idx, DRS_RES_COLD);
 			break;
 		}
@@ -1263,9 +1441,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a stinking cloud.", m_name);
-			breath(m_idx, GF_POIS,
+			breath(m_idx, py, px, GF_POIS,
 			       damroll(12, 2));
 			update_smart_learn(m_idx, DRS_RES_POIS);
 			break;
 		}
@@ -1275,9 +1453,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a nether ball.", m_name);
-			breath(m_idx, GF_NETHER,
+			breath(m_idx, py, px, GF_NETHER,
 			       (50 + damroll(10, 10) + rlev));
 			update_smart_learn(m_idx, DRS_RES_NETHR);
 			break;
 		}
@@ -1288,9 +1466,9 @@
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s gestures fluidly.", m_name);
 			msg_print("You are engulfed in a whirlpool.");
-			breath(m_idx, GF_WATER,
+			breath(m_idx, py, px, GF_WATER,
 			       randint(rlev * 5 / 2) + 50);
 			break;
 		}
 
@@ -1299,9 +1477,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles powerfully.", m_name);
 			else msg_format("%^s invokes a mana storm.", m_name);
-			breath(m_idx, GF_MANA,
+			breath(m_idx, py, px, GF_MANA,
 			       (rlev * 5) + damroll(10, 10));
 			break;
 		}
 
@@ -1310,9 +1488,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles powerfully.", m_name);
 			else msg_format("%^s invokes a darkness storm.", m_name);
-			breath(m_idx, GF_DARK,
+			breath(m_idx, py, px, GF_DARK,
 			       (rlev * 5) + damroll(10, 10));
 			update_smart_learn(m_idx, DRS_RES_DARK);
 			break;
 		}
@@ -1793,8 +1971,10 @@
 
 		/* RF6_HEAL */
 		case RF6_OFFSET+2:
 		{
+			int healing;
+
 			disturb(1, 0);
 
 			/* Message */
 			if (blind)
@@ -1806,9 +1986,12 @@
 				msg_format("%^s concentrates on %s wounds.", m_name, m_poss);
 			}
 
 			/* Heal some */
-			m_ptr->hp += (rlev * 6);
+			healing = m_ptr->maxhp * randint(10) / 15;
+			if (healing > rlev * 6) healing = rlev * 6;
+			if (healing < rlev) healing = rlev;
+			m_ptr->hp += healing;
 
 			/* Fully healed */
 			if (m_ptr->hp >= m_ptr->maxhp)
 			{
@@ -2941,8 +3124,9 @@
 
 
 #ifdef MONSTER_AI
 
+#if 0
 	/* Normal animal packs try to get the player out of corridors. */
 	if (smart_packs &&
 	    (r_ptr->flags1 & RF1_FRIENDS) && (r_ptr->flags3 & RF3_ANIMAL) &&
 	    !((r_ptr->flags2 & (RF2_PASS_WALL)) || (r_ptr->flags2 & (RF2_KILL_WALL))))
@@ -2966,8 +3150,9 @@
 			/* Find hiding place */
 			if (find_hiding(m_idx, &y, &x)) done = TRUE;
 		}
 	}
+#endif
 
 #endif /* MONSTER_AI */
 
 	/* Apply fear */
@@ -3002,39 +3187,73 @@
 
 #ifdef MONSTER_AI
 
 	/* Monster groups try to surround the player */
-	if (!done && smart_packs && (r_ptr->flags1 & RF1_FRIENDS))
+	if (!done && smart_packs && (r_ptr->flags1 & RF1_GROUP_MASK))
 	{
-		int i;
+		int i, i2;
+		int tx, ty, tx2, ty2;
+ 		int count = 0, count2;
+		int found = 0;
 
-		/* Find an empty square near the player to fill */
+		/* Count monsters near current position */
 		for (i = 0; i < 8; i++)
 		{
-			/* Pick squares near player (semi-randomly) */
-			y2 = py + ddy_ddd[(m_idx + i) & 7];
-			x2 = px + ddx_ddd[(m_idx + i) & 7];
+			tx = m_ptr->fx + ddx_ddd[i];
+			ty = m_ptr->fy + ddy_ddd[i];
+
+			if (tx == px && ty == py)
+				continue;
 
-			/* Already there? */
-			if ((m_ptr->fy == y2) && (m_ptr->fx == x2))
+			if (cave_m_idx[ty][tx])
 			{
-				/* Attack the player */
-				y2 = py;
-				x2 = px;
+				bool blocked = TRUE;
 
-				break;
-			}
+				/* Check if this monster can reach the player easily */
+				for (i2 = 0; i2 < 8; i2++)
+				{
+					tx2 = tx + ddx_ddd[i2];
+					ty2 = ty + ddy_ddd[i2];
 
-			/* Ignore filled grids */
-			if (!cave_empty_bold(y2, x2)) continue;
+					if (!cave_empty_bold(ty2, tx2))
+						continue;
 
-			/* Try to fill this hole */
-			break;
+					if (ABS(tx2 - px) > 1 || ABS(ty2 - py) > 1)
+						continue;
+
+					blocked = FALSE;
+					break;
+				}
+
+				if (blocked)
+					count++;
+			}
 		}
 
-		/* Extract the new "pseudo-direction" */
-		y = m_ptr->fy - y2;
-		x = m_ptr->fx - x2;
+		if (count)
+		{
+			/* Check options */
+			for (i = 0; i < 8; i++)
+			{
+				tx = m_ptr->fx + ddx_ddd[i];
+				ty = m_ptr->fy + ddy_ddd[i];
+
+				if (tx == px && ty == py)
+					continue;
+
+				if (!cave_empty_bold(ty, tx))
+					continue;
+
+				if (ABS(tx - px) > 1 || ABS(ty - py) > 1)
+					continue;
+
+				if (rand_int(++found) == 0)
+				{
+					y = -ddy_ddd[i];
+					x = -ddx_ddd[i];
+				}
+			}
+		}
 
 		/* Done */
 		done = TRUE;
 	}
diff --recursive --unified=4 angband-291/src/monster1.c antiband/src/monster1.c
--- angband-291/src/monster1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/monster1.c	Tue Oct 30 11:10:46 2001
@@ -602,9 +602,9 @@
 
 	/* Collect inate attacks */
 	vn = 0;
 	if (flags4 & (RF4_SHRIEK))		vp[vn++] = "shriek for help";
-	if (flags4 & (RF4_XXX2))		vp[vn++] = "do something";
+	if (flags4 & (RF4_SCREAM))		vp[vn++] = "scream for help";
 	if (flags4 & (RF4_XXX3))		vp[vn++] = "do something";
 	if (flags4 & (RF4_XXX4))		vp[vn++] = "do something";
 	if (flags4 & (RF4_ARROW_1))		vp[vn++] = "fire an arrow";
 	if (flags4 & (RF4_ARROW_2))		vp[vn++] = "fire arrows";
diff --recursive --unified=4 angband-291/src/monster2.c antiband/src/monster2.c
--- angband-291/src/monster2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/monster2.c	Thu Nov 15 01:43:34 2001
@@ -415,22 +415,30 @@
 		/* Occasional "nasty" monster */
 		if (rand_int(NASTY_MON) == 0)
 		{
 			/* Pick a level bonus */
-			int d = level / 4 + 2;
+			int d = randint(level / 2 + 3);
+
+			/* Reduce very dangerous monsters a bit */
+			while (d > 5 && rand_int(3) != 0)
+				d--;
 
 			/* Boost the level */
-			level += ((d < 5) ? d : 5);
+			level += d;
 		}
 
 		/* Occasional "nasty" monster */
 		if (rand_int(NASTY_MON) == 0)
 		{
 			/* Pick a level bonus */
-			int d = level / 4 + 2;
+			int d = randint(level / 2 + 3);
+
+			/* Reduce very dangerous monsters a bit */
+			while (d > 5 && rand_int(3) != 0)
+				d--;
 
 			/* Boost the level */
-			level += ((d < 5) ? d : 5);
+			level += d;
 		}
 	}
 
 
@@ -2025,9 +2033,9 @@
 	/* Look for a location */
 	for (i = 0; i < 20; ++i)
 	{
 		/* Pick a distance */
-		int d = (i / 15) + 1;
+		int d = (i / 3) + 3;
 
 		/* Pick a location */
 		scatter(&y, &x, y1, x1, d, 0);
 
@@ -2273,25 +2281,25 @@
 		}
 
 		case DRS_RES_ACID:
 		{
-			if (p_ptr->resist_acid) m_ptr->smart |= (SM_RES_ACID);
+			if (p_ptr->resist_acid || p_ptr->xresist_acid) m_ptr->smart |= (SM_RES_ACID);
 			if (p_ptr->oppose_acid) m_ptr->smart |= (SM_OPP_ACID);
 			if (p_ptr->immune_acid) m_ptr->smart |= (SM_IMM_ACID);
 			break;
 		}
 
 		case DRS_RES_ELEC:
 		{
-			if (p_ptr->resist_elec) m_ptr->smart |= (SM_RES_ELEC);
+			if (p_ptr->resist_elec || p_ptr->xresist_elec) m_ptr->smart |= (SM_RES_ELEC);
 			if (p_ptr->oppose_elec) m_ptr->smart |= (SM_OPP_ELEC);
 			if (p_ptr->immune_elec) m_ptr->smart |= (SM_IMM_ELEC);
 			break;
 		}
 
 		case DRS_RES_FIRE:
 		{
-			if (p_ptr->resist_fire) m_ptr->smart |= (SM_RES_FIRE);
+			if (p_ptr->resist_fire || p_ptr->xresist_fire) m_ptr->smart |= (SM_RES_FIRE);
 			if (p_ptr->oppose_fire) m_ptr->smart |= (SM_OPP_FIRE);
 			if (p_ptr->immune_fire) m_ptr->smart |= (SM_IMM_FIRE);
 			break;
 		}
diff --recursive --unified=4 angband-291/src/object1.c antiband/src/object1.c
--- angband-291/src/object1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/object1.c	Thu Nov 15 02:17:00 2001
@@ -13,10 +13,10 @@
 
 /*
  * Max sizes of the following arrays.
  */
-#define MAX_ROCKS      42       /* Used with rings (min 38) */
-#define MAX_AMULETS    16       /* Used with amulets (min 13) */
+#define MAX_ROCKS      45       /* Used with rings (min 43) */
+#define MAX_AMULETS    18       /* Used with amulets (min 13) */
 #define MAX_WOODS      32       /* Used with staffs (min 30) */
 #define MAX_METALS     32       /* Used with wands/rods (min 29/28) */
 #define MAX_COLORS     60       /* Used with potions (min 60) */
 #define MAX_SHROOM     20       /* Used with mushrooms (min 20) */
@@ -37,9 +37,9 @@
 	"Onyx", "Opal", "Pearl", "Quartz", "Quartzite",
 	"Rhodonite", "Ruby", "Sapphire", "Tiger Eye", "Topaz",
 	"Turquoise", "Zircon", "Platinum", "Bronze", "Gold",
 	"Obsidian", "Silver", "Tortoise Shell", "Mithril", "Jet",
-	"Engagement", "Adamantite"
+	"Engagement", "Adamantite", "Twisted", "Large", "Tiny",
 };
 
 static byte ring_col[MAX_ROCKS] =
 {
@@ -50,9 +50,9 @@
 	TERM_L_RED, TERM_L_WHITE, TERM_WHITE, TERM_L_WHITE, TERM_L_WHITE,
 	TERM_L_RED, TERM_RED, TERM_BLUE, TERM_YELLOW, TERM_YELLOW,
 	TERM_L_BLUE, TERM_L_UMBER, TERM_WHITE, TERM_L_UMBER, TERM_YELLOW,
 	TERM_L_DARK, TERM_L_WHITE, TERM_UMBER, TERM_L_BLUE, TERM_L_DARK,
-	TERM_YELLOW, TERM_L_GREEN
+	TERM_YELLOW, TERM_L_GREEN, TERM_UMBER, TERM_L_DARK, TERM_SLATE
 };
 
 
 /*
@@ -63,17 +63,17 @@
 {
 	"Amber", "Driftwood", "Coral", "Agate", "Ivory",
 	"Obsidian", "Bone", "Brass", "Bronze", "Pewter",
 	"Tortoise Shell", "Golden", "Azure", "Crystal", "Silver",
-	"Copper"
+	"Copper", "Pink Coral", "Ebony"
 };
 
 static byte amulet_col[MAX_AMULETS] =
 {
 	TERM_YELLOW, TERM_L_UMBER, TERM_WHITE, TERM_L_WHITE, TERM_WHITE,
 	TERM_L_DARK, TERM_WHITE, TERM_L_UMBER, TERM_L_UMBER, TERM_SLATE,
 	TERM_UMBER, TERM_YELLOW, TERM_L_BLUE, TERM_WHITE, TERM_L_WHITE,
-	TERM_L_UMBER
+	TERM_L_UMBER, TERM_L_RED, TERM_L_DARK
 };
 
 
 /*
@@ -729,8 +729,18 @@
 				(*f1) = a_ptr->flags1;
 				(*f2) = a_ptr->flags2;
 				(*f3) = a_ptr->flags3;
 			}
+
+			/* Randart */
+			if (o_ptr->name3)
+			{
+				randart_type *x_ptr = &x_info[o_ptr->name3];
+
+				(*f1) = x_ptr->flags1;
+				(*f2) = x_ptr->flags2;
+				(*f3) = x_ptr->flags3;
+			}
 		}
 
 		/* Ego-item */
 		if (o_ptr->name2)
@@ -753,8 +763,19 @@
 				(*f1) = (a_ptr->flags1 & (TR1_PVAL_MASK));
 
 				(*f3) = (a_ptr->flags3 & (TR3_IGNORE_MASK));
 			}
+
+			/* Obvious randart flags */
+			if (o_ptr->name3)
+			{
+				randart_type *x_ptr = &x_info[o_ptr->name3];
+
+				/* Obvious flags (pval) */
+				(*f1) = (x_ptr->flags1 & (TR1_PVAL_MASK));
+
+				(*f3) = (x_ptr->flags3 & (TR3_IGNORE_MASK));
+			}
 		}
 	}
 
 	if (mode != OBJECT_FLAGS_FULL)
@@ -789,8 +810,24 @@
 				(*f3) &= ~(TR3_IGNORE_MASK);
 			}
 		}
 
+		/* Randart */
+		if (o_ptr->name3)
+		{
+			randart_type *x_ptr = &x_info[o_ptr->name3];
+
+			(*f1) = x_ptr->flags1;
+			(*f2) = x_ptr->flags2;
+			(*f3) = x_ptr->flags3;
+
+			if (mode == OBJECT_FLAGS_RANDOM)
+			{
+				/* Hack - remove 'ignore' flags */
+				(*f3) &= ~(TR3_IGNORE_MASK);
+			}
+		}
+
 		/* Full knowledge for *identified* objects */
 		if (!(o_ptr->ident & IDENT_MENTAL)) return;
 	}
 
@@ -1399,8 +1436,17 @@
 			object_desc_chr_macro(t, ' ');
 			object_desc_str_macro(t, (a_name + a_ptr->name));
 		}
 
+		/* Grab any randart name */
+		else if (o_ptr->name3)
+		{
+			randart_type *x_ptr = &x_info[o_ptr->name3];
+
+			object_desc_chr_macro(t, ' ');
+			object_desc_str_macro(t, x_ptr->name);
+		}
+
 		/* Grab any ego-item name */
 		else if (o_ptr->name2)
 		{
 			ego_item_type *e_ptr = &e_info[o_ptr->name2];
@@ -1961,17 +2007,20 @@
 	"word of recall",
 	"confuse monster",
 	"probing",
 	"fire branding of bolts",
+	"large elemental ball (400)",
 };
 
 
 
 /*
  * Determine the "Activation" (if any) for an artifact
  * Return a string, or NULL for "no activation"
+ *
+ * "buffer" must hold at least 80 chars
  */
-cptr item_activation(object_type *o_ptr)
+cptr item_activation(object_type *o_ptr, char *buffer)
 {
 	u32b f1, f2, f3;
 
 	/* Extract the flags */
@@ -1984,113 +2033,687 @@
 	if (o_ptr->name1)
 	{
 		artifact_type *a_ptr = &a_info[o_ptr->name1];
 
-#if 0
-		/*
-		 * ToDo: Put the recharge time back into the
-		 * artifact description.
-		 */
-		char turns[32];
+		/* Paranoia */
+		if (a_ptr->activation >= ACT_MAX)
+			return (NULL);
 
 		/* Format the number of turns */
 		if (a_ptr->time && a_ptr->randtime)
-			sprintf(turns, " every %d+d%d turns",
+			sprintf(buffer, "%s every %d+d%d turns",
+					act_description[a_ptr->activation],
 			        a_ptr->time, a_ptr->randtime);
 		else if (a_ptr->time)
-			sprintf(turns, " every %d turns", a_ptr->time);
+			sprintf(buffer, "%s every %d turns", 
+					act_description[a_ptr->activation],
+					a_ptr->time);
 		else if (a_ptr->randtime)
-			sprintf(turns, " every d%d turns", a_ptr->randtime);
-#endif
+			sprintf(buffer, "%s every d%d turns", 
+					act_description[a_ptr->activation],
+					a_ptr->randtime);
+		else
+			sprintf(buffer, "%s",
+					act_description[a_ptr->activation]);
+
+		/* Some artifacts can be activated */
+		return (buffer);
+	}
+
+	/* Randart activations */
+	if (o_ptr->name3)
+	{
+		randart_type *x_ptr = &x_info[o_ptr->name3];
 
 		/* Paranoia */
-		if (a_ptr->activation >= ACT_MAX)
+		if (x_ptr->activation >= ACT_MAX)
 			return (NULL);
 
+		/* Format the number of turns */
+		if (x_ptr->time && x_ptr->randtime)
+			sprintf(buffer, "%s every %d+d%d turns",
+					act_description[x_ptr->activation],
+			        x_ptr->time, x_ptr->randtime);
+		else if (x_ptr->time)
+			sprintf(buffer, "%s every %d turns", 
+					act_description[x_ptr->activation],
+					x_ptr->time);
+		else if (x_ptr->randtime)
+			sprintf(buffer, "%s every d%d turns", 
+					act_description[x_ptr->activation],
+					x_ptr->randtime);
+		else
+			sprintf(buffer, "%s",
+					act_description[x_ptr->activation]);
+
 		/* Some artifacts can be activated */
-		return (act_description[a_ptr->activation]);
+		return (buffer);
 	}
 
-	/* Require dragon scale mail */
-	if (o_ptr->tval != TV_DRAG_ARMOR) return (NULL);
+	/* Check dragon scale mail */
+	if (o_ptr->tval == TV_DRAG_ARMOR)
+	{
+		/* Branch on the sub-type */
+		switch (o_ptr->sval)
+		{
+			case SV_DRAGON_BLUE:
+			{
+				return "breathe lightning (100) every 450+d450 turns";
+			}
+			case SV_DRAGON_WHITE:
+			{
+				return "breathe frost (110) every 450+d450 turns";
+			}
+			case SV_DRAGON_BLACK:
+			{
+				return "breathe acid (130) every 450+d450 turns";
+			}
+			case SV_DRAGON_GREEN:
+			{
+				return "breathe poison gas (150) every 450+d450 turns";
+			}
+			case SV_DRAGON_RED:
+			{
+				return "breathe fire (200) every 450+d450 turns";
+			}
+			case SV_DRAGON_MULTIHUED:
+			{
+				return "breathe multi-hued (250) every 225+d225 turns";
+			}
+			case SV_DRAGON_BRONZE:
+			{
+				return "breathe confusion (120) every 450+d450 turns";
+			}
+			case SV_DRAGON_GOLD:
+			{
+				return "breathe sound (130) every 450+d450 turns";
+			}
+			case SV_DRAGON_CHAOS:
+			{
+				return "breathe chaos/disenchant (220) every 300+d300 turns";
+			}
+			case SV_DRAGON_LAW:
+			{
+				return "breathe sound/shards (230) every 300+d300 turns";
+			}
+			case SV_DRAGON_BALANCE:
+			{
+				return "breathe balance (250) every 300+d300 turns";
+			}
+			case SV_DRAGON_SHINING:
+			{
+				return "breathe light/darkness (200) every 300+d300 turns";
+			}
+			case SV_DRAGON_POWER:
+			{
+				return "breathe the elements (300) every 300+d300 turns";
+			}
+		}
+	}
 
-	/* Branch on the sub-type */
-	switch (o_ptr->sval)
+	/* Check rings */
+	if (o_ptr->tval == TV_RING)
 	{
-		case SV_DRAGON_BLUE:
+		switch (o_ptr->sval)
 		{
-			return "breathe lightning (100) every 450+d450 turns";
+		case SV_RING_ACID:
+			{
+				return "shoot acid (12d8) every 20+d20 turns";
+			}
+		case SV_RING_FLAMES:
+			{
+				return "shoot fire (12d8) every 20+d20 turns";
+			}
+		case SV_RING_ICE:
+			{
+				return "shoot frost (12d8) every 20+d20 turns";
+			}
+		case SV_RING_TELEPORTATION:
+			{
+				return "teleport every 50+d50 turns";
+			}
+		case SV_RING_MASTERY:
+			{
+				return "dispel monsters (100) every 1000+d1000 turns";
+			}
+		case SV_RING_METEORS:
+			{
+				return "meteor swarm (30) every 15+d15 turns";
+			}
 		}
-		case SV_DRAGON_WHITE:
+	}
+
+	/* Oops */
+	return NULL;
+}
+
+
+/*
+ * Calculate the multiplier we'll get with a given bow type.  This is done
+ * differently in 2.8.2 than it was in 2.8.1.
+ */
+static int bow_multiplier(int sval)
+{
+	switch (sval)
+	{
+		case SV_SLING:
+		case SV_SHORT_BOW:
+			return 2;
+		case SV_LONG_BOW:
+		case SV_LIGHT_XBOW:
+			return 3;
+		case SV_HEAVY_XBOW:
+			return 4;
+		default:
+			msg_format("Illegal bow sval %s\n", sval);
+	}
+
+	return 0;
+}
+
+
+/*
+ * Fill an array with a description of the item flags.
+ *
+ * "info" must point to a cptr array that is big enough to store all
+ * descriptions.
+ *
+ * Returns the number of lines.
+ *
+ * ToDo: Check the len of the array to prevent buffer overflows
+ * (yes, this is paranoid).
+ *
+ * ToDo: Allow dynamic generation of strings.
+ */
+static bool identify_fully_aux2(object_type *o_ptr, int mode)
+{
+	char buffer[80];
+
+	u32b f1, f2, f3;
+
+	int i;
+
+	int vn;
+	cptr vp[64];
+
+	bool worked = FALSE;
+	bool f;
+	bool has_brand = FALSE;
+	bool has_slay = FALSE;
+
+	/* Extract the "known" and "random" flags */
+	object_flags_aux(mode, o_ptr, &f1, &f2, &f3);
+
+	/* Mega-Hack -- describe activation */
+	if (f3 & (TR3_ACTIVATE))
+	{
+		roff(format("It can be activated for %s if it is being worn.  ", 
+			        item_activation(o_ptr, buffer)));
+		worked = TRUE;
+	}
+
+
+	/* Hack -- describe lite's */
+	if (o_ptr->tval == TV_LITE)
+	{
+		if (artifact_p(o_ptr))
 		{
-			return "breathe frost (110) every 450+d450 turns";
+			roff("It provides light (radius 3) forever.  ");
 		}
-		case SV_DRAGON_BLACK:
+		else if (o_ptr->sval == SV_LITE_LANTERN)
 		{
-			return "breathe acid (130) every 450+d450 turns";
+			roff("It provides light (radius 2) when fueled.  ");
 		}
-		case SV_DRAGON_GREEN:
+		else
 		{
-			return "breathe poison gas (150) every 450+d450 turns";
+			roff("It provides light (radius 1) when fueled.  ");
 		}
-		case SV_DRAGON_RED:
+		worked = TRUE;
+	}
+
+
+	/* Gather stat bonuses */
+	vn = 0;
+	if (f1 & (TR1_STR)) vp[vn++] = "strength";
+	if (f1 & (TR1_INT)) vp[vn++] = "intelligence";
+	if (f1 & (TR1_WIS)) vp[vn++] = "wisdom";
+	if (f1 & (TR1_DEX)) vp[vn++] = "dexterity";
+	if (f1 & (TR1_CON)) vp[vn++] = "constitution";
+	if (f1 & (TR1_CHR)) vp[vn++] = "charisma";
+	/* Hack - shorten to "all stats" if appropriate */
+	f = FALSE;
+	if (vn == 6)
+	{
+		vn = 0;
+		f = TRUE;
+	}
+	if (f1 & (TR1_STEALTH)) vp[vn++] = "stealth";
+	if (f1 & (TR1_SEARCH))  vp[vn++] = "searching";
+	if (f1 & (TR1_TUNNEL))  vp[vn++] = "tunneling";
+	if (f1 & (TR1_SPEED))   vp[vn++] = "speed";
+
+	if ((f || vn > 0) && o_ptr->pval != 0)
+	{
+		if (!f)
 		{
-			return "breathe fire (200) every 450+d450 turns";
+			if (o_ptr->pval > 0)
+				roff("It increases your ");
+			else
+				roff("It decreases your ");
 		}
-		case SV_DRAGON_MULTIHUED:
+		else
 		{
-			return "breathe multi-hued (250) every 225+d225 turns";
+			if (o_ptr->pval > 0)
+				roff("It increases all your stats");
+			else
+				roff("It decreases all your stats");
+			if (vn > 1)
+				roff(", ");
+			else if (vn > 0)
+				roff(" and your ");
 		}
-		case SV_DRAGON_BRONZE:
+
+		for (i = 0; i < vn; i++)
 		{
-			return "breathe confusion (120) every 450+d450 turns";
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
 		}
-		case SV_DRAGON_GOLD:
+
+		roff(format(" by %i.  ", ABS(o_ptr->pval)));
+		worked = TRUE;
+	}
+
+	if (f1 & (TR1_INFRA))
+	{
+		roff(format("It increases your infravision by %i'.  ", o_ptr->pval * 10));
+		worked = TRUE;
+	}
+
+	if (f1 & (TR1_BLOWS))
+	{
+		roff(format("It deals %i extra blow%s per round. ", o_ptr->pval, o_ptr->pval > 1 ? "s" : ""));
+		worked = TRUE;
+	}
+
+	if (f1 & (TR1_SHOTS))
+	{
+		roff(format("It fires %i extra shot%s per round. ", o_ptr->pval, o_ptr->pval > 1 ? "s" : ""));
+		worked = TRUE;
+	}
+
+	if (f1 & (TR1_MIGHT))
+	{
+		roff(format("Its damage multiplier is increased to x%i.  ", bow_multiplier(o_ptr->sval) + o_ptr->pval));
+		worked = TRUE;
+	}
+
+	/* Collect slays */
+	vn = 0;
+	if (f1 & (TR1_SLAY_ANIMAL)) vp[vn++] = "natural creatures";
+	if (f1 & (TR1_SLAY_EVIL))   vp[vn++] = "evil monsters";
+	if (f1 & (TR1_SLAY_ORC))    vp[vn++] = "orcs";
+	if (f1 & (TR1_SLAY_TROLL))  vp[vn++] = "trolls";
+	if (f1 & (TR1_SLAY_GIANT))  vp[vn++] = "giants";
+	if ((f1 & (TR1_SLAY_DRAGON)) && !(f1 & (TR1_KILL_DRAGON))) vp[vn++] = "dragons";
+	if (f1 & (TR1_SLAY_DEMON))  vp[vn++] = "demons";
+	if (f1 & (TR1_SLAY_UNDEAD)) vp[vn++] = "the undead";
+
+	if (vn > 0)
+	{
+		roff("It is especially deadly to ");
+
+		for (i = 0; i < vn; i++)
 		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
 		}
+
+		roff(".  ");
+		worked = TRUE;
+		has_slay = TRUE;
+	}
+
+	if (f1 & (TR1_KILL_DRAGON))
+	{
+		roff("It is great bane of dragons.  ");
+		worked = TRUE;
+		has_slay = TRUE;
+	}
+
+	/* Collect brands */
+	vn = 0;
+	if (f1 & (TR1_BRAND_NETHR)) vp[vn++] = "nether";
+	if (f1 & (TR1_BRAND_NEXUS)) vp[vn++] = "nexus";
+	if (f1 & (TR1_BRAND_CHAOS)) vp[vn++] = "chaos";
+	if (f1 & (TR1_BRAND_ACID))  vp[vn++] = "acid";
+	if (f1 & (TR1_BRAND_ELEC))  vp[vn++] = "electricity";
+	if (f1 & (TR1_BRAND_FIRE))  vp[vn++] = "fire";
+	if (f1 & (TR1_BRAND_COLD))  vp[vn++] = "frost";
+
+	if (vn > 0)
+	{
+		roff("It deals extra damage to monsters vulnerable to ");
+
+		for (i = 0; i < vn; i++)
 		{
-			return "breathe chaos/disenchant (220) every 300+d300 turns";
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" or ");
 		}
-		case SV_DRAGON_LAW:
+
+		roff(".  ");
+		worked = TRUE;
+		has_brand = TRUE;
+	}
+
+	/* Collect strange effects */
+	vn = 0;
+	if (f3 & (TR3_IMPACT))      vp[vn++] = "earthquakes";
+	if (f1 & (TR1_BRAND_NETHR)) vp[vn++] = "life draining";
+	if (f1 & (TR1_BRAND_NEXUS)) vp[vn++] = "teleportation";
+	if (f1 & (TR1_BRAND_CHAOS)) vp[vn++] = "strange effects";
+
+	if (vn > 0)
+	{
+		roff("It may cause ");
+
+		for (i = 0; i < vn; i++)
 		{
-			return "breathe sound/shards (230) every 300+d300 turns";
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" or ");
 		}
-		case SV_DRAGON_BALANCE:
+
+		roff(" when it hits.  ");
+		worked = TRUE;
+	}
+
+	/* Calculate average damage */
+	if ((p_ptr->pclass == CLASS_WARRIOR || p_ptr->wizard) && 
+		wield_slot(o_ptr) == INVEN_WIELD)
+	{
+		int dam2;
+
+		dam2 = o_ptr->dd * (o_ptr->ds + 1);
+		if (o_ptr->ident & (IDENT_KNOWN))
+			dam2 += 2 * o_ptr->to_d;
+		if (has_brand)
+			dam2 = dam2 * 3 / 2;
+		dam2 += 2 * p_ptr->to_d;
+
+		roff(format("It does about %i damage on an average hit against ", dam2 / 2));
+		if (has_slay || has_brand)
+			roff("most monsters.  ");
+		else
+			roff("all monsters.  ");
+
+		worked = TRUE;
+	}
+	/* Hack - determine type of ammo needed */
+	if ((p_ptr->pclass == CLASS_RANGER || p_ptr->wizard) &&
+		inventory[INVEN_BOW].number &&
+		o_ptr->tval == TV_SHOT + inventory[INVEN_BOW].sval / 10)
+	{
+		int dam2;
+
+		dam2 = o_ptr->dd * (o_ptr->ds + 1);
+		if (o_ptr->ident & (IDENT_KNOWN))
+			dam2 += 2 * o_ptr->to_d;
+		if (inventory[INVEN_BOW].ident & (IDENT_KNOWN))
+			dam2 += 2 * inventory[INVEN_BOW].to_d;
+
+		roff(format("It does about %i damage with your current missile weapon ", dam2 / 2));
+		if (has_slay || has_brand)
+			roff("on an average shot against most monsters.  ");
+		else
+			roff("on an average shot against all monsters.  ");
+
+		worked = TRUE;
+	}
+
+
+	/* Collect sustains */
+	vn = 0;
+	if (f2 & (TR2_SUST_STR)) vp[vn++] = "strength";
+	if (f2 & (TR2_SUST_INT)) vp[vn++] = "intelligence";
+	if (f2 & (TR2_SUST_WIS)) vp[vn++] = "wisdom";
+	if (f2 & (TR2_SUST_DEX)) vp[vn++] = "dexterity";
+	if (f2 & (TR2_SUST_CON)) vp[vn++] = "constitution";
+	if (f2 & (TR2_SUST_CHR)) vp[vn++] = "charisma";
+	/* Hack - shorten to "all stats" if appropriate */
+	if (vn == 6)
+		roff("It sustains all your stats.  ");
+	else if (vn > 0)
+	{
+		roff("It sustains your ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	/* Collect resistances */
+	vn = 0;
+	if ((f2 & (TR2_RES_ACID)) && !(f2 & (TR2_IM_ACID))) vp[vn++] = "acid";
+	if ((f2 & (TR2_RES_ELEC)) && !(f2 & (TR2_IM_ELEC))) vp[vn++] = "electricity";
+	if ((f2 & (TR2_RES_FIRE)) && !(f2 & (TR2_IM_FIRE))) vp[vn++] = "fire";
+	if ((f2 & (TR2_RES_COLD)) && !(f2 & (TR2_IM_COLD))) vp[vn++] = "cold";
+	if (f2 & (TR2_RES_POIS))  vp[vn++] = "poison";
+	if (f2 & (TR2_RES_FEAR))  vp[vn++] = "fear";
+	if (f2 & (TR2_RES_LITE))  vp[vn++] = "light";
+	if (f2 & (TR2_RES_DARK))  vp[vn++] = "darkness";
+	if (f2 & (TR2_RES_BLIND)) vp[vn++] = "blindness";
+	if (f2 & (TR2_RES_CONFU)) vp[vn++] = "confusion";
+	if (f2 & (TR2_RES_SOUND)) vp[vn++] = "sound";
+	if (f2 & (TR2_RES_SHARD)) vp[vn++] = "shards";
+	if (f2 & (TR2_RES_NEXUS)) vp[vn++] = "nexus";
+	if (f2 & (TR2_RES_NETHR)) vp[vn++] = "nether";
+	if (f2 & (TR2_RES_CHAOS)) vp[vn++] = "chaos";
+	if (f2 & (TR2_RES_DISEN)) vp[vn++] = "disenchantment";
+
+	if (vn > 0)
+	{
+		roff("It provides resistance to ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		if (f2 & (TR2_IM_ACID | TR2_IM_ELEC | TR2_IM_FIRE | TR2_IM_COLD))
+			roff(", and grants total immunity to ");
+		else
+			roff(".  ");
+		worked = TRUE;
+	}
+	else if (f2 & (TR2_IM_ACID | TR2_IM_ELEC | TR2_IM_FIRE | TR2_IM_COLD))
+		roff("It grants total immunity to ");
+
+	/* Collect immunities */
+	vn = 0;
+	if (f2 & (TR2_IM_ACID)) vp[vn++] = "acid";
+	if (f2 & (TR2_IM_ELEC)) vp[vn++] = "electricity";
+	if (f2 & (TR2_IM_FIRE)) vp[vn++] = "fire";
+	if (f2 & (TR2_IM_COLD)) vp[vn++] = "cold";
+
+	if (vn > 0)
+	{
+		for (i = 0; i < vn; i++)
 		{
-			return "breathe balance (250) every 300+d300 turns";
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
 		}
-		case SV_DRAGON_SHINING:
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	/* Collect minor powers */
+	vn = 0;
+	if (f3 & (TR3_SLOW_DIGEST)) vp[vn++] = "slows your metabolism";
+	if (f3 & (TR3_FEATHER))     vp[vn++] = "induces feather falling";
+	if (f3 & (TR3_LITE))        vp[vn++] = "provides permanent light";
+	if (f3 & (TR3_REGEN))       vp[vn++] = "speeds your regenerative powers";
+	if (f3 & (TR3_TELEPATHY))   vp[vn++] = "gives telepathic powers";
+	if (f3 & (TR3_SEE_INVIS))   vp[vn++] = "allows you to see invisible monsters";
+	if (f3 & (TR3_FREE_ACT))    vp[vn++] = "provides immunity to paralysis";
+	if (f3 & (TR3_HOLD_LIFE))   vp[vn++] = "provides resistance to life draining";
+	if (vn > 0)
+	{
+		roff("It ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	/* Collect curses */
+	vn = 0;
+	if (f3 & (TR3_TELEPORT))  vp[vn++] = "induces random teleportation";
+	if (f3 & (TR3_AGGRAVATE)) vp[vn++] = "aggravates nearby creatures";
+	if (f3 & (TR3_DRAIN_EXP)) vp[vn++] = "drains experience";
+
+	if (vn > 0)
+	{
+		roff("It ");
+
+		for (i = 0; i < vn; i++)
 		{
-			return "breathe light/darkness (200) every 300+d300 turns";
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
 		}
-		case SV_DRAGON_POWER:
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	if (f3 & (TR3_BLESSED))
+	{
+		roff("It has been blessed by the gods.  ");
+		worked = TRUE;
+	}
+
+	if (object_known_p(o_ptr) && cursed_p(o_ptr))
+	{
+		if (f3 & (TR3_PERMA_CURSE))
+			roff("It is permanently cursed.  ");
+		else if (f3 & (TR3_HEAVY_CURSE))
+			roff("It is heavily cursed.  ");
+		else
+			roff("It is cursed.  ");
+		worked = TRUE;
+	}
+
+	/* Collect immunities */
+	vn = 0;
+	if (f3 & (TR3_IGNORE_ACID)) vp[vn++] = "acid";
+	if (f3 & (TR3_IGNORE_ELEC)) vp[vn++] = "electricity";
+	if (f3 & (TR3_IGNORE_FIRE)) vp[vn++] = "fire";
+	if (f3 & (TR3_IGNORE_COLD)) vp[vn++] = "cold";
+	/* Hack - shorten to "the elements" if appropriate */
+	if (vn == 4)
+	{
+		vn = 0;
+		vp[vn++] = "the elements";
+	}
+
+	if (object_known_p(o_ptr) && artifact_p(o_ptr))
+	{
+		roff("It is an artifact.  ");
+		worked = TRUE;
+	}
+	else if (vn > 0)
+	{
+		roff("It cannot be harmed by ");
+
+		for (i = 0; i < vn; i++)
 		{
-			return "breathe the elements (300) every 300+d300 turns";
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" or ");
 		}
+
+		roff(".  ");
+		worked = TRUE;
 	}
 
+	if (p_ptr->pclass == CLASS_ROGUE || p_ptr->wizard)
+	{
+		s32b value = object_value(o_ptr);
 
-	/* Oops */
-	return NULL;
+		if (value > 0)
+			roff(format("It is worth about %i gold.  ", value));
+		else
+			roff("It is worthless.  ");
+
+		worked = TRUE;
+	}
+
+	if (p_ptr->wizard && object_known_p(o_ptr) && (o_ptr->ident & IDENT_MENTAL) && o_ptr->name3)
+	{
+		roff(format("Current power is %i.  ", artifact_power(o_ptr)));
+		worked = TRUE;
+	}
+
+	/* Unknown extra powers (ego-item with random extras or artifact) */
+	if (object_known_p(o_ptr) &&
+		(!(o_ptr->ident & IDENT_MENTAL)) &&
+	    ((o_ptr->xtra1) || artifact_p(o_ptr)))
+	{
+		roff("It has hidden powers.  ");
+		worked = TRUE;
+	}
+
+	/* All done */
+	roff("\n");
+
+
+	/* Return the number of lines */
+	return (worked);
 }
 
+/* XXX XXX XXX Hack */
+static char id_aux3_buffer[80];
 
-/*
- * Fill an array with a description of the item flags.
- *
- * "info" must point to a cptr array that is big enough to store all
- * descriptions.
- *
- * Returns the number of lines.
- *
- * ToDo: Check the len of the array to prevent buffer overflows
- * (yes, this is paranoid).
- *
- * ToDo: Allow dynamic generation of strings.
- */
-bool identify_fully_aux2(object_type *o_ptr, int mode, cptr *info, int len)
+static bool identify_fully_aux3(object_type *o_ptr, int mode, cptr *info, int len)
 {
 	int i = 0;
 
 	u32b f1, f2, f3;
@@ -2102,9 +2725,9 @@
 	/* Mega-Hack -- describe activation */
 	if (f3 & (TR3_ACTIVATE))
 	{
 		info[i++] = "It can be activated for...";
-		info[i++] = item_activation(o_ptr);
+		info[i++] = item_activation(o_ptr, id_aux3_buffer);
 		info[i++] = "...if it is being worn.";
 	}
 
 
@@ -2472,72 +3095,61 @@
 	/* Return the number of lines */
 	return (i);
 }
 
-
 /*
  * Describe an item's random attributes for "character dumps"
  */
 int identify_random_gen(object_type *o_ptr, cptr *info, int len)
 {
 	/* Fill the list of descriptions and return the count */
-	return identify_fully_aux2(o_ptr, OBJECT_FLAGS_RANDOM, info, len);
+	return identify_fully_aux3(o_ptr, OBJECT_FLAGS_RANDOM, info, len);
 }
 
 
 /*
  * Describe an item
  */
-bool identify_fully_aux(object_type *o_ptr)
+bool identify_fully_aux(object_type *o_ptr, char *o_name_in)
 {
 	int i, j, k;
-	cptr info[128];
-
-
-	/* Fill the list of descriptions */
-	i = identify_fully_aux2(o_ptr, OBJECT_FLAGS_KNOWN, info, 128);
-
-	/* No special effects */
-	if (!i) return (FALSE);
+	char o_name[80];
+	bool worked;
 
 
 	/* Save screen */
 	screen_save();
 
+	/* Begin recall */
+	Term_erase(0, 1, 255);
 
-	/* Erase the screen */
-	Term_clear();
-
-	/* Label the information */
-	prt("     Item Attributes:", 1, 0);
+	/* Recall monster */
+	worked = identify_fully_aux2(o_ptr, OBJECT_FLAGS_KNOWN);
 
-	/* Dump some info */
-	for (k = 2, j = 0; j < i; j++)
+	/* Did nothing happen? */
+	if (!worked)
 	{
-		/* Show the info */
-		prt(info[j], k++, 0);
+		screen_load();
+		return (FALSE);
+	}
 
-		/* Page wrap */
-		if ((k == 22) && (j+1 < i))
-		{
-			prt("-- more --", k, 0);
-			inkey();
+	/* Clear the top line */
+	Term_erase(0, 0, 255);
 
-			/* Erase the screen */
-			Term_clear();
+	/* Reset the cursor */
+	Term_gotoxy(0, 0);
 
-			/* Label the information */
-			prt("     Item Attributes:", 1, 0);
+	/* Get a description */
+	if (o_name_in)
+		strcpy(o_name, o_name_in);
+	else
+		object_desc(o_name, o_ptr, TRUE, 3);
 
-			/* Back to the top */
-			k = 2;
-		}
-	}
+	/* Dump the name */
+	Term_addstr(-1, TERM_WHITE, format("%^s", o_name));
 
-	/* Wait for it */
-	prt("[Press any key to continue]", k, 0);
+	/* Wait for a keypress */
 	(void)inkey();
-
 
 	/* Load screen */
 	screen_load();
 
diff --recursive --unified=4 angband-291/src/object2.c antiband/src/object2.c
--- angband-291/src/object2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/object2.c	Tue Nov 20 19:37:54 2001
@@ -433,15 +433,30 @@
 		/* Mega-Hack -- preserve artifacts */
 		if (!character_dungeon || adult_preserve)
 		{
 			/* Hack -- Preserve unknown artifacts */
-			if (artifact_p(o_ptr) && !object_known_p(o_ptr))
+			if (o_ptr->name1 && !object_known_p(o_ptr))
 			{
 				/* Mega-Hack -- Preserve the artifact */
 				a_info[o_ptr->name1].cur_num = 0;
 			}
 		}
 
+		/* Clear randarts */
+		if (o_ptr->name3)
+		{
+			if (p_ptr->wizard)
+			{
+				char o_name[80];
+
+				object_desc_store(o_name, o_ptr, FALSE, 0);
+				msg_format("Removing a randart (%s).", o_name);
+			}
+
+			/* Hack - first byte of name indicates used-ness */
+			x_info[o_ptr->name3].name[0] = 0;
+		}
+
 		/* Monster */
 		if (o_ptr->held_m_idx)
 		{
 			monster_type *m_ptr;
@@ -864,8 +879,20 @@
 		/* Hack -- Use the artifact cost instead */
 		value = a_ptr->cost;
 	}
 
+	/* Randart */
+	else if (o_ptr->name3)
+	{
+		randart_type *x_ptr = &x_info[o_ptr->name3];
+
+		/* Hack -- "worthless" artifacts */
+		if (!x_ptr->cost) return (0L);
+
+		/* Hack -- Use the artifact cost instead */
+		value = x_ptr->cost;
+	}
+
 	/* Ego-Item */
 	else if (o_ptr->name2)
 	{
 		ego_item_type *e_ptr = &e_info[o_ptr->name2];
@@ -1164,8 +1191,19 @@
 			/* Probably okay */
 			break;
 		}
 
+		/* Rings, Amulets, Lites */
+		case TV_RING:
+		case TV_AMULET:
+		case TV_LITE:
+		{
+			/* Require full knowledge of both items */
+			if (!object_known_p(o_ptr) || !object_known_p(j_ptr)) return (0);
+
+			/* Fall through */
+		}
+
 		/* Weapons and Armor */
 		case TV_BOW:
 		case TV_DIGGING:
 		case TV_HAFTED:
@@ -1180,18 +1218,19 @@
 		case TV_SOFT_ARMOR:
 		case TV_HARD_ARMOR:
 		case TV_DRAG_ARMOR:
 		{
-			/* Fall through */
-		}
-
-		/* Rings, Amulets, Lites */
-		case TV_RING:
-		case TV_AMULET:
-		case TV_LITE:
-		{
-			/* Require full knowledge of both items */
-			if (!object_known_p(o_ptr) || !object_known_p(j_ptr)) return (0);
+			/* Require knowledge or {average} pseudo-id for both items */
+			if (!object_known_p(o_ptr) && 
+				!(o_ptr->ident & (IDENT_SENSE) && o_ptr->discount == INSCRIP_AVERAGE))
+			{
+				return (0);
+			}
+			if (!object_known_p(j_ptr) && 
+				!(j_ptr->ident & (IDENT_SENSE) && j_ptr->discount == INSCRIP_AVERAGE))
+			{
+				return (0);
+			}
 
 			/* Fall through */
 		}
 
@@ -1216,8 +1255,11 @@
 
 			/* Require identical "ego-item" names */
 			if (o_ptr->name2 != j_ptr->name2) return (FALSE);
 
+			/* Require identical "randart" names */
+			if (o_ptr->name3 != j_ptr->name3) return (FALSE);
+
 			/* Hack -- Never stack "powerful" items */
 			if (o_ptr->xtra1 || j_ptr->xtra1) return (FALSE);
 
 			/* Hack -- Never stack recharging items */
@@ -1553,11 +1595,11 @@
  * Attempt to change an object into an ego-item -MWK-
  * Better only called by apply_magic()
  * The return value is currently unused, but a wizard might be interested in it.
  */
-static bool make_ego_item(object_type *o_ptr, bool cursed)
+bool make_ego_item(object_type *o_ptr, bool cursed, int level)
 {
-	int i, j, level;
+	int i, j;
 
 	int e_idx;
 
 	long value, total;
@@ -1569,10 +1611,12 @@
 
 	/* Fail if object already is ego or artifact */
 	if (o_ptr->name1) return (FALSE);
 	if (o_ptr->name2) return (FALSE);
+	if (o_ptr->name3) return (FALSE);
 
-	level = p_ptr->depth;
+	/* Gratuitous hack: fail DSM */
+	if (o_ptr->tval == TV_DRAG_ARMOR) return (FALSE);
 
 	/* Boost level (like with object base types) */
 	if (level > 0)
 	{
@@ -2117,8 +2161,20 @@
 
 					break;
 				}
 
+				/* Mastery */
+				case SV_RING_MASTERY:
+				{
+					/* Stat bonus */
+					o_ptr->pval = 1 + m_bonus(5, level);
+
+					/* Bonus to armor class */
+					o_ptr->to_a = 5 + randint(5) + m_bonus(10, level);
+
+					break;
+				}
+
 				/* Ring of Speed! */
 				case SV_RING_SPEED:
 				{
 					/* Base speed (1 to 10) */
@@ -2182,24 +2238,8 @@
 					o_ptr->to_a = 5 + randint(5) + m_bonus(10, level);
 					break;
 				}
 
-				/* Weakness, Stupidity */
-				case SV_RING_WEAKNESS:
-				case SV_RING_STUPIDITY:
-				{
-					/* Broken */
-					o_ptr->ident |= (IDENT_BROKEN);
-
-					/* Cursed */
-					o_ptr->ident |= (IDENT_CURSED);
-
-					/* Penalize */
-					o_ptr->pval = 0 - (1 + m_bonus(5, level));
-
-					break;
-				}
-
 				/* WOE, Stupidity */
 				case SV_RING_WOE:
 				{
 					/* Broken */
@@ -2303,8 +2343,32 @@
 					}
 
 					break;
 				}
+
+				/* Ring of Teleportation */
+				case SV_RING_TELEPORTATION:
+				{
+					/* Cursed */
+					if (power < 0)
+					{
+						/* Cursed */
+						o_ptr->ident |= (IDENT_CURSED);
+					}
+
+					break;
+				}
+
+				/* Ring of Elvenkind/Dwarvenkind */
+				case SV_RING_ELVENKIND:
+				case SV_RING_DWARVENKIND:
+				{
+					o_ptr->pval = 1 + m_bonus(3, level);
+
+					/* Never cursed */
+
+					break;
+				}
 			}
 
 			break;
 		}
@@ -2486,11 +2550,11 @@
  * a chance that an artifact will be created.  This is true even if both the
  * "good" and "great" arguments are false.  Objects which are forced "great"
  * get three extra "attempts" to become an artifact.
  */
-void apply_magic(object_type *o_ptr, int lev, bool okay, bool good, bool great)
+void apply_magic(object_type *o_ptr, int lev, bool okay, bool good, bool great, bool force_randart)
 {
-	int i, rolls, f1, f2, power;
+	int i, rolls, f1, f2, f3, power;
 
 
 	/* Maximum "level" for various things */
 	if (lev > MAX_DEPTH - 1) lev = MAX_DEPTH - 1;
@@ -2507,8 +2571,14 @@
 
 	/* Maximal chance of being "great" */
 	if (f2 > 20) f2 = 20;
 
+	/* Base chance of being "randart" */
+	f3 = f1 / 5;
+
+	/* Maximal chance of being "randart" */
+	if (f3 > 10) f3 = 10;
+
 
 	/* Assume normal */
 	power = 0;
 
@@ -2518,9 +2588,15 @@
 		/* Assume "good" */
 		power = 1;
 
 		/* Roll for "great" */
-		if (great || (rand_int(100) < f2)) power = 2;
+		if (great || (rand_int(100) < f2)) 
+		{
+			power = 2;
+
+			/* Roll for "randart" */
+			if (force_randart || (rand_int(100) < f3)) power = 3;
+		}
 	}
 
 	/* Roll for "cursed" */
 	else if (rand_int(100) < f1)
@@ -2528,9 +2604,15 @@
 		/* Assume "cursed" */
 		power = -1;
 
 		/* Roll for "broken" */
-		if (rand_int(100) < f2) power = -2;
+		if (rand_int(100) < f2) 
+		{
+			power = -2;
+
+			/* Roll for "terrible */
+			if (rand_int(100) < f3) power = -3;
+		}
 	}
 
 
 	/* Assume no rolls */
@@ -2541,10 +2623,13 @@
 
 	/* Get four rolls if forced great */
 	if (great) rolls = 4;
 
+	/* Randarts don't get rolls */
+	if (power >= 3) rolls = 0;
+
 	/* Get no rolls if not allowed */
-	if (!okay || o_ptr->name1) rolls = 0;
+	if (!okay || o_ptr->name1 || o_ptr->name3) rolls = 0;
 
 	/* Roll for artifacts if allowed */
 	for (i = 0; i < rolls; i++)
 	{
@@ -2601,15 +2686,23 @@
 		case TV_HAFTED:
 		case TV_POLEARM:
 		case TV_SWORD:
 		case TV_BOW:
+		{
+			if (power) a_m_aux_1(o_ptr, lev, power);
+			if (power > 2 || power < -2)
+				make_randart(o_ptr, (bool)((power < 0) ? TRUE : FALSE));
+			else if (power > 1 || power < -1)
+				(void)make_ego_item(o_ptr, (bool)((power < 0) ? TRUE : FALSE), p_ptr->depth);
+			break;
+		}
 		case TV_SHOT:
 		case TV_ARROW:
 		case TV_BOLT:
 		{
 			if (power) a_m_aux_1(o_ptr, lev, power);
-			if (((power > 1) ? TRUE : FALSE) || ((power < -1) ? TRUE : FALSE))
-				(void)make_ego_item(o_ptr, (bool)((power < 0) ? TRUE : FALSE));
+			if (power > 1 || power < -1)
+				(void)make_ego_item(o_ptr, (bool)((power < 0) ? TRUE : FALSE), p_ptr->depth);
 			break;
 		}
 
 		case TV_DRAG_ARMOR:
@@ -2622,10 +2715,12 @@
 		case TV_GLOVES:
 		case TV_BOOTS:
 		{
 			if (power) a_m_aux_2(o_ptr, lev, power);
-			if (((power > 1) ? TRUE : FALSE) || (power < -1))
-				(void)make_ego_item(o_ptr, (bool)((power < 0) ? TRUE : FALSE));
+			if (power > 2 || power < -2)
+				make_randart(o_ptr, (bool)((power < 0) ? TRUE : FALSE));
+			else if (power > 1 || power < -1)
+				(void)make_ego_item(o_ptr, (bool)((power < 0) ? TRUE : FALSE), p_ptr->depth);
 			break;
 		}
 
 		case TV_RING:
@@ -2652,28 +2747,8 @@
 		/* Extra powers */
 		if (e_ptr->xtra)
 		{
 			o_ptr->xtra1 = e_ptr->xtra;
-			switch (o_ptr->xtra1)
-			{
-				case OBJECT_XTRA_TYPE_SUSTAIN:
-				{
-					o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_SUSTAIN);
-					break;
-				}
-
-				case OBJECT_XTRA_TYPE_RESIST:
-				{
-					o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_RESIST);
-					break;
-				}
-
-				case OBJECT_XTRA_TYPE_POWER:
-				{
-					o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_POWER);
-					break;
-				}
-			}
 		}
 
 		/* Hack -- acquire "broken" flag */
 		if (!e_ptr->cost) o_ptr->ident |= (IDENT_BROKEN);
@@ -2707,27 +2782,103 @@
 
 		/* Hack -- apply rating bonus */
 		rating += e_ptr->rating;
 
+		/* Hack -- weapons of Slaying get extra damage dice */
+		if (o_ptr->name2 == EGO_SLAYING_2)
+		{
+			o_ptr->dd++;
+			if (rand_int(5) == 0)
+				o_ptr->dd++;
+		}
+
 		/* Cheat -- describe the item */
 		if (cheat_peek) object_mention(o_ptr);
 
 		/* Done */
 		return;
 	}
 
 
+	/* Hack -- analyze artifacts */
+	if (o_ptr->name3)
+	{
+		randart_type *x_ptr = &x_info[o_ptr->name3];
+
+		/* Hack -- extract the "broken" flag */
+		if (!x_ptr->cost) o_ptr->ident |= (IDENT_BROKEN);
+
+		/* Hack -- extract the "cursed" flag */
+		if (x_ptr->flags3 & (TR3_LIGHT_CURSE)) o_ptr->ident |= (IDENT_CURSED);
+
+		/* Mega-Hack -- increase the rating */
+		rating += 10;
+
+		/* Mega-Hack -- increase the rating again */
+		if (x_ptr->cost > 50000L) rating += 10;
+
+		/* Cheat -- peek at the item */
+		if (cheat_peek) object_mention(o_ptr);
+
+		/* Done */
+		return;
+	}
+
+
 	/* Examine real objects */
 	if (o_ptr->k_idx)
 	{
 		object_kind *k_ptr = &k_info[o_ptr->k_idx];
 
+		/* Total hack - examine rings of resistance */
+		if (o_ptr->tval == TV_RING && o_ptr->sval == SV_RING_RESISTANCE)
+		{
+			o_ptr->xtra1 = OBJECT_XTRA_TYPE_RESIST;
+		}
+
+		/* Total hack - examine rings of mastery */
+		if (o_ptr->tval == TV_RING && o_ptr->sval == SV_RING_MASTERY)
+		{
+			o_ptr->xtra1 = OBJECT_XTRA_TYPE_POWER;
+		}
+
+		/* Total hack - examine amulets of the magi */
+		if (o_ptr->tval == TV_AMULET && o_ptr->sval == SV_AMULET_THE_MAGI)
+		{
+			o_ptr->xtra1 = OBJECT_XTRA_TYPE_POWER;
+		}
+
 		/* Hack -- acquire "broken" flag */
 		if (!k_ptr->cost) o_ptr->ident |= (IDENT_BROKEN);
 
 		/* Hack -- acquire "cursed" flag */
 		if (k_ptr->flags3 & (TR3_LIGHT_CURSE)) o_ptr->ident |= (IDENT_CURSED);
 	}
+
+	/* Handle special powers */
+	if (o_ptr->xtra1)
+	{
+		switch (o_ptr->xtra1)
+		{
+			case OBJECT_XTRA_TYPE_SUSTAIN:
+			{
+				o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_SUSTAIN);
+				break;
+			}
+
+			case OBJECT_XTRA_TYPE_RESIST:
+			{
+				o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_RESIST);
+				break;
+			}
+
+			case OBJECT_XTRA_TYPE_POWER:
+			{
+				o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_POWER);
+				break;
+			}
+		}
+	}
 }
 
 
 
@@ -2794,12 +2945,13 @@
 			if (k_ptr->sval == SV_RING_SPEED) return (TRUE);
 			return (FALSE);
 		}
 
-		/* Amulets -- Amulets of the Magi are good */
+		/* Amulets -- Amulets of the Magi and the Planes are good */
 		case TV_AMULET:
 		{
 			if (k_ptr->sval == SV_AMULET_THE_MAGI) return (TRUE);
+			if (k_ptr->sval == SV_AMULET_THE_PLANES) return (TRUE);
 			return (FALSE);
 		}
 	}
 
@@ -2817,9 +2969,9 @@
  * This routine uses "object_level" for the "generation level".
  *
  * We assume that the given object has been "wiped".
  */
-bool make_object(object_type *j_ptr, bool good, bool great)
+bool make_object(object_type *j_ptr, bool good, bool great, bool force_randart)
 {
 	int prob, base;
 
 
@@ -2830,9 +2982,9 @@
 	base = (good ? (object_level + 10) : object_level);
 
 
 	/* Generate a special artifact, or a normal object */
-	if ((rand_int(prob) != 0) || !make_artifact_special(j_ptr))
+	if (force_randart || (rand_int(prob) != 0) || !make_artifact_special(j_ptr))
 	{
 		int k_idx;
 
 		/* Good objects */
@@ -2865,9 +3017,9 @@
 		object_prep(j_ptr, k_idx);
 	}
 
 	/* Apply magic (allow artifacts) */
-	apply_magic(j_ptr, object_level, TRUE, good, great);
+	apply_magic(j_ptr, object_level, TRUE, good, great, force_randart);
 
 	/* Hack -- generate multiple spikes/missiles */
 	switch (j_ptr->tval)
 	{
@@ -3256,9 +3408,9 @@
 		/* Wipe the object */
 		object_wipe(i_ptr);
 
 		/* Make a good (or great) object (if possible) */
-		if (!make_object(i_ptr, TRUE, great)) continue;
+		if (!make_object(i_ptr, TRUE, great, FALSE)) continue;
 
 		/* Drop the object */
 		drop_near(i_ptr, -1, y1, x1);
 	}
@@ -3285,9 +3437,9 @@
 	/* Wipe the object */
 	object_wipe(i_ptr);
 
 	/* Make an object (if possible) */
-	if (make_object(i_ptr, good, great))
+	if (make_object(i_ptr, good, great, FALSE))
 	{
 		/* Give it to the floor */
 		if (!floor_carry(y, x, i_ptr))
 		{
@@ -4289,9 +4441,9 @@
 	/* Paranoia -- must be literate */
 	if (!mp_ptr->spell_book) return (100);
 
 	/* Get the spell */
-	s_ptr = &mp_ptr->info[spell];
+	s_ptr = &spells[mp_ptr->spell_type][spell].casters[p_ptr->pclass];
 
 	/* Extract the base spell failure rate */
 	chance = s_ptr->sfail;
 
@@ -4347,9 +4499,9 @@
 {
 	magic_type *s_ptr;
 
 	/* Get the spell */
-	s_ptr = &mp_ptr->info[spell];
+	s_ptr = &spells[mp_ptr->spell_type][spell].casters[p_ptr->pclass];
 
 	/* Spell is illegal */
 	if (s_ptr->slevel > p_ptr->lev) return (FALSE);
 
@@ -4413,9 +4565,9 @@
 			case 38: sprintf(p, " dam %dd8", (6+((plev-5)/4))); break;
 			case 39: sprintf(p, " dam %d", 40 + plev/2); break;
 			case 40: sprintf(p, " dam %d", 40 + plev); break;
 			case 41: sprintf(p, " dam %d", 70 + plev); break;
-			case 42: sprintf(p, " dam %d", 65 + plev); break;
+			case 42: sprintf(p, " dam %d", 33 + plev / 2); break;
 			case 43: sprintf(p, " dam %d", 300 + plev*2); break;
 			case 49: strcpy(p, " dur 20+d20"); break;
 			case 50: strcpy(p, " dur 20+d20"); break;
 			case 51: strcpy(p, " dur 20+d20"); break;
@@ -4471,9 +4623,9 @@
 
 /*
  * Print a list of spells (for browsing or casting or viewing).
  */
-void print_spells(byte *spells, int num, int y, int x)
+void print_spells(u16b *spell_table, int num, int y, int x)
 {
 	int i, spell;
 
 	magic_type *s_ptr;
@@ -4494,12 +4646,12 @@
 	/* Dump the spells */
 	for (i = 0; i < num; i++)
 	{
 		/* Get the spell index */
-		spell = spells[i];
+		spell = spell_table[i];
 
 		/* Get the spell info */
-		s_ptr = &mp_ptr->info[spell];
+		s_ptr = &spells[mp_ptr->spell_type][spell].casters[p_ptr->pclass];
 
 		/* Skip illegible spells */
 		if (s_ptr->slevel >= 99)
 		{
@@ -4549,9 +4701,9 @@
 		}
 
 		/* Dump the spell --(-- */
 		sprintf(out_val, "  %c) %-30s%2d %4d %3d%%%s",
-		        I2A(i), spell_names[mp_ptr->spell_type][spell],
+		        I2A(i), spells[mp_ptr->spell_type][spell].name,
 		        s_ptr->slevel, s_ptr->smana, spell_chance(spell), comment);
 		c_prt(line_attr, out_val, y + i + 1, x);
 	}
 
@@ -4567,9 +4719,9 @@
  * Include list of usable spells for readible books
  */
 void display_koff(int k_idx)
 {
-	int y;
+	int y, i;
 
 	object_type *i_ptr;
 	object_type object_type_body;
 
@@ -4614,25 +4766,19 @@
 
 		int spell;
 		int num = 0;
 
-		byte spells[64];
+		u16b spells[64];
 
 
 		/* Get the item's sval */
 		sval = i_ptr->sval;
 
 		/* Extract spells */
-		for (spell = 0; spell < 64; spell++)
+		for (i = 0; i < 12; i++)
 		{
-			/* Check for this spell */
-			if ((spell < 32) ?
-			    (spell_flags[mp_ptr->spell_type][sval][0] & (1L << spell)) :
-			    (spell_flags[mp_ptr->spell_type][sval][1] & (1L << (spell - 32))))
-			{
-				/* Collect this spell */
-				spells[num++] = spell;
-			}
+			if (spell_list[mp_ptr->spell_type][sval][i] > 0)
+				spells[num++] = spell_list[mp_ptr->spell_type][sval][i];
 		}
 
 		/* Print spells */
 		print_spells(spells, num, 2, 0);
diff --recursive --unified=4 angband-291/src/randart.c antiband/src/randart.c
--- angband-291/src/randart.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/randart.c	Sun Nov  4 14:21:16 2001
@@ -12,17 +12,17 @@
 #include "angband.h"
 
 
 /*
- * Random artifact generator (randart) by Greg Wooledge.
+ * Random artifact generator (randart) 
+ *
+ * Original code by Greg Wooledge, heavily mutilated by Ross Morgan-Linial
  *
  * Note that the direct use of malloc/free is a bad idea.  XXX XXX XXX
  *
  * The external "names.txt" file was sucked into this file for simplicity.
  */
 
-#ifdef GJW_RANDART
-
 static const char *names_list =
 "adanedhel\n"
 "adurant\n"
 "aeglos\n"
@@ -655,8 +655,11 @@
 	if (t) strcpy(t, s);
 	return t;
 }
 
+/* Hackish */
+static bool probs_built = FALSE;
+
 
 /*
  * Use W. Sheldon Simms' random name generator.  This function builds
  * probability tables which are used later on for letter selection.  It
@@ -706,8 +709,15 @@
 	int tries, lnum, vow;
 	int c_prev, c_cur, c_next;
 	char *cp;
 
+	/* If we haven't built the probability tables, do so now */
+	if (!probs_built)
+	{
+		build_prob(names_list);
+		probs_built = TRUE;
+	}
+
 startover:
 	vow = 0;
 	lnum = 0;
 	tries = 0;
@@ -759,98 +769,28 @@
 
 /*
  * Use W. Sheldon Simms' random name generator.
  */
-static int init_names(void)
+static void name_randart(randart_type *x_ptr)
 {
-	char buf[BUFLEN];
-	size_t name_size;
-	char *a_base;
-	char *a_next;
-	int i;
-
-	/* Temporary space for names, while reading and randomizing them. */
-	char **names;
-	int nnames = 0;
-
-
-	build_prob(names_list);
-
-	/* Allocate the "names" array */
-	/* ToDo: Make sure the memory is freed correctly in case of errors */
-	C_MAKE(names, z_info->a_max, char*);
+	char *cp;
 
-	for (i = 0; i < z_info->a_max; i++)
+	while (1)
 	{
-		char *word = make_word();
+		cp = make_word();
+
+		if (strlen(cp) >= 17)
+			continue;
 
 		if (rand_int(3) == 0)
-			sprintf(buf, "'%s'", word);
+			sprintf(x_ptr->name, "'%s'", cp);
 		else
-			sprintf(buf, "of %s", word);
-		names[i] = my_strdup(buf);
-	}
+			sprintf(x_ptr->name, "of %s", cp);
 
-	/* Special cases -- keep these three names separate. */
-	free(names[ART_POWER - 1]);
-	free(names[ART_GROND - 1]);
-	free(names[ART_MORGOTH - 1]);
-
-	if ((names[ART_POWER - 1] = my_strdup("of Power (The One Ring)")) == NULL)
-	{
-		msg_format("Memory allocation error");
-		return 1;
-	}
-
-	if ((names[ART_GROND - 1] = my_strdup("'Grond'")) == NULL)
-	{
-		msg_format("Memory allocation error");
-		return 1;
-	}
-
-	if ((names[ART_MORGOTH - 1] = my_strdup("of Morgoth")) == NULL)
-	{
-		msg_format("Memory allocation error");
-		return 1;
-	}
-
-	/* Convert our names array into an a_name structure for later use. */
-	name_size = 0;
-
-	for (i = 1; i < z_info->a_max; i++)
-	{
-		name_size += strlen(names[i-1]) + 2;	/* skip first char */
-	}
-
-	C_MAKE(a_base, name_size, char);
-
-	a_next = a_base + 1;	/* skip first char */
-
-	for (i = 1; i < z_info->a_max; i++)
-	{
-		strcpy(a_next, names[i-1]);
-		if (a_info[i].tval > 0)		/* skip unused! */
-			a_info[i].name = a_next - a_base;
-		a_next += strlen(names[i-1]) + 1;
-	}
-
-	/* Free some of our now unneeded memory. */
-	KILL(a_name, char);
-
-	for (i = 0; i < nnames; i++)
-	{
-		free(names[i]);
+		return;
 	}
-
-	/* Free the "names" array */
-	C_KILL(names, z_info->a_max, char*);
-
-	a_name = a_base;
-
-	return 0;
 }
 
-
 /*
  * Calculate the multiplier we'll get with a given bow type.  This is done
  * differently in 2.8.2 than it was in 2.8.1.
  */
@@ -873,107 +813,107 @@
 	return 0;
 }
 
 
+static s32b pval_table[9] = {0, 1, 2, 4, 6, 8, 10, 13, 10000};
+
 /*
  * Evaluate the artifact's overall power level.
  */
-static s32b artifact_power(int a_idx, bool cannot_use_kind_cache)
+s32b artifact_power(object_type *o_ptr)
 {
-	const artifact_type *a_ptr = &a_info[a_idx];
-	s32b p = 0;
+	const randart_type *x_ptr = &x_info[o_ptr->name3];
+	s32b p = 0, b;
 	s16b k_idx;
 	object_kind *k_ptr = NULL;	/* silence the warning */
 	int immunities = 0;
 
-	/* Start with a "power" rating derived from the base item's level. */
-	if (a_idx >= ART_MIN_NORMAL)
-	{
-		if (cannot_use_kind_cache)
-			k_idx = lookup_kind(a_ptr->tval, a_ptr->sval);
-		else
-			k_idx = kinds[a_idx];
+	if (!o_ptr->name3) return 0;
 
-		if (k_idx)
-		{
-			k_ptr = &k_info[k_idx];
-			p = (k_ptr->level + 7) / 8;
-		}
-		/* Otherwise just forget it and use 0. ;-) */
-	}
+	k_idx = o_ptr->k_idx;
+	k_ptr = &k_info[k_idx];
+	p = (k_ptr->level + 7) / 8;
 
 	/* Evaluate certain abilities based on type of object. */
-	switch (a_ptr->tval)
+	switch (o_ptr->tval)
 	{
 		case TV_BOW:
 		{
 			int mult;
 
-			p += (a_ptr->to_d + sign(a_ptr->to_d)) / 2;
-			mult = bow_multiplier(a_ptr->sval);
-			if (a_ptr->flags1 & TR1_MIGHT)
+			p += (o_ptr->to_d + sign(o_ptr->to_d)) / 2;
+			mult = bow_multiplier(o_ptr->sval);
+			if (x_ptr->flags1 & TR1_MIGHT)
 			{
-				if (a_ptr->pval > 3)
+				if (o_ptr->pval > 3)
 				{
 					p += 20000;	/* inhibit */
 					mult = 1;	/* don't overflow */
 				}
 				else
-					mult += a_ptr->pval;
+					mult += o_ptr->pval;
 			}
 			p *= mult;
-			if (a_ptr->flags1 & TR1_SHOTS)
+			if (x_ptr->flags1 & TR1_SHOTS)
 			{
-				if (a_ptr->pval > 3)
+				if (o_ptr->pval > 3)
 					p += 20000;	/* inhibit */
-				else if (a_ptr->pval > 0)
-					p *= (2 * a_ptr->pval);
+				else if (o_ptr->pval > 0)
+					p *= (1 + o_ptr->pval);
 			}
-			p += (a_ptr->to_h + 3 * sign(a_ptr->to_h)) / 4;
-			if (a_ptr->weight < k_ptr->weight) p++;
+			p += (o_ptr->to_h + 3 * sign(o_ptr->to_h)) / 4;
+			if (o_ptr->weight < k_ptr->weight) p++;
 			break;
 		}
 		case TV_DIGGING:
 		case TV_HAFTED:
 		case TV_POLEARM:
 		case TV_SWORD:
+		case TV_SHOT:
+		case TV_ARROW:
+		case TV_BOLT:
 		{
-			p += (a_ptr->dd * a_ptr->ds + 1) / 2;
-			if (a_ptr->flags1 & TR1_SLAY_EVIL) p = (p * 3) / 2;
-			if (a_ptr->flags1 & TR1_KILL_DRAGON) p = (p * 3) / 2;
-			if (a_ptr->flags1 & TR1_SLAY_ANIMAL) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_SLAY_UNDEAD) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_SLAY_DRAGON) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_SLAY_DEMON) p = (p * 5) / 4;
-			if (a_ptr->flags1 & TR1_SLAY_TROLL) p = (p * 5) / 4;
-			if (a_ptr->flags1 & TR1_SLAY_ORC) p = (p * 5) / 4;
-			if (a_ptr->flags1 & TR1_SLAY_GIANT) p = (p * 6) / 5;
-
-			if (a_ptr->flags1 & TR1_BRAND_ACID) p = p * 2;
-			if (a_ptr->flags1 & TR1_BRAND_ELEC) p = (p * 3) / 2;
-			if (a_ptr->flags1 & TR1_BRAND_FIRE) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_BRAND_COLD) p = (p * 4) / 3;
-
-			p += (a_ptr->to_d + 2 * sign(a_ptr->to_d)) / 3;
-			if (a_ptr->to_d > 15) p += (a_ptr->to_d - 14) / 2;
+			p += (o_ptr->dd * (o_ptr->ds + 1)) / 5;
+			p += (o_ptr->to_d + 2 * sign(o_ptr->to_d)) / 3;
+			if (o_ptr->to_d > 15) p += (o_ptr->to_d - 14) / 2;
+
+			b = p;
+
+			if (x_ptr->flags1 & TR1_SLAY_EVIL)   p += b / 4;	/* + 50% dam, rarity factor 2 */
+			if (x_ptr->flags1 & TR1_KILL_DRAGON) p += b / 3;	/* +200% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_ANIMAL) p += b / 6;	/* + 50% dam, rarity factor 3 */
+			if (x_ptr->flags1 & TR1_SLAY_UNDEAD) p += b / 4;	/* +100% dam, rarity factor 4 */
+			if (x_ptr->flags1 & TR1_SLAY_DRAGON) p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_DEMON)  p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_TROLL)  p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_ORC)    p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_GIANT)  p += b / 9;	/* +100% dam, rarity factor 9 */
+
+			if (x_ptr->flags1 & TR1_BRAND_NETHR) p += b / 2;	/* + 50% dam, rarity factor 1 */
+			if (x_ptr->flags1 & TR1_BRAND_NEXUS) p += b / 2;	/* + 50% dam, rarity factor 1 */
+			if (x_ptr->flags1 & TR1_BRAND_CHAOS) p += b / 2;	/* + 50% dam, rarity factor 1 */
+			if (x_ptr->flags1 & TR1_BRAND_ACID)  p += b / 3;	/* + 50% dam, rarity factor 1.5 */
+			if (x_ptr->flags1 & TR1_BRAND_ELEC)  p += b / 4;	/* + 50% dam, rarity factor 2 */
+			if (x_ptr->flags1 & TR1_BRAND_FIRE)  p += b / 5;	/* + 50% dam, rarity factor 2.5 */
+			if (x_ptr->flags1 & TR1_BRAND_COLD)  p += b / 4;	/* + 50% dam, rarity factor 2 */
 
-			if (a_ptr->flags1 & TR1_BLOWS)
+			if (x_ptr->flags1 & TR1_BLOWS)
 			{
-				if (a_ptr->pval > 3)
+				if (o_ptr->pval > 3)
 					p += 20000;	/* inhibit */
-				else if (a_ptr->pval > 0)
-					p = (p * 6) / (4 - a_ptr->pval);
+				else if (o_ptr->pval > 0)
+					p = (p * 6) / (4 - o_ptr->pval);
 			}
 
-			if ((a_ptr->flags1 & TR1_TUNNEL) &&
-			    (a_ptr->tval != TV_DIGGING))
-				p += a_ptr->pval * 3;
+			if ((x_ptr->flags1 & TR1_TUNNEL) &&
+			    (o_ptr->tval != TV_DIGGING))
+				p += o_ptr->pval * 3;
 
-			p += (a_ptr->to_h + 3 * sign(a_ptr->to_h)) / 4;
+			p += (o_ptr->to_h + 3 * sign(o_ptr->to_h)) / 4;
 
 			/* Remember, weight is in 0.1 lb. units. */
-			if (a_ptr->weight != k_ptr->weight)
-				p += (k_ptr->weight - a_ptr->weight) / 20;
+			if (o_ptr->weight != k_ptr->weight)
+				p += (k_ptr->weight - o_ptr->weight) / 20;
 
 			break;
 		}
 		case TV_BOOTS:
@@ -984,13 +924,13 @@
 		case TV_CLOAK:
 		case TV_SOFT_ARMOR:
 		case TV_HARD_ARMOR:
 		{
-			p += (a_ptr->ac + 4 * sign(a_ptr->ac)) / 5;
-			p += (a_ptr->to_h + sign(a_ptr->to_h)) / 2;
-			p += (a_ptr->to_d + sign(a_ptr->to_d)) / 2;
-			if (a_ptr->weight != k_ptr->weight)
-				p += (k_ptr->weight - a_ptr->weight) / 30;
+			p += (o_ptr->ac + 4 * sign(o_ptr->ac)) / 5;
+			p += (o_ptr->to_h + sign(o_ptr->to_h)) / 2;
+			p += (o_ptr->to_d + sign(o_ptr->to_d)) / 2;
+			if (o_ptr->weight != k_ptr->weight)
+				p += (k_ptr->weight - o_ptr->weight) / 30;
 			break;
 		}
 		case TV_LITE:
 		{
@@ -1005,915 +945,1107 @@
 		}
 	}
 
 	/* Other abilities are evaluated independent of the object type. */
-	p += (a_ptr->to_a + 3 * sign(a_ptr->to_a)) / 4;
-	if (a_ptr->to_a > 20) p += (a_ptr->to_a - 19) / 2;
-	if (a_ptr->to_a > 30) p += (a_ptr->to_a - 29) / 2;
-	if (a_ptr->to_a > 40) p += 20000;	/* inhibit */
-
-	if (a_ptr->pval > 0)
-	{
-		if (a_ptr->flags1 & TR1_STR) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_INT) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_WIS) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_DEX) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_CON) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_STEALTH) p += a_ptr->pval * a_ptr->pval;
-	}
-	else if (a_ptr->pval < 0)	/* hack: don't give large negatives */
-	{
-		if (a_ptr->flags1 & TR1_STR) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_INT) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_WIS) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_DEX) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_CON) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_STEALTH) p += a_ptr->pval;
-	}
-	if (a_ptr->flags1 & TR1_CHR) p += a_ptr->pval;
-	if (a_ptr->flags1 & TR1_INFRA) p += (a_ptr->pval + sign(a_ptr->pval)) / 2;
-	if (a_ptr->flags1 & TR1_SPEED) p += (a_ptr->pval * 3) / 2;
-
-	if (a_ptr->flags2 & TR2_SUST_STR) p += 6;
-	if (a_ptr->flags2 & TR2_SUST_INT) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_WIS) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_DEX) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_CON) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_CHR) p += 1;
-	if (a_ptr->flags2 & TR2_IM_ACID)
+	p += (o_ptr->to_a + 3 * sign(o_ptr->to_a)) / 4;
+	if (o_ptr->to_a > 20) p += (o_ptr->to_a - 19) / 2;
+	if (o_ptr->to_a > 30) p += (o_ptr->to_a - 29) / 2;
+	if (o_ptr->to_a > 40) p += 20000;	/* inhibit */
+
+	if (o_ptr->pval > 0)
+	{
+		int b = o_ptr->pval;
+		if (b > 8) b = 8;
+
+		if (x_ptr->flags1 & TR1_STR) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_INT) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_WIS) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_DEX) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_CON) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_STEALTH) p += pval_table[b];
+	}
+	else if (o_ptr->pval < 0)	/* hack: don't give large negatives */
+	{
+		if (x_ptr->flags1 & TR1_STR) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_INT) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_WIS) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_DEX) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_CON) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_STEALTH) p += o_ptr->pval;
+	}
+	if (x_ptr->flags1 & TR1_CHR) p += 3 * o_ptr->pval;
+	if (x_ptr->flags1 & TR1_INFRA) p += (o_ptr->pval + sign(o_ptr->pval));
+	if (x_ptr->flags1 & TR1_SPEED)
+	{
+		p += 2 * o_ptr->pval;
+		if (o_ptr->pval > 3)
+			p += (o_ptr->pval - 3) * 3;
+	}
+
+	if (x_ptr->flags2 & TR2_SUST_STR) p += 3;
+	if (x_ptr->flags2 & TR2_SUST_INT) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_WIS) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_DEX) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_CON) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_CHR) p += 1;
+	if (x_ptr->flags2 & TR2_IM_ACID)
 	{
-		p += 20;
+		p += 35;
 		immunities++;
 	}
-	if (a_ptr->flags2 & TR2_IM_ELEC)
+	if (x_ptr->flags2 & TR2_IM_ELEC)
 	{
-		p += 24;
+		p += 30;
 		immunities++;
 	}
-	if (a_ptr->flags2 & TR2_IM_FIRE)
+	if (x_ptr->flags2 & TR2_IM_FIRE)
 	{
-		p += 36;
+		p += 40;
 		immunities++;
 	}
-	if (a_ptr->flags2 & TR2_IM_COLD)
+	if (x_ptr->flags2 & TR2_IM_COLD)
 	{
-		p += 24;
+		p += 30;
 		immunities++;
 	}
-	if (immunities > 1) p += 16;
-	if (immunities > 2) p += 16;
-	if (immunities > 3) p += 20000;		/* inhibit */
-	if (a_ptr->flags3 & TR3_FREE_ACT) p += 8;
-	if (a_ptr->flags3 & TR3_HOLD_LIFE) p += 10;
-	if (a_ptr->flags2 & TR2_RES_ACID) p += 6;
-	if (a_ptr->flags2 & TR2_RES_ELEC) p += 6;
-	if (a_ptr->flags2 & TR2_RES_FIRE) p += 6;
-	if (a_ptr->flags2 & TR2_RES_COLD) p += 6;
-	if (a_ptr->flags2 & TR2_RES_POIS) p += 12;
-	if (a_ptr->flags2 & TR2_RES_LITE) p += 8;
-	if (a_ptr->flags2 & TR2_RES_DARK) p += 10;
-	if (a_ptr->flags2 & TR2_RES_BLIND) p += 10;
-	if (a_ptr->flags2 & TR2_RES_CONFU) p += 8;
-	if (a_ptr->flags2 & TR2_RES_SOUND) p += 10;
-	if (a_ptr->flags2 & TR2_RES_SHARD) p += 8;
-	if (a_ptr->flags2 & TR2_RES_NETHR) p += 12;
-	if (a_ptr->flags2 & TR2_RES_NEXUS) p += 10;
-	if (a_ptr->flags2 & TR2_RES_CHAOS) p += 12;
-	if (a_ptr->flags2 & TR2_RES_DISEN) p += 12;
-
-	if (a_ptr->flags3 & TR3_FEATHER) p += 2;
-	if (a_ptr->flags3 & TR3_LITE) p += 2;
-	if (a_ptr->flags3 & TR3_SEE_INVIS) p += 8;
-	if (a_ptr->flags3 & TR3_TELEPATHY) p += 20;
-	if (a_ptr->flags3 & TR3_SLOW_DIGEST) p += 4;
-	if (a_ptr->flags3 & TR3_REGEN) p += 8;
-	if (a_ptr->flags3 & TR3_TELEPORT) p -= 20;
-	if (a_ptr->flags3 & TR3_DRAIN_EXP) p -= 16;
-	if (a_ptr->flags3 & TR3_AGGRAVATE) p -= 8;
-	if (a_ptr->flags3 & TR3_BLESSED) p += 4;
-	if (a_ptr->flags3 & TR3_LIGHT_CURSE) p -= 4;
-	if (a_ptr->flags3 & TR3_HEAVY_CURSE) p -= 20;
+	if (immunities > 1) p += 20000;		/* inhibit */
+	if (x_ptr->flags3 & TR3_FREE_ACT) p += 10;
+	if (x_ptr->flags3 & TR3_HOLD_LIFE) p += 12;
+	if (x_ptr->flags2 & TR2_RES_ACID) p += 4;
+	if (x_ptr->flags2 & TR2_RES_ELEC) p += 4;
+	if (x_ptr->flags2 & TR2_RES_FIRE) p += 4;
+	if (x_ptr->flags2 & TR2_RES_COLD) p += 4;
+	if (x_ptr->flags2 & TR2_RES_POIS) p += 12;
+	if (x_ptr->flags2 & TR2_RES_LITE) p += 6;
+	if (x_ptr->flags2 & TR2_RES_DARK) p += 6;
+	if (x_ptr->flags2 & TR2_RES_BLIND) p += 8;
+	if (x_ptr->flags2 & TR2_RES_CONFU) p += 10;
+	if (x_ptr->flags2 & TR2_RES_SOUND) p += 8;
+	if (x_ptr->flags2 & TR2_RES_SHARD) p += 8;
+	if (x_ptr->flags2 & TR2_RES_NETHR) p += 12;
+	if (x_ptr->flags2 & TR2_RES_NEXUS) p += 10;
+	if (x_ptr->flags2 & TR2_RES_CHAOS) p += 12;
+	if (x_ptr->flags2 & TR2_RES_DISEN) p += 12;
+
+	if (x_ptr->flags3 & TR3_FEATHER) p += 1;
+	if (x_ptr->flags3 & TR3_LITE) p += 3;
+	if (x_ptr->flags3 & TR3_SEE_INVIS) p += 4;
+	if (x_ptr->flags3 & TR3_TELEPATHY) p += 12;
+	if (x_ptr->flags3 & TR3_SLOW_DIGEST) p += 2;
+	if (x_ptr->flags3 & TR3_REGEN) p += 6;
+	if (x_ptr->flags3 & TR3_TELEPORT) p -= 12;
+	if (x_ptr->flags3 & TR3_DRAIN_EXP) p -= 16;
+	if (x_ptr->flags3 & TR3_AGGRAVATE) p -= 8;
+	if (x_ptr->flags3 & TR3_BLESSED) p += 2;
+	if (x_ptr->flags3 & TR3_LIGHT_CURSE) p -= 4;
+	if (x_ptr->flags3 & TR3_HEAVY_CURSE) p -= 12;
 /*	if (a_ptr->flags3 & TR3_PERMA_CURSE) p -= 40; */
 
 	return p;
 }
 
-
-/*
- * Randomly select a base item type (tval,sval).  Assign the various fields
- * corresponding to that choice.
- */
-static void choose_item(int a_idx)
-{
-	artifact_type *a_ptr = &a_info[a_idx];
-	int tval, sval;
-	object_kind *k_ptr;
-	int r;
-	s16b k_idx, r2;
-	byte target_level;
-
-	/*
-	 * Look up the original artifact's base object kind to get level and
-	 * rarity information to supplement the artifact level/rarity.  As a
-	 * degenerate case consider Bladeturner, which has artifact lvl/rar
-	 * of only 95/3, but which is based on an object with 110/64!
-	 */
-	k_idx = lookup_kind(a_ptr->tval, a_ptr->sval);
-	k_ptr = &k_info[k_idx];
-	target_level = k_ptr->level;
-
-	/*
-	 * Add base object kind's rarity to artifact rarity.  Later we will
-	 * subtract the new object kind's rarity.
-	 */
-	a_ptr->rarity += k_ptr->chance[0];
-
-	/*
-	 * Pick a category (tval) of weapon randomly.  Within each tval, roll
-	 * an sval (specific item) based on the target level.  The number we
-	 * roll should be a bell curve.  The mean and standard variation of the
-	 * bell curve are based on the target level; the distribution of
-	 * kinds versus the bell curve is hand-tweaked. :-(
-	 */
-	r = rand_int(100);
-
-	if (r < 5)
-	{
-		/* Create a missile weapon. */
-		tval = TV_BOW;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 3) sval = SV_SLING;
-		else if (r2 < 10) sval = SV_SHORT_BOW;
-		else if (r2 < 30) sval = SV_LONG_BOW;
-		else if (r2 < 45) sval = SV_LIGHT_XBOW;
-		else sval = SV_HEAVY_XBOW;
-	}
-	else if (r < 9)
-	{
-		/* Create a digging tool. */
-		tval = TV_DIGGING;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 15) sval = SV_SHOVEL;
-		else if (r2 < 30) sval = SV_PICK;
-		else if (r2 < 60) sval = SV_GNOMISH_SHOVEL;
-		else if (r2 < 90) sval = SV_ORCISH_PICK;
-		else if (r2 < 120) sval = SV_DWARVEN_SHOVEL;
-		else sval = SV_DWARVEN_PICK;
-	}
-	else if (r < 19)
-	{
-		/* Create a "blunt" weapon. */
-		tval = TV_HAFTED;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 6) sval = SV_WHIP;
-		else if (r2 < 12) sval = SV_MACE;
-		else if (r2 < 20) sval = SV_WAR_HAMMER;
-		else if (r2 < 30) sval = SV_QUARTERSTAFF;
-		else if (r2 < 34) sval = SV_LUCERN_HAMMER;
-		else if (r2 < 38) sval = SV_MORNING_STAR;
-		else if (r2 < 45) sval = SV_FLAIL;
-		else if (r2 < 55) sval = SV_LEAD_FILLED_MACE;
-		else if (r2 < 80) sval = SV_BALL_AND_CHAIN;
-		else if (r2 < 120) sval = SV_TWO_HANDED_FLAIL;
-		else sval = SV_MACE_OF_DISRUPTION;
-	}
-	else if (r < 33)
-	{
-		/* Create a long, sharp-edged weapon. */
-		tval = TV_SWORD;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 0) sval = SV_BROKEN_DAGGER;
-		else if (r2 < 1) sval = SV_BROKEN_SWORD;
-		else if (r2 < 5) sval = SV_DAGGER;
-		else if (r2 < 9) sval = SV_MAIN_GAUCHE;
-		else if (r2 < 10) sval = SV_RAPIER;	/* or at least pointy ;-) */
-		else if (r2 < 12) sval = SV_SMALL_SWORD;
-		else if (r2 < 14) sval = SV_SHORT_SWORD;
-		else if (r2 < 16) sval = SV_SABRE;
-		else if (r2 < 18) sval = SV_CUTLASS;
-		else if (r2 < 20) sval = SV_TULWAR;
-		else if (r2 < 23) sval = SV_BROAD_SWORD;
-		else if (r2 < 26) sval = SV_LONG_SWORD;
-		else if (r2 < 30) sval = SV_SCIMITAR;
-		else if (r2 < 45) sval = SV_BASTARD_SWORD;
-		else if (r2 < 60) sval = SV_KATANA;
-		else if (r2 < 90) sval = SV_TWO_HANDED_SWORD;
-		else if (r2 < 120) sval = SV_EXECUTIONERS_SWORD;
-		else sval = SV_BLADE_OF_CHAOS;
-	}
-	else if (r < 42)
-	{
-		/* Create a weapon that's not blunt or sword-shaped. */
-		tval = TV_POLEARM;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 12) sval = SV_SPEAR;
-		else if (r2 < 20) sval = SV_TRIDENT;
-		else if (r2 < 27) sval = SV_LANCE;
-		else if (r2 < 35) sval = SV_AWL_PIKE;
-		else if (r2 < 45) sval = SV_PIKE;
-		else if (r2 < 50) sval = SV_BEAKED_AXE;
-		else if (r2 < 55) sval = SV_BROAD_AXE;
-		else if (r2 < 60) sval = SV_BATTLE_AXE;
-		else if (r2 < 65) sval = SV_GLAIVE;
-		else if (r2 < 80) sval = SV_HALBERD;
-		else if (r2 < 120) sval = SV_GREAT_AXE;
-		else if (r2 < 128) sval = SV_SCYTHE;
-		else if (r2 < 135) sval = SV_LOCHABER_AXE;
-		else sval = SV_SCYTHE_OF_SLICING;
-	}
-	else if (r < 64)
-	{
-		/* Create light or hard body armor. */
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 45) tval = TV_SOFT_ARMOR; else tval = TV_HARD_ARMOR;
-
-		/* Soft stuff. */
-		if (r2 < 0) sval = SV_FILTHY_RAG;
-		else if (r2 < 5) sval = SV_ROBE;
-		else if (r2 < 10) sval = SV_SOFT_LEATHER_ARMOR;
-		else if (r2 < 15) sval = SV_SOFT_STUDDED_LEATHER;
-		else if (r2 < 20) sval = SV_HARD_LEATHER_ARMOR;
-		else if (r2 < 30) sval = SV_HARD_STUDDED_LEATHER;
-		else if (r2 < 45) sval = SV_LEATHER_SCALE_MAIL;
-
-		/* Hard stuff. */
-		else if (r2 < 55) sval = SV_RUSTY_CHAIN_MAIL;
-		else if (r2 < 65) sval = SV_METAL_SCALE_MAIL;
-		else if (r2 < 75) sval = SV_CHAIN_MAIL;
-		else if (r2 < 85) sval = SV_AUGMENTED_CHAIN_MAIL;
-		else if (r2 < 90) sval = SV_DOUBLE_CHAIN_MAIL;
-		else if (r2 < 97) sval = SV_BAR_CHAIN_MAIL;
-		else if (r2 < 105) sval = SV_METAL_BRIGANDINE_ARMOUR;
-		else if (r2 < 115) sval = SV_PARTIAL_PLATE_ARMOUR;
-		else if (r2 < 125) sval = SV_METAL_LAMELLAR_ARMOUR;
-		else if (r2 < 135) sval = SV_FULL_PLATE_ARMOUR;
-		else if (r2 < 140) sval = SV_RIBBED_PLATE_ARMOUR;
-		else if (r2 < 150) sval = SV_MITHRIL_CHAIN_MAIL;
-		else if (r2 < 170) sval = SV_MITHRIL_PLATE_MAIL;
-		else sval = SV_ADAMANTITE_PLATE_MAIL;
-	}
-	else if (r < 71)
-	{
-		/* Make shoes. */
-		tval = TV_BOOTS;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 9) sval = SV_PAIR_OF_SOFT_LEATHER_BOOTS;
-		else if (r2 < 15) sval = SV_PAIR_OF_HARD_LEATHER_BOOTS;
-		else sval = SV_PAIR_OF_METAL_SHOD_BOOTS;
-	}
-	else if (r < 78)
-	{
-		/* Make gloves. */
-		tval = TV_GLOVES;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 10) sval = SV_SET_OF_LEATHER_GLOVES;
-		else if (r2 < 30) sval = SV_SET_OF_GAUNTLETS;
-		else sval = SV_SET_OF_CESTI;
-	}
-	else if (r < 87)
-	{
-		/* Make headgear. */
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 50) tval = TV_HELM; else tval = TV_CROWN;
-
-		if (r2 < 9) sval = SV_HARD_LEATHER_CAP;
-		else if (r2 < 20) sval = SV_METAL_CAP;
-		else if (r2 < 40) sval = SV_IRON_HELM;
-		else if (r2 < 50) sval = SV_STEEL_HELM;
-
-		else if (r2 < 60) sval = SV_IRON_CROWN;
-		else if (r2 < 90) sval = SV_GOLDEN_CROWN;
-		else sval = SV_JEWELED_CROWN;
-	}
-	else if (r < 94)
-	{
-		/* Make a shield. */
-		tval = TV_SHIELD;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 9) sval = SV_SMALL_LEATHER_SHIELD;
-		else if (r2 < 20) sval = SV_SMALL_METAL_SHIELD;
-		else if (r2 < 40) sval = SV_LARGE_LEATHER_SHIELD;
-		else if (r2 < 60) sval = SV_LARGE_METAL_SHIELD;
-		else sval = SV_SHIELD_OF_DEFLECTION;
-	}
-	else
-	{
-		/* Make a cloak. */
-		tval = TV_CLOAK;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 90) sval = SV_CLOAK;
-		else sval = SV_SHADOW_CLOAK;
-	}
-
-	k_idx = lookup_kind(tval, sval);
-	k_ptr = &k_info[k_idx];
-	kinds[a_idx] = k_idx;
-
-	/*
-	 * Subtract the new object kind's rarity (see above).  We can't
-	 * blindly subtract, because a_ptr->rarity is a byte.
-	 */
-	if (a_ptr->rarity <= k_ptr->chance[0])
-		a_ptr->rarity = 1;
-	else
-		a_ptr->rarity -= k_ptr->chance[0];
-
-	a_ptr->tval = k_ptr->tval;
-	a_ptr->sval = k_ptr->sval;
-	a_ptr->pval = k_ptr->pval;
-	a_ptr->to_h = k_ptr->to_h;
-	a_ptr->to_d = k_ptr->to_d;
-	a_ptr->to_a = k_ptr->to_a;
-	a_ptr->ac = k_ptr->ac;
-	a_ptr->dd = k_ptr->dd;
-	a_ptr->ds = k_ptr->ds;
-	a_ptr->weight = k_ptr->weight;
-	a_ptr->flags1 = k_ptr->flags1;
-	a_ptr->flags2 = k_ptr->flags2;
-	a_ptr->flags3 = k_ptr->flags3;
-
-	/* Artifacts ignore everything */
-	a_ptr->flags3 |= TR3_IGNORE_MASK;
-
-	/* Assign basic stats to the artifact based on its artifact level. */
-	switch (a_ptr->tval)
-	{
-		case TV_BOW: case TV_DIGGING: case TV_HAFTED:
-		case TV_SWORD: case TV_POLEARM:
-			a_ptr->to_h += (s16b)(a_ptr->level / 10 + rand_int(4) + rand_int(4));
-			a_ptr->to_d += (s16b)(a_ptr->level / 10 + rand_int(4) + rand_int((a_ptr->dd * a_ptr->ds) / 2 + 1));
-			break;
-		case TV_BOOTS: case TV_GLOVES: case TV_HELM: case TV_CROWN:
-		case TV_SHIELD: case TV_CLOAK: case TV_SOFT_ARMOR:
-		case TV_HARD_ARMOR:
-			a_ptr->to_a += (s16b)(a_ptr->level / 10 + a_ptr->ac / 3 + rand_int(8));
-			if (a_ptr->to_a < 10) a_ptr->to_a += (s16b)(2 + rand_int(4) + rand_int(4));
-			/*
-			 * Make sure armor gets some resists!  Hard body armor
-			 * is generally high-level stuff, with good ac and
-			 * to_a.  That sucks up all the points....
-			 */
-			switch (a_ptr->tval)
-			{
-			case TV_SOFT_ARMOR: case TV_HARD_ARMOR:
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_ACID;
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_ELEC;
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_COLD;
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_FIRE;
-				break;
-			}
-			break;
-	}
-}
-
-
 /*
  * We've just added an ability which uses the pval bonus.  Make sure it's
  * not zero.  If it's currently negative, leave it negative (heh heh).
  */
-static void do_pval(artifact_type *a_ptr)
+static void do_pval(object_type *o_ptr)
 {
-	if (a_ptr->pval == 0) a_ptr->pval = (s16b)(1 + rand_int(3));
-	else if (a_ptr->pval < 0)
+	if (o_ptr->pval == 0) o_ptr->pval = (s16b)(1 + rand_int(3));
+	else if (o_ptr->pval < 0)
 	{
-		if (rand_int(2) == 0) a_ptr->pval--;
+		if (rand_int(2) == 0) o_ptr->pval--;
 	}
-	else if (rand_int(3) > 0) a_ptr->pval++;
+	else if (rand_int(3) > 0) o_ptr->pval++;
 }
 
 
-static void remove_contradictory(artifact_type *a_ptr)
+static void remove_contradictory(object_type *o_ptr)
 {
-	if (a_ptr->flags3 & TR3_AGGRAVATE) a_ptr->flags1 &= ~(TR1_STEALTH);
-	if (a_ptr->flags2 & TR2_IM_ACID) a_ptr->flags2 &= ~(TR2_RES_ACID);
-	if (a_ptr->flags2 & TR2_IM_ELEC) a_ptr->flags2 &= ~(TR2_RES_ELEC);
-	if (a_ptr->flags2 & TR2_IM_FIRE) a_ptr->flags2 &= ~(TR2_RES_FIRE);
-	if (a_ptr->flags2 & TR2_IM_COLD) a_ptr->flags2 &= ~(TR2_RES_COLD);
-
-	if (a_ptr->pval < 0)
-	{
-		if (a_ptr->flags1 & TR1_STR) a_ptr->flags2 &= ~(TR2_SUST_STR);
-		if (a_ptr->flags1 & TR1_INT) a_ptr->flags2 &= ~(TR2_SUST_INT);
-		if (a_ptr->flags1 & TR1_WIS) a_ptr->flags2 &= ~(TR2_SUST_WIS);
-		if (a_ptr->flags1 & TR1_DEX) a_ptr->flags2 &= ~(TR2_SUST_DEX);
-		if (a_ptr->flags1 & TR1_CON) a_ptr->flags2 &= ~(TR2_SUST_CON);
-		if (a_ptr->flags1 & TR1_CHR) a_ptr->flags2 &= ~(TR2_SUST_CHR);
-		a_ptr->flags1 &= ~(TR1_BLOWS);
-	}
-
-	if (a_ptr->flags3 & TR3_LIGHT_CURSE) a_ptr->flags3 &= ~(TR3_BLESSED);
-	if (a_ptr->flags1 & TR1_KILL_DRAGON) a_ptr->flags1 &= ~(TR1_SLAY_DRAGON);
-	if (a_ptr->flags3 & TR3_DRAIN_EXP) a_ptr->flags3 &= ~(TR3_HOLD_LIFE);
+	randart_type *x_ptr = &x_info[o_ptr->name3];
+
+	if (x_ptr->flags3 & TR3_AGGRAVATE) x_ptr->flags1 &= ~(TR1_STEALTH);
+	if (x_ptr->flags2 & TR2_IM_ACID) x_ptr->flags2 &= ~(TR2_RES_ACID);
+	if (x_ptr->flags2 & TR2_IM_ELEC) x_ptr->flags2 &= ~(TR2_RES_ELEC);
+	if (x_ptr->flags2 & TR2_IM_FIRE) x_ptr->flags2 &= ~(TR2_RES_FIRE);
+	if (x_ptr->flags2 & TR2_IM_COLD) x_ptr->flags2 &= ~(TR2_RES_COLD);
+
+	if (o_ptr->pval < 0)
+	{
+		if (x_ptr->flags1 & TR1_STR) x_ptr->flags2 &= ~(TR2_SUST_STR);
+		if (x_ptr->flags1 & TR1_INT) x_ptr->flags2 &= ~(TR2_SUST_INT);
+		if (x_ptr->flags1 & TR1_WIS) x_ptr->flags2 &= ~(TR2_SUST_WIS);
+		if (x_ptr->flags1 & TR1_DEX) x_ptr->flags2 &= ~(TR2_SUST_DEX);
+		if (x_ptr->flags1 & TR1_CON) x_ptr->flags2 &= ~(TR2_SUST_CON);
+		if (x_ptr->flags1 & TR1_CHR) x_ptr->flags2 &= ~(TR2_SUST_CHR);
+		x_ptr->flags1 &= ~(TR1_BLOWS);
+		x_ptr->flags1 &= ~(TR1_SHOTS);
+		x_ptr->flags1 &= ~(TR1_INFRA);
+	}
+
+	if (x_ptr->flags3 & TR3_LIGHT_CURSE) x_ptr->flags3 &= ~(TR3_BLESSED);
+	if (x_ptr->flags1 & TR1_BRAND_NETHR) x_ptr->flags3 &= ~(TR3_BLESSED);
+	if (x_ptr->flags1 & TR1_KILL_DRAGON) x_ptr->flags1 &= ~(TR1_SLAY_DRAGON);
+	if (x_ptr->flags3 & TR3_DRAIN_EXP) x_ptr->flags3 &= ~(TR3_HOLD_LIFE);
+
+	if (o_ptr->tval == TV_SHOT || o_ptr->tval == TV_ARROW ||
+		o_ptr->tval == TV_BOLT)
+	{
+		x_ptr->flags1 &= ~(TR1_PVAL_MASK);
+		x_ptr->flags2 = 0;
+		x_ptr->flags3 &= (TR3_IGNORE_MASK | TR3_CURSED_MASK);
+	}
 }
 
 
 /*
  * Randomly select an extra ability to be added to the artifact in question.
  * XXX - This function is way too large.
  */
-static void add_ability(artifact_type *a_ptr)
+static void add_ability(object_type *o_ptr, int power)
 {
+	randart_type *x_ptr = &x_info[o_ptr->name3];
+
 	int r;
+	int p = power;
+
+	/* Boost power */
+	while (rand_int(2) == 0)
+		p += randint(10);
 
-	r = rand_int(10);
-	if (r < 5)		/* Pick something dependent on item type. */
+	/* Cap power */
+	if (p > 50) p = 50;
+
+	/*
+	 *  0-29: minor ability
+	 * 30-49: major ability
+	 * 50+  : major power
+	 */
+
+	r = rand_int(p);
+	if (rand_int(2) != 0)		/* Pick something dependent on item type. */
 	{
-		r = rand_int(100);
-		switch (a_ptr->tval)
+		switch (o_ptr->tval)
 		{
-			case TV_BOW:
+			case TV_BOLT:
+			case TV_ARROW:
+			case TV_SHOT:
 			{
-				if (r < 15)
+				if (r < 3)
+					o_ptr->to_h += randint(5) + randint(5);
+				else if (r < 6)
+					o_ptr->to_d += randint(5) + randint(5);
+				else if (r < 20)
 				{
-					a_ptr->flags1 |= TR1_SHOTS;
-					do_pval(a_ptr);
+					o_ptr->to_h += randint(5) + randint(5);
+					o_ptr->to_d += randint(5) + randint(5);
 				}
-				else if (r < 35)
+				if (r < 30)
+				{
+					switch (rand_int(8))
+					{
+					case 0:
+					case 1:
+					case 2:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_ORC;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_TROLL;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_GIANT;
+							break;
+						}
+					case 3:
+					case 4:
+					case 5:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_EVIL;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_UNDEAD;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_DEMON;
+							break;
+						}
+					case 6:
+						{
+							x_ptr->flags1 |= TR1_SLAY_ANIMAL;
+							break;
+						}
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_SLAY_DRAGON;
+							break;
+						}
+					}
+				}
+				else
 				{
-					a_ptr->flags1 |= TR1_MIGHT;
-					do_pval(a_ptr);
+					switch (rand_int(8))
+					{
+					case 0:
+						{
+							x_ptr->flags1 |= TR1_KILL_DRAGON;
+							break;
+						}
+					case 1:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ACID;
+							break;
+						}
+					case 2:
+					case 3:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ELEC;
+							break;
+						}
+					case 4:
+					case 5:
+						{
+							x_ptr->flags1 |= TR1_BRAND_FIRE;
+							break;
+						}
+					case 6:
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_BRAND_COLD;
+							break;
+						}
+					}
 				}
-				else if (r < 65) a_ptr->to_h += (s16b)(2 + rand_int(2));
-				else a_ptr->to_d += (s16b)(2 + rand_int(3));
 
 				break;
 			}
-			case TV_DIGGING:
-			case TV_HAFTED:
-			case TV_POLEARM:
-			case TV_SWORD:
+			case TV_BOW:
 			{
-				if (r < 4)
-				{
-					a_ptr->flags1 |= TR1_WIS;
-					do_pval(a_ptr);
-					if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_WIS;
-					if (a_ptr->tval == TV_SWORD || a_ptr->tval == TV_POLEARM)
-						a_ptr->flags3 |= TR3_BLESSED;
-				}
-				else if (r < 7)
-				{
-					a_ptr->flags1 |= TR1_BRAND_ACID;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_ACID;
-				}
+				if (r < 5)
+					o_ptr->to_h += randint(5) + randint(5);
 				else if (r < 10)
+					o_ptr->to_d += randint(5) + randint(5);
+				else if (r < 30)
 				{
-					a_ptr->flags1 |= TR1_BRAND_ELEC;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_ELEC;
+					o_ptr->to_h += randint(5) + randint(5);
+					o_ptr->to_d += randint(5) + randint(5);
 				}
-				else if (r < 15)
+				else if (r < 33)
 				{
-					a_ptr->flags1 |= TR1_BRAND_FIRE;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_FIRE;
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else if (r < 20)
+				else if (rand_int(2) == 0)
 				{
-					a_ptr->flags1 |= TR1_BRAND_COLD;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_COLD;
+					x_ptr->flags1 |= TR1_SHOTS;
+					do_pval(o_ptr);
 				}
-				else if (r < 28)
+				else
 				{
-					a_ptr->dd += (byte)(1 + rand_int(2) + rand_int(2));
-					if (a_ptr->dd > 9) a_ptr->dd = 9;
+					x_ptr->flags1 |= TR1_MIGHT;
+					do_pval(o_ptr);
 				}
-				else if (r < 31) a_ptr->flags1 |= TR1_KILL_DRAGON;
-				else if (r < 35) a_ptr->flags1 |= TR1_SLAY_DRAGON;
-				else if (r < 40) a_ptr->flags1 |= TR1_SLAY_EVIL;
 
-				else if (r < 45) a_ptr->flags1 |= TR1_SLAY_ANIMAL;
-				else if (r < 50)
-				{
-					a_ptr->flags1 |= TR1_SLAY_UNDEAD;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_DEMON;
-				}
-				else if (r < 54)
+				break;
+			}
+			case TV_DIGGING:
+			case TV_HAFTED:
+			case TV_POLEARM:
+			case TV_SWORD:
+			{
+				if (r < 3)
+					o_ptr->to_h += randint(5) + randint(5);
+				else if (r < 6)
+					o_ptr->to_d += randint(5) + randint(5);
+				else if (r < 18)
 				{
-					a_ptr->flags1 |= TR1_SLAY_DEMON;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_UNDEAD;
+					o_ptr->to_h += randint(5) + randint(5);
+					o_ptr->to_d += randint(5) + randint(5);
 				}
-				else if (r < 59)
+				else if (r < 20 && o_ptr->tval != TV_HAFTED)
+					x_ptr->flags3 |= TR3_BLESSED;
+				else if (r < 28)
 				{
-					a_ptr->flags1 |= TR1_SLAY_ORC;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_TROLL;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_GIANT;
+					switch (rand_int(8))
+					{
+					case 0:
+					case 1:
+					case 2:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_ORC;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_TROLL;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_GIANT;
+							break;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_STR;
+								do_pval(o_ptr);
+							}
+						}
+					case 3:
+					case 4:
+					case 5:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_EVIL;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_UNDEAD;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_DEMON;
+							if (o_ptr->tval != TV_HAFTED && rand_int(3) != 0)
+								x_ptr->flags3 |= TR3_BLESSED;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_WIS;
+								do_pval(o_ptr);
+							}
+							if (rand_int(5) == 0)
+								x_ptr->flags3 |= TR3_HOLD_LIFE;
+							break;
+						}
+					case 6:
+						{
+							x_ptr->flags1 |= TR1_SLAY_ANIMAL;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_INT;
+								do_pval(o_ptr);
+							}
+							if (rand_int(5) == 0)
+								x_ptr->flags3 |= TR3_REGEN;
+							break;
+						}
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_SLAY_DRAGON;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_CON;
+								do_pval(o_ptr);
+							}
+							break;
+						}
+					}
 				}
-				else if (r < 63)
+				else if (r < 30)
+					o_ptr->to_a += randint(5);
+				else if (r < 32)
+					o_ptr->dd++;
+				else if (r < 40)
 				{
-					a_ptr->flags1 |= TR1_SLAY_TROLL;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_ORC;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_GIANT;
+					switch (rand_int(8))
+					{
+					case 0:
+						{
+							x_ptr->flags1 |= TR1_KILL_DRAGON;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_CON;
+								do_pval(o_ptr);
+							}
+							break;
+						}
+					case 1:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ACID;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_ACID;
+							break;
+						}
+					case 2:
+					case 3:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ELEC;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_ELEC;
+							break;
+						}
+					case 4:
+					case 5:
+						{
+							x_ptr->flags1 |= TR1_BRAND_FIRE;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_FIRE;
+							break;
+						}
+					case 6:
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_BRAND_COLD;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_COLD;
+							break;
+						}
+					}
 				}
-				else if (r < 67)
+				else if (r < 42)
 				{
-					a_ptr->flags1 |= TR1_SLAY_GIANT;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_ORC;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_TROLL;
+					switch (rand_int(3))
+					{
+					case 0:
+						{
+							x_ptr->flags1 |= TR1_BRAND_NEXUS;
+							if (rand_int(p) >= 30)
+								x_ptr->flags2 |= TR2_RES_NEXUS;
+							break;
+						}
+					case 1:
+						{
+							x_ptr->flags1 |= TR1_BRAND_NETHR;
+							if (rand_int(p) >= 30)
+								x_ptr->flags2 |= TR2_RES_NETHR;
+							break;
+						}
+					case 2:
+						{
+							x_ptr->flags1 |= TR1_BRAND_CHAOS;
+							if (rand_int(p) >= 30)
+								x_ptr->flags2 |= TR2_RES_CHAOS;
+							break;
+						}
+					}
 				}
-				else if (r < 72) a_ptr->flags3 |= TR3_SEE_INVIS;
-				else if (r < 76)
+				else if (r < 44)
 				{
-					if (a_ptr->pval < 0) break;
-					a_ptr->flags1 |= TR1_BLOWS;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_STR;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_STR;
+				}
+				else if (r < 47)
+				{
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else if (r < 89)
+				else
 				{
-					a_ptr->to_d += (s16b)(3 + rand_int(4));
-					a_ptr->to_h += (s16b)(3 + rand_int(4));
+					x_ptr->flags1 |= TR1_CON;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_CON;
 				}
-				else if (r < 92) a_ptr->to_a += (s16b)(3 + rand_int(3));
-				else if (r < 98)
-					a_ptr->weight = (a_ptr->weight * 9) / 10;
-				else
-					if (a_ptr->tval != TV_DIGGING)
-					{
-						a_ptr->flags1 |= TR1_TUNNEL;
-						do_pval(a_ptr);
-					}
 
 				break;
 			}
 			case TV_BOOTS:
 			{
-				if (r < 10) a_ptr->flags3 |= TR3_FEATHER;
-				else if (r < 50) a_ptr->to_a += (s16b)(2 + rand_int(4));
-				else if (r < 80)
+				if (r < 6)
+					x_ptr->flags3 |= TR3_FEATHER;
+				else if (r < 25)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
 				{
-					a_ptr->flags1 |= TR1_STEALTH;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_STEALTH;
+					do_pval(o_ptr);
 				}
-				else if (r < 90)
+				else if (r < 35)
 				{
-					a_ptr->flags1 |= TR1_SPEED;
-					if (a_ptr->pval < 0) break;
-					if (a_ptr->pval == 0) a_ptr->pval = (s16b)(3 + rand_int(8));
-					else if (rand_int(2) == 0) a_ptr->pval++;
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else a_ptr->weight = (a_ptr->weight * 9) / 10;
+				else if (r < 45)
+					x_ptr->flags3 |= TR3_FREE_ACT;
+				else
+				{
+					x_ptr->flags1 |= TR1_SPEED;
+					do_pval(o_ptr);
+					/* Supercharge! */
+					while (o_ptr->pval > 0 && rand_int(3) == 0)
+						o_ptr->pval++;
+				}
+
 				break;
 			}
 			case TV_GLOVES:
 			{
-				if (r < 25) a_ptr->flags3 |= TR3_FREE_ACT;
-				else if (r < 50)
-				{
-					a_ptr->flags1 |= TR1_DEX;
-					do_pval(a_ptr);
+				if (r < 25)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					o_ptr->to_h += rand_int(6);
+					o_ptr->to_d += rand_int(6);
+				}
+				else if (r < 40)
+				{
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else if (r < 75) a_ptr->to_a += (s16b)(3 + rand_int(3));
 				else
-				{
-					a_ptr->to_h += (s16b)(2 + rand_int(3));
-					a_ptr->to_d += (s16b)(2 + rand_int(3));
-					a_ptr->flags3 |= TR3_SHOW_MODS;
-				}
+					x_ptr->flags3 |= TR3_FREE_ACT;
+
 				break;
 			}
 			case TV_HELM:
 			case TV_CROWN:
 			{
-				if (r < 20) a_ptr->flags2 |= TR2_RES_BLIND;
-				else if (r < 45) a_ptr->flags3 |= TR3_TELEPATHY;
-				else if (r < 65) a_ptr->flags3 |= TR3_SEE_INVIS;
-				else if (r < 75)
+				if (r < 13)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 15)
+					x_ptr->flags1 |= TR3_LITE;
+				else if (r < 19)
 				{
-					a_ptr->flags1 |= TR1_WIS;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_INFRA;
+					do_pval(o_ptr);
 				}
-				else if (r < 85)
+				else if (r < 22)
 				{
-					a_ptr->flags1 |= TR1_INT;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_SEARCH;
+					do_pval(o_ptr);
 				}
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+				else if (r < 26)
+					x_ptr->flags3 |= TR3_SEE_INVIS;
+				else if (r < 30)
+				{
+					x_ptr->flags1 |= TR1_CHR;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_CHR;
+				}
+				else if (r < 37)
+				{
+					x_ptr->flags1 |= TR1_INT;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_INT;
+				}
+				else if (r < 44)
+				{
+					x_ptr->flags1 |= TR1_WIS;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_WIS;
+				}
+				else
+					x_ptr->flags3 |= TR3_TELEPATHY;
+
 				break;
 			}
 			case TV_SHIELD:
 			{
-				if (r < 20) a_ptr->flags2 |= TR2_RES_ACID;
-				else if (r < 40) a_ptr->flags2 |= TR2_RES_ELEC;
-				else if (r < 60) a_ptr->flags2 |= TR2_RES_FIRE;
-				else if (r < 80) a_ptr->flags2 |= TR2_RES_COLD;
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+				if (r < 20)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ACID;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ELEC;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_FIRE;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_COLD;
+				}
+				else if (r < 34)
+				{
+					x_ptr->flags2 |= TR2_RES_ACID;
+					x_ptr->flags2 |= TR2_RES_ELEC;
+					x_ptr->flags2 |= TR2_RES_FIRE;
+					x_ptr->flags2 |= TR2_RES_COLD;
+				}
+				else if (r < 47)
+				{
+					switch (rand_int(11))
+					{
+					case 0:  x_ptr->flags2 |= TR2_RES_POIS; break;
+					case 1:  x_ptr->flags2 |= TR2_RES_LITE; break;
+					case 2:  x_ptr->flags2 |= TR2_RES_DARK; break;
+					case 3:  x_ptr->flags2 |= TR2_RES_BLIND; break;
+					case 4:  x_ptr->flags2 |= TR2_RES_CONFU; break;
+					case 5:  x_ptr->flags2 |= TR2_RES_SOUND; break;
+					case 6:  x_ptr->flags2 |= TR2_RES_SHARD; break;
+					case 7:  x_ptr->flags2 |= TR2_RES_NETHR; break;
+					case 8:  x_ptr->flags2 |= TR2_RES_NEXUS; break;
+					case 9:  x_ptr->flags2 |= TR2_RES_CHAOS; break;
+					case 10: x_ptr->flags2 |= TR2_RES_DISEN; break;
+					}
+				}
+				else
+					x_ptr->flags3 |= TR3_HOLD_LIFE;
+
 				break;
 			}
 			case TV_CLOAK:
 			{
-				if (r < 50)
-				{
-					a_ptr->flags1 |= TR1_STEALTH;
-					do_pval(a_ptr);
+				if (r < 20)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					x_ptr->flags1 |= TR1_STEALTH;
+					do_pval(o_ptr);
+				}
+				else if (r < 44)
+				{
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ACID;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ELEC;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_FIRE;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_COLD;
 				}
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+				else if (r < 47)
+					x_ptr->flags3 |= TR3_FREE_ACT;
+				else
+					x_ptr->flags3 |= TR3_HOLD_LIFE;
+
 				break;
 			}
+			case TV_DRAG_ARMOR:
 			case TV_SOFT_ARMOR:
 			case TV_HARD_ARMOR:
 			{
-				if (r < 8)
-				{
-					a_ptr->flags1 |= TR1_STEALTH;
-					do_pval(a_ptr);
+				if (r < 25)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ACID;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ELEC;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_FIRE;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_COLD;
+				}
+				else if (r < 34)
+				{
+					x_ptr->flags2 |= TR2_RES_ACID;
+					x_ptr->flags2 |= TR2_RES_ELEC;
+					x_ptr->flags2 |= TR2_RES_FIRE;
+					x_ptr->flags2 |= TR2_RES_COLD;
 				}
-				else if (r < 16) a_ptr->flags3 |= TR3_HOLD_LIFE;
-				else if (r < 22)
+				else if (r < 47)
 				{
-					a_ptr->flags1 |= TR1_CON;
-					do_pval(a_ptr);
-					if (rand_int(2) == 0)
-						a_ptr->flags2 |= TR2_SUST_CON;
-				}
-				else if (r < 34) a_ptr->flags2 |= TR2_RES_ACID;
-				else if (r < 46) a_ptr->flags2 |= TR2_RES_ELEC;
-				else if (r < 58) a_ptr->flags2 |= TR2_RES_FIRE;
-				else if (r < 70) a_ptr->flags2 |= TR2_RES_COLD;
-				else if (r < 80)
-					a_ptr->weight = (a_ptr->weight * 9) / 10;
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+					switch (rand_int(11))
+					{
+					case 0:  x_ptr->flags2 |= TR2_RES_POIS; break;
+					case 1:  x_ptr->flags2 |= TR2_RES_LITE; break;
+					case 2:  x_ptr->flags2 |= TR2_RES_DARK; break;
+					case 3:  x_ptr->flags2 |= TR2_RES_BLIND; break;
+					case 4:  x_ptr->flags2 |= TR2_RES_CONFU; break;
+					case 5:  x_ptr->flags2 |= TR2_RES_SOUND; break;
+					case 6:  x_ptr->flags2 |= TR2_RES_SHARD; break;
+					case 7:  x_ptr->flags2 |= TR2_RES_NETHR; break;
+					case 8:  x_ptr->flags2 |= TR2_RES_NEXUS; break;
+					case 9:  x_ptr->flags2 |= TR2_RES_CHAOS; break;
+					case 10: x_ptr->flags2 |= TR2_RES_DISEN; break;
+					}
+				}
+				else
+					x_ptr->flags3 |= TR3_HOLD_LIFE;
+
 				break;
 			}
 		}
 	}
 	else			/* Pick something universally useful. */
 	{
-		r = rand_int(43);
-		switch (r)
-		{
-			case 0:
-				a_ptr->flags1 |= TR1_STR;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_STR;
-				break;
-			case 1:
-				a_ptr->flags1 |= TR1_INT;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_INT;
-				break;
-			case 2:
-				a_ptr->flags1 |= TR1_WIS;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_WIS;
-				if (a_ptr->tval == TV_SWORD || a_ptr->tval == TV_POLEARM)
-					a_ptr->flags3 |= TR3_BLESSED;
-				break;
-			case 3:
-				a_ptr->flags1 |= TR1_DEX;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_DEX;
-				break;
-			case 4:
-				a_ptr->flags1 |= TR1_CON;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_CON;
-				break;
-			case 5:
-				a_ptr->flags1 |= TR1_CHR;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_CHR;
-				break;
+		r = rand_int(power);
 
-			case 6:
-				a_ptr->flags1 |= TR1_STEALTH;
-				do_pval(a_ptr);
-				break;
-			case 7:
-				a_ptr->flags1 |= TR1_SEARCH;
-				do_pval(a_ptr);
-				break;
-			case 8:
-				a_ptr->flags1 |= TR1_INFRA;
-				do_pval(a_ptr);
-				break;
-			case 9:
-				a_ptr->flags1 |= TR1_SPEED;
-				if (a_ptr->pval == 0) a_ptr->pval = (s16b)(3 + rand_int(3));
-				else do_pval(a_ptr);
-				break;
-
-			case 10:
-				a_ptr->flags2 |= TR2_SUST_STR;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_STR;
-					do_pval(a_ptr);
-				}
-				break;
-			case 11:
-				a_ptr->flags2 |= TR2_SUST_INT;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_INT;
-					do_pval(a_ptr);
-				}
-				break;
-			case 12:
-				a_ptr->flags2 |= TR2_SUST_WIS;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_WIS;
-					do_pval(a_ptr);
-					if (a_ptr->tval == TV_SWORD || a_ptr->tval == TV_POLEARM)
-						a_ptr->flags3 |= TR3_BLESSED;
-				}
-				break;
-			case 13:
-				a_ptr->flags2 |= TR2_SUST_DEX;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_DEX;
-					do_pval(a_ptr);
-				}
-				break;
-			case 14:
-				a_ptr->flags2 |= TR2_SUST_CON;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_CON;
-					do_pval(a_ptr);
-				}
-				break;
-			case 15:
-				a_ptr->flags2 |= TR2_SUST_CHR;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_CHR;
-					do_pval(a_ptr);
-				}
-				break;
-
-			case 16:
+		if (r < 2)
+			x_ptr->flags3 |= TR3_LITE;
+		else if (r < 4)
+			x_ptr->flags3 |= TR3_FEATHER;
+		else if (r < 7)
+			x_ptr->flags3 |= TR3_SLOW_DIGEST;
+		else if (r < 10)
+			x_ptr->flags3 |= TR3_SEE_INVIS;
+		else if (r < 12)
+		{
+			switch (rand_int(6))
 			{
-				if (rand_int(3) == 0) a_ptr->flags2 |= TR2_IM_ACID;
-				break;
+			case 0: x_ptr->flags2 |= TR2_SUST_STR; break;
+			case 1: x_ptr->flags2 |= TR2_SUST_INT; break;
+			case 2: x_ptr->flags2 |= TR2_SUST_WIS; break;
+			case 3: x_ptr->flags2 |= TR2_SUST_DEX; break;
+			case 4: x_ptr->flags2 |= TR2_SUST_CON; break;
+			case 5: x_ptr->flags2 |= TR2_SUST_CHR; break;
 			}
-			case 17:
+		}
+		else if (r < 13)
+		{
+			x_ptr->flags1 |= TR1_INFRA;
+			do_pval(o_ptr);
+		}
+		else if (r < 14)
+		{
+			x_ptr->flags1 |= TR1_SEARCH;
+			do_pval(o_ptr);
+		}
+		else if (r < 15)
+		{
+			x_ptr->flags1 |= TR1_STEALTH;
+			do_pval(o_ptr);
+		}
+		else if (r < 19)
+		{
+			switch (rand_int(4))
 			{
-				if (rand_int(3) == 0) a_ptr->flags2 |= TR2_IM_ELEC;
-				break;
+			case 0: x_ptr->flags2 |= TR2_RES_ACID; break;
+			case 1: x_ptr->flags2 |= TR2_RES_ELEC; break;
+			case 2: x_ptr->flags2 |= TR2_RES_FIRE; break;
+			case 3: x_ptr->flags2 |= TR2_RES_COLD; break;
 			}
-			case 18:
+		}
+		else if (r < 21)
+		{
+			x_ptr->flags1 |= TR1_CHR;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_CHR;
+		}
+		else if (r < 23)
+		{
+			x_ptr->flags1 |= TR1_DEX;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_DEX;
+		}
+		else if (r < 25)
+		{
+			x_ptr->flags1 |= TR1_INT;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_INT;
+		}
+		else if (r < 27)
+		{
+			x_ptr->flags1 |= TR1_WIS;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_WIS;
+		}
+		else if (r < 29)
+		{
+			x_ptr->flags1 |= TR1_CON;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_CON;
+		}
+		else if (r < 31)
+		{
+			x_ptr->flags1 |= TR1_STR;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_STR;
+		}
+		else if (r < 33)
+			x_ptr->flags3 |= TR3_REGEN;
+		else if (r < 34)
+			x_ptr->flags3 |= TR3_TELEPATHY;
+		else if (r < 38)
+		{
+			switch (rand_int(11))
 			{
-				if (rand_int(4) == 0) a_ptr->flags2 |= TR2_IM_FIRE;
-				break;
+			case 0:  x_ptr->flags2 |= TR2_RES_POIS; break;
+			case 1:  x_ptr->flags2 |= TR2_RES_LITE; break;
+			case 2:  x_ptr->flags2 |= TR2_RES_DARK; break;
+			case 3:  x_ptr->flags2 |= TR2_RES_BLIND; break;
+			case 4:  x_ptr->flags2 |= TR2_RES_CONFU; break;
+			case 5:  x_ptr->flags2 |= TR2_RES_SOUND; break;
+			case 6:  x_ptr->flags2 |= TR2_RES_SHARD; break;
+			case 7:  x_ptr->flags2 |= TR2_RES_NETHR; break;
+			case 8:  x_ptr->flags2 |= TR2_RES_NEXUS; break;
+			case 9:  x_ptr->flags2 |= TR2_RES_CHAOS; break;
+			case 10: x_ptr->flags2 |= TR2_RES_DISEN; break;
 			}
-			case 19:
+		}
+		else if (r < 41)
+			x_ptr->flags3 |= TR3_FREE_ACT;
+		else if (r < 44)
+			x_ptr->flags3 |= TR3_HOLD_LIFE;
+		else if (r < 48)
+		{
+			x_ptr->flags1 |= TR1_SPEED;
+			do_pval(o_ptr);
+			/* Supercharge! */
+			while (o_ptr->pval > 0 && rand_int(3) == 0)
+				o_ptr->pval++;
+		}
+		else
+		{
+			switch (rand_int(4))
 			{
-				if (rand_int(3) == 0) a_ptr->flags2 |= TR2_IM_COLD;
-				break;
+			case 0: x_ptr->flags2 |= TR2_IM_ACID; break;
+			case 1: x_ptr->flags2 |= TR2_IM_ELEC; break;
+			case 2: x_ptr->flags2 |= TR2_IM_FIRE; break;
+			case 3: x_ptr->flags2 |= TR2_IM_COLD; break;
 			}
-			case 20: a_ptr->flags3 |= TR3_FREE_ACT; break;
-			case 21: a_ptr->flags3 |= TR3_HOLD_LIFE; break;
-			case 22: a_ptr->flags2 |= TR2_RES_ACID; break;
-			case 23: a_ptr->flags2 |= TR2_RES_ELEC; break;
-			case 24: a_ptr->flags2 |= TR2_RES_FIRE; break;
-			case 25: a_ptr->flags2 |= TR2_RES_COLD; break;
-
-			case 26: a_ptr->flags2 |= TR2_RES_POIS; break;
-			case 27: a_ptr->flags2 |= TR2_RES_LITE; break;
-			case 28: a_ptr->flags2 |= TR2_RES_DARK; break;
-			case 29: a_ptr->flags2 |= TR2_RES_BLIND; break;
-			case 30: a_ptr->flags2 |= TR2_RES_CONFU; break;
-			case 31: a_ptr->flags2 |= TR2_RES_SOUND; break;
-			case 32: a_ptr->flags2 |= TR2_RES_SHARD; break;
-			case 33:
-				if (rand_int(2) == 0)
-					a_ptr->flags2 |= TR2_RES_NETHR;
-				break;
-			case 34: a_ptr->flags2 |= TR2_RES_NEXUS; break;
-			case 35: a_ptr->flags2 |= TR2_RES_CHAOS; break;
-			case 36:
-				if (rand_int(2) == 0)
-					a_ptr->flags2 |= TR2_RES_DISEN;
-				break;
-			case 37: a_ptr->flags3 |= TR3_FEATHER; break;
-			case 38: a_ptr->flags3 |= TR3_LITE; break;
-			case 39: a_ptr->flags3 |= TR3_SEE_INVIS; break;
-			case 40:
-				if (rand_int(3) == 0)
-					a_ptr->flags3 |= TR3_TELEPATHY;
-				break;
-			case 41: a_ptr->flags3 |= TR3_SLOW_DIGEST; break;
-
-			case 42:
-				a_ptr->flags3 |= TR3_REGEN; break;
 		}
 	}
 
 	/* Now remove contradictory or redundant powers. */
-	remove_contradictory(a_ptr);
+	remove_contradictory(o_ptr);
 }
 
 
 /*
  * Make it bad, or if it's already bad, make it worse!
  */
-static void do_curse(artifact_type *a_ptr)
+static void do_curse(object_type *o_ptr)
 {
+	randart_type *x_ptr = &x_info[o_ptr->name3];
+
 	if (rand_int(3) == 0)
-		a_ptr->flags3 |= TR3_AGGRAVATE;
+		x_ptr->flags3 |= TR3_AGGRAVATE;
 	if (rand_int(5) == 0)
-		a_ptr->flags3 |= TR3_DRAIN_EXP;
+		x_ptr->flags3 |= TR3_DRAIN_EXP;
 	if (rand_int(7) == 0)
-		a_ptr->flags3 |= TR3_TELEPORT;
+		x_ptr->flags3 |= TR3_TELEPORT;
 
-	if ((a_ptr->pval > 0) && (rand_int(2) == 0))
-		a_ptr->pval = -a_ptr->pval;
-	if ((a_ptr->to_a > 0) && (rand_int(2) == 0))
-		a_ptr->to_a = -a_ptr->to_a;
-	if ((a_ptr->to_h > 0) && (rand_int(2) == 0))
-		a_ptr->to_h = -a_ptr->to_h;
-	if ((a_ptr->to_d > 0) && (rand_int(4) == 0))
-		a_ptr->to_d = -a_ptr->to_d;
+	if ((o_ptr->pval > 0) && (rand_int(2) == 0))
+		o_ptr->pval = -o_ptr->pval;
+	if ((o_ptr->to_a > 0) && (rand_int(2) == 0))
+		o_ptr->to_a = -o_ptr->to_a;
+	if ((o_ptr->to_h > 0) && (rand_int(2) == 0))
+		o_ptr->to_h = -o_ptr->to_h;
+	if ((o_ptr->to_d > 0) && (rand_int(4) == 0))
+		o_ptr->to_d = -o_ptr->to_d;
 
-	if (a_ptr->flags3 & TR3_LIGHT_CURSE)
+	if (x_ptr->flags3 & TR3_LIGHT_CURSE)
 	{
-		if (rand_int(2) == 0) a_ptr->flags3 |= TR3_HEAVY_CURSE;
+		if (rand_int(2) == 0) x_ptr->flags3 |= TR3_HEAVY_CURSE;
 		return;
 	}
 
-	a_ptr->flags3 |= TR3_LIGHT_CURSE;
-	if (rand_int(4) == 0) a_ptr->flags3 |= TR3_HEAVY_CURSE;
+	x_ptr->flags3 |= TR3_LIGHT_CURSE;
+	if (rand_int(4) == 0) x_ptr->flags3 |= TR3_HEAVY_CURSE;
 }
 
 
-/*
- * Note the three special cases (One Ring, Grond, Morgoth).
- */
-static int scramble_artifact(int a_idx)
+static byte activation_table[60] = {
+	ACT_ILLUMINATION,
+	ACT_MISSILE,
+	ACT_PHASE,
+	ACT_CURE_WOUNDS,
+	ACT_FIRE1,
+	ACT_STINKING_CLOUD,
+	ACT_FROST1,
+	ACT_ILLUMINATION,
+	ACT_MISSILE,
+	ACT_CURE_WOUNDS,
+	ACT_TRAP_DOOR_DEST,
+	ACT_SLEEP,
+	ACT_STONE_TO_MUD,
+	ACT_FIRE1,
+	ACT_ILLUMINATION,
+	ACT_STINKING_CLOUD,
+	ACT_PHASE,
+	ACT_MISSILE,
+	ACT_FROST2,
+	ACT_ACID1,
+	ACT_PROBE,
+	ACT_REM_FEAR_POIS,
+	ACT_CONFUSE,
+	ACT_MAGIC_MAP,
+	ACT_TELEPORT,
+	ACT_MAGIC_MAP,
+	ACT_HEAL1,
+	ACT_HASTE1,
+	ACT_DETECT,
+	ACT_IDENTIFY,
+	ACT_RESIST,
+	ACT_FIRE2,
+	ACT_FROST3,
+	ACT_TELEPORT,
+	ACT_FROST4,
+	ACT_ELEC2,
+	ACT_FIRE3,
+	ACT_TELEPORT,
+	ACT_IDENTIFY,
+	ACT_RECHARGE1,
+	ACT_DRAIN_LIFE1,
+	ACT_PROT_EVIL,
+	ACT_LIGHTNING_BOLT,
+	ACT_DETECT,
+	ACT_RESIST,
+	ACT_TELE_AWAY,
+	ACT_ARROW,
+	ACT_WOR,
+	ACT_HASTE2,
+	ACT_HEAL2,
+	ACT_RAGE_BLESS_RESIST,
+	ACT_FROST5,
+	ACT_DISP_EVIL,
+	ACT_WOR,
+	ACT_FIREBRAND,
+	ACT_DRAIN_LIFE2,
+	ACT_STAR_BALL,
+	ACT_RESTORE_LIFE,
+	ACT_GENOCIDE,
+	ACT_MASS_GENOCIDE,
+};
+
+
+bool make_randart_stupid(object_type *o_ptr)
+{
+	int i;
+	int x_idx = 0;
+	randart_type *x_ptr;
+
+	for (i = 1; i < z_info->x_max; i++)
+	{
+		if (x_info[i].name[0]) continue;
+		x_idx = i;
+		break;
+	}
+
+	if (!x_idx) return (FALSE);
+
+	o_ptr->name3 = x_idx;
+
+	x_ptr = &x_info[x_idx];
+
+	x_ptr->flags1 = 0;
+	x_ptr->flags2 = 0;
+	x_ptr->flags3 = 0;
+
+	name_randart(x_ptr);
+
+	for (i = 0; i < 4; i++)
+		add_ability(o_ptr, 30);
+	for (i = 0; i < 2; i++)
+		add_ability(o_ptr, 50);
+
+	/*
+	 * Add TR3_HIDE_TYPE to all artifacts with nonzero pval because we're
+	 * too lazy to find out which ones need it and which ones don't.
+	 */
+	if (o_ptr->pval)
+		x_ptr->flags3 |= TR3_HIDE_TYPE;
+
+	return TRUE;
+
+}
+
+
+
+bool make_randart(object_type *o_ptr, bool curse)
 {
-	artifact_type *a_ptr = &a_info[a_idx];
-	u32b activates = a_ptr->flags3 & TR3_ACTIVATE;
+	randart_type *x_ptr;
+	object_kind *k_ptr = &k_info[o_ptr->k_idx];
+	int x_idx = 0;
 	s32b power;
 	int tries;
 	s32b ap;
-	bool curse_me = FALSE;
 	bool aggravate_me = FALSE;
+	int i;
+	u32b f1, f2, f3;
 
-	/* Special cases -- don't randomize these! */
-	if ((a_idx == ART_POWER) ||
-	    (a_idx == ART_GROND) ||
-	    (a_idx == ART_MORGOTH))
-		return 0;
-
-	/* Skip unused artifacts, too! */
-	if (a_ptr->tval == 0) return 0;
-
-	/* Evaluate the original artifact to determine the power level. */
-	power = artifact_power(a_idx, TRUE);
-	if (power < 0) curse_me = TRUE;
-
-	if (randart_verbose)
-		msg_format("Artifact %d: power = %d", a_idx, power);
-
-	/* Really powerful items should aggravate. */
-	if (power > 100)
+	/* Find a free index */
+	for (i = 1; i < z_info->x_max; i++)
 	{
-		if (rand_int(100) < (power - 100) * 3)
-			aggravate_me = TRUE;
+		if (x_info[i].name[0]) continue;
+		x_idx = i;
+		break;
 	}
+	if (!x_idx) return (FALSE);
+
+	/* Get the object's current flags */
+	object_flags(o_ptr, &f1, &f2, &f3);
+
+	/* Get the artifact */
+	x_ptr = &x_info[x_idx];
+
+	/* Clear the artifact */	
+	x_ptr->cost = k_ptr->cost;
+	x_ptr->flags1 = f1;
+	x_ptr->flags2 = f2;
+	x_ptr->flags3 = f3 & ~(TR3_ACTIVATE);
+	x_ptr->level = (p_ptr->depth + k_ptr->level) / 2;
+	x_ptr->activation = 0;
+	x_ptr->time = 0;
+	x_ptr->randtime = 0;
+
+	/* Name it */
+	name_randart(x_ptr);
+
+	/* Assign the artifact index */
+	o_ptr->name3 = x_idx;
+
+	/* Sometimes artifacts are deeper */
+	while (rand_int((x_ptr->level - (p_ptr->depth + k_ptr->level) / 2) * 4) == 0)
+		x_ptr->level++;
+
+	/* Get current power */
+	ap = artifact_power(o_ptr);
+
+	/* Find a power */
+	power = (ap + 30) / 2 + randint(x_ptr->level + 10);
 
-	if (a_idx >= ART_MIN_NORMAL)
+	/* Reduce powerful items */
+	if (power > ap + 30)
+		power = ap + 30 + randint(power - ap - 30);
+
+	/* Always add something */
+	if (power < ap + 10) power = ap + 10;
+
+	/* Find a power based on level and rarity */
+	if (curse)
+		power = -power;
+
+	/* Sometimes add an activation */
+	if (rand_int(200) < power)
 	{
-		/*
-		 * Normal artifact - choose a random base item type.  Not too
-		 * powerful, so we'll have to add something to it.  Not too
-		 * weak, for the opposite reason.
-		 */
-		int count = 0;
-		s32b ap2;
+		int m = x_ptr->level / 2 + 20;
+		if (m > 60)
+			m = 60;
 
-		do
+		x_ptr->flags3 |= TR3_ACTIVATE;
+		x_ptr->activation = activation_table[rand_int(m)];
+
+		/* Default values */
+		x_ptr->time = x_ptr->randtime = 2 + x_ptr->level * x_ptr->level / 4;
+
+		/* Find a real artifact with the right activation */
+		for (i = 0; i < ART_MIN_RANDART; i++)
 		{
-			choose_item(a_idx);
-			ap2 = artifact_power(a_idx, FALSE);
-			count++;
-		} while ((count < MAX_TRIES) &&
-			   ((ap2 > (power * 8) / 10 + 1) ||
-			    (ap2 < (power / 10))));
+			if (a_info[i].tval == 0) continue;
+			if (!(a_info[i].flags3 & TR3_ACTIVATE)) continue;
+			if (a_info[i].activation != x_ptr->activation) continue;
+
+			/* Base on that timeout */
+			x_ptr->time = a_info[i].time * a_info[i].level / x_ptr->level;
+			x_ptr->randtime = a_info[i].randtime * a_info[i].level / x_ptr->level;
+
+			/* Not too much worse */
+			if (x_ptr->time > a_info[i].time * 2) x_ptr->time = a_info[i].time * 2;
+			if (x_ptr->randtime > a_info[i].randtime * 2) x_ptr->randtime = a_info[i].randtime * 2;
+
+			break;
+		}
+
+		/* Ensure sanity */
+		if (x_ptr->time < 2) x_ptr->time = 2;
+		if (x_ptr->randtime < 0) x_ptr->randtime = 0;
 	}
-	else
-	{
-		/* Special artifact (light source, ring, or
-		   amulet).  Clear the following fields; leave
-		   the rest alone. */
-		a_ptr->pval = 0;
-		a_ptr->to_h = a_ptr->to_d = a_ptr->to_a = 0;
-		a_ptr->flags1 = a_ptr->flags2 = 0;
 
-		/* Artifacts ignore everything */
-		a_ptr->flags3 = (TR3_IGNORE_MASK);
+	/* Really powerful items should aggravate. */
+	if (power > 60)
+	{
+		if (rand_int(60) < (power - 60))
+			aggravate_me = TRUE;
 	}
 
 	/* First draft: add two abilities, then curse it three times. */
-	if (curse_me)
+	if (curse)
 	{
-		add_ability(a_ptr);
-		add_ability(a_ptr);
-		do_curse(a_ptr);
-		do_curse(a_ptr);
-		do_curse(a_ptr);
-		remove_contradictory(a_ptr);
-		ap = artifact_power(a_idx, FALSE);
+		add_ability(o_ptr, 20);
+		add_ability(o_ptr, 20);
+		do_curse(o_ptr);
+		do_curse(o_ptr);
+		do_curse(o_ptr);
+		remove_contradictory(o_ptr);
+		ap = artifact_power(o_ptr);
 	}
 	else
 	{
 		/*
@@ -1921,18 +2053,21 @@
 		 * original's in terms of overall power/usefulness.
 		 */
 		for (tries = 0; tries < MAX_TRIES; tries++)
 		{
-			artifact_type a_old;
+			object_type o_old;
+			randart_type x_old;
 
 			/* Copy artifact info temporarily. */
-			a_old = *a_ptr;
-			add_ability(a_ptr);
-			ap = artifact_power(a_idx, FALSE);
+			o_old = *o_ptr;
+			x_old = *x_ptr;
+			add_ability(o_ptr, 20 + randint(power * 2 / 3));
+			ap = artifact_power(o_ptr);
 			if (ap > (power * 11) / 10 + 1)
 			{
 				/* too powerful -- put it back */
-				*a_ptr = a_old;
+				*o_ptr = o_old;
+				*x_ptr = x_old;
 				continue;
 			}
 
 			else if (ap >= (power * 9) / 10)	/* just right */
@@ -1941,171 +2076,32 @@
 			}
 
 			/* Stop if we're going negative, so we don't overload
 			   the artifact with great powers to compensate. */
-			else if ((ap < 0) && (ap < (-(power * 1)) / 10))
+			else if ((ap < 0) && (ap < (-(power * 5)) / 10))
 			{
 				break;
 			}
 		}		/* end of power selection */
 
 		if (aggravate_me)
 		{
-			a_ptr->flags3 |= TR3_AGGRAVATE;
-			remove_contradictory(a_ptr);
-			ap = artifact_power(a_idx, FALSE);
+			x_ptr->flags3 |= TR3_AGGRAVATE;
+			remove_contradictory(o_ptr);
+			ap = artifact_power(o_ptr);
 		}
 	}
 
-	a_ptr->cost = ap * (s32b)1000;
+	x_ptr->cost = ap * (s32b)(400 + 100 * randint(6));
 
-	if (a_ptr->cost < 0) a_ptr->cost = 0;
-
-#if 0
-	/* One last hack: if the artifact is very powerful, raise the rarity.
-	   This compensates for artifacts like (original) Bladeturner, which
-	   have low artifact rarities but came from extremely-rare base
-	   kinds. */
-	if ((ap > 0) && ((ap / 8) > a_ptr->rarity))
-		a_ptr->rarity = ap / 8;
-#endif /* 0 */
-
-	/* Restore some flags */
-	if (activates) a_ptr->flags3 |= TR3_ACTIVATE;
-	if (a_idx < ART_MIN_NORMAL) a_ptr->flags3 |= TR3_INSTA_ART;
+	if (x_ptr->cost < 0) x_ptr->cost = 0;
 
 	/*
 	 * Add TR3_HIDE_TYPE to all artifacts with nonzero pval because we're
 	 * too lazy to find out which ones need it and which ones don't.
 	 */
-	if (a_ptr->pval)
-		a_ptr->flags3 |= TR3_HIDE_TYPE;
-
-	return 0;
-}
-
-
-/*
- * Return nonzero if the whole set of random artifacts meets certain
- * criteria.  Return 0 if we fail to meet those criteria (which will
- * restart the whole process).
- */
-static int artifacts_acceptable(void)
-{
-	int swords = 5, polearms = 5, blunts = 5, bows = 3;
-	int bodies = 5, shields = 3, cloaks = 3, hats = 4;
-	int gloves = 4, boots = 4;
-	int i;
-
-	for (i = ART_MIN_NORMAL; i < z_info->a_max; i++)
-	{
-		switch (a_info[i].tval)
-		{
-			case TV_SWORD:
-				swords--; break;
-			case TV_POLEARM:
-				polearms--; break;
-			case TV_HAFTED:
-				blunts--; break;
-			case TV_BOW:
-				bows--; break;
-			case TV_SOFT_ARMOR:
-			case TV_HARD_ARMOR:
-				bodies--; break;
-			case TV_SHIELD:
-				shields--; break;
-			case TV_CLOAK:
-				cloaks--; break;
-			case TV_HELM:
-			case TV_CROWN:
-				hats--; break;
-			case TV_GLOVES:
-				gloves--; break;
-			case TV_BOOTS:
-				boots--; break;
-		}
-	}
-
-	if (swords > 0 || polearms > 0 || blunts > 0 || bows > 0 ||
-	    bodies > 0 || shields > 0 || cloaks > 0 || hats > 0 ||
-	    gloves > 0 || boots > 0)
-	{
-		if (randart_verbose)
-		{
-			char types[256];
-			sprintf(types, "%s%s%s%s%s%s%s%s%s%s",
-				swords > 0 ? " swords" : "",
-				polearms > 0 ? " polearms" : "",
-				blunts > 0 ? " blunts" : "",
-				bows > 0 ? " bows" : "",
-				bodies > 0 ? " body-armors" : "",
-				shields > 0 ? " shields" : "",
-				cloaks > 0 ? " cloaks" : "",
-				hats > 0 ? " hats" : "",
-				gloves > 0 ? " gloves" : "",
-				boots > 0 ? " boots" : "");
-			msg_format("Restarting generation process: not enough%s\n",
-				types);
-		}
-		return 0;
-	}
-	else
-	{
-		return 1;
-	}
-}
-
-
-static int scramble(void)
-{
-	/* This outer loop is for post-processing.  If our artifact set
-	   fails to meet certain criteria, we start over. :-( */
-	do
-	{
-		int a_idx;
-
-		/* Generate all the artifacts. */
-		for (a_idx = 1; a_idx < z_info->a_max; a_idx++)
-		{
-			scramble_artifact(a_idx);
-		}
-	} while (!artifacts_acceptable());	/* end of all artifacts */
-
-	return 0;
-}
-
-
-static int do_randart_aux(void)
-{
-	int result;
-
-	if ((result = init_names()) != 0) return result;
-
-	if ((result = scramble()) != 0) return result;
+	if (o_ptr->pval)
+		x_ptr->flags3 |= TR3_HIDE_TYPE;
 
 	return 0;
 }
 
-
-int do_randart(u32b randart_seed)
-{
-	int rc;
-
-	/* Prepare to use the Angband "simple" RNG. */
-	Rand_value = randart_seed;
-	Rand_quick = TRUE;
-
-	/* Allocate the "kinds" array */
-	C_MAKE(kinds, z_info->a_max, s16b);
-
-	rc = do_randart_aux();
-
-	/* Free the "kinds" array */
-	C_FREE(kinds, z_info->a_max, s16b);
-
-	/* When done, resume use of the Angband "complex" RNG. */
-	Rand_quick = FALSE;
-
-	return rc;
-}
-
-#endif /* GJW_RANDART */
Only in antiband/src: readdib.c
Only in antiband/src: readdib.h
diff --recursive --unified=4 angband-291/src/save.c antiband/src/save.c
--- angband-291/src/save.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/save.c	Thu Nov  1 23:23:32 2001
@@ -675,8 +675,33 @@
 	}
 	wr_byte(*str);
 }
 
+/*
+ * Write a "randart" record
+ */
+static void wr_randart(randart_type *x_ptr)
+{
+	int i;
+	const byte len = 20;
+	
+	wr_byte(len);
+	for (i = 0; i < len; i++)
+		wr_byte(x_ptr->name[i]);
+
+	wr_s32b(x_ptr->cost);
+
+	wr_u32b(x_ptr->flags1);
+	wr_u32b(x_ptr->flags2);
+	wr_u32b(x_ptr->flags3);
+
+	wr_byte(x_ptr->level);
+
+	wr_byte(x_ptr->activation);
+	wr_u16b(x_ptr->time);
+	wr_u16b(x_ptr->randtime);
+}
+
 
 /*
  * These functions write info in larger logical records
  */
@@ -703,8 +728,9 @@
 	wr_s16b(o_ptr->weight);
 
 	wr_byte(o_ptr->name1);
 	wr_byte(o_ptr->name2);
+	wr_byte(o_ptr->name3);
 
 	wr_s16b(o_ptr->timeout);
 
 	wr_s16b(o_ptr->to_h);
@@ -717,8 +743,12 @@
 	wr_byte(o_ptr->ident);
 
 	wr_byte(o_ptr->marked);
 
+	/* Special hack - dump randart info now */
+	if (o_ptr->name3)
+		wr_randart(&x_info[o_ptr->name3]);
+
 	/* Old flags */
 	wr_u32b(0L);
 	wr_u32b(0L);
 	wr_u32b(0L);
@@ -1030,8 +1060,9 @@
 
 	/* Dump the stats (maximum and current) */
 	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_max[i]);
 	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_cur[i]);
+	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_lim[i]);
 
 	/* Ignore the transient stats */
 	for (i = 0; i < 12; ++i) wr_s16b(0);
 
@@ -1816,9 +1847,9 @@
 			sf_minor = 5;
 		}
 
 		/* Extremely old savefiles */
-		if (sf_major > 2)
+		if (sf_major > 2 && sf_major < 12)
 		{
 			sf_major = 1;
 		}
 
@@ -1839,9 +1870,9 @@
 			err = rd_savefile_old();
 		}
 
 		/* Parse "new" savefiles */
-		else if (sf_major == 2)
+		else if (sf_major == 2 || sf_major == 12)
 		{
 			/* Attempt to load */
 			err = rd_savefile_new();
 		}
@@ -1894,9 +1925,9 @@
 		    (version_patch != sf_patch))
 		{
 			/* Message */
 			msg_format("Converted a %d.%d.%d savefile.",
-			           sf_major, sf_minor, sf_patch);
+			           sf_major % 10, sf_minor, sf_patch);
 			msg_print(NULL);
 		}
 
 		/* Player is dead */
diff --recursive --unified=4 angband-291/src/spells1.c antiband/src/spells1.c
--- angband-291/src/spells1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/spells1.c	Thu Nov 15 01:43:34 2001
@@ -851,8 +851,9 @@
 	if (p_ptr->immune_acid || (dam <= 0)) return;
 
 	/* Resist the damage */
 	if (p_ptr->resist_acid) dam = (dam + 2) / 3;
+	if (p_ptr->xresist_acid) dam = (dam + 2) / 3;
 	if (p_ptr->oppose_acid) dam = (dam + 2) / 3;
 
 	/* If any armor gets hit, defend the player */
 	if (minus_ac()) dam = (dam + 1) / 2;
@@ -877,8 +878,9 @@
 
 	/* Resist the damage */
 	if (p_ptr->oppose_elec) dam = (dam + 2) / 3;
 	if (p_ptr->resist_elec) dam = (dam + 2) / 3;
+	if (p_ptr->xresist_elec) dam = (dam + 2) / 3;
 
 	/* Take damage */
 	take_hit(dam, kb_str);
 
@@ -901,8 +903,9 @@
 
 	/* Resist the damage */
 	if (p_ptr->resist_fire) dam = (dam + 2) / 3;
 	if (p_ptr->oppose_fire) dam = (dam + 2) / 3;
+	if (p_ptr->xresist_fire) dam = (dam + 2) / 3;
 
 	/* Take damage */
 	take_hit(dam, kb_str);
 
@@ -923,8 +926,9 @@
 
 	/* Resist the damage */
 	if (p_ptr->resist_cold) dam = (dam + 2) / 3;
 	if (p_ptr->oppose_cold) dam = (dam + 2) / 3;
+	if (p_ptr->xresist_cold) dam = (dam + 2) / 3;
 
 	/* Take damage */
 	take_hit(dam, kb_str);
 
@@ -950,9 +954,9 @@
 	/* Then augment the current/max stat */
 	value = p_ptr->stat_cur[stat];
 
 	/* Cannot go above 18/100 */
-	if (value < 18+100)
+	if (value < p_ptr->stat_lim[stat])
 	{
 		/* Gain one (sometimes two) points */
 		if (value < 18)
 		{
@@ -960,21 +964,21 @@
 			value += gain;
 		}
 
 		/* Gain 1/6 to 1/3 of distance to 18/100 */
-		else if (value < 18+98)
+		else if (value < p_ptr->stat_lim[stat] - 2)
 		{
 			/* Approximate gain value */
-			gain = (((18+100) - value) / 2 + 3) / 2;
+			gain = ((p_ptr->stat_lim[stat] - value) / 2 + 3) / 2;
 
 			/* Paranoia */
 			if (gain < 1) gain = 1;
 
 			/* Apply the bonus */
 			value += randint(gain) + gain / 2;
 
 			/* Maximal value */
-			if (value > 18+99) value = 18 + 99;
+			if (value > p_ptr->stat_lim[stat] - 1) value = p_ptr->stat_lim[stat] - 1;
 		}
 
 		/* Gain one point at a time */
 		else
@@ -1241,9 +1245,9 @@
  * Apply Nexus
  */
 static void apply_nexus(monster_type *m_ptr)
 {
-	int max1, cur1, max2, cur2, ii, jj;
+	int max1, cur1, max2, cur2, lim1, lim2, ii, jj;
 
 	switch (randint(7))
 	{
 		case 1: case 2: case 3:
@@ -1286,15 +1290,19 @@
 			for (jj = ii; jj == ii; jj = rand_int(6)) /* loop */;
 
 			max1 = p_ptr->stat_max[ii];
 			cur1 = p_ptr->stat_cur[ii];
+			lim1 = p_ptr->stat_lim[ii];
 			max2 = p_ptr->stat_max[jj];
 			cur2 = p_ptr->stat_cur[jj];
+			lim2 = p_ptr->stat_lim[jj];
 
 			p_ptr->stat_max[ii] = max2;
 			p_ptr->stat_cur[ii] = cur2;
+			p_ptr->stat_lim[ii] = lim2;
 			p_ptr->stat_max[jj] = max1;
 			p_ptr->stat_cur[jj] = cur1;
+			p_ptr->stat_lim[jj] = lim1;
 
 			p_ptr->update |= (PU_BONUS);
 
 			break;
@@ -1964,9 +1972,9 @@
  * also set "notice" to FALSE, or the player will learn what the spell does.
  *
  * We attempt to return "TRUE" if the player saw anything "useful" happen.
  */
-static bool project_m(int who, int r, int y, int x, int dam, int typ)
+static bool project_m(int who, int r, int y, int x, int dam, int typ, bool breath)
 {
 	int tmp;
 
 	monster_type *m_ptr;
@@ -2031,8 +2039,14 @@
 	l_ptr = &l_list[m_ptr->r_idx];
 	name = (r_name + r_ptr->name);
 	if (m_ptr->ml) seen = TRUE;
 
+#if 0
+	/* Never affect other monsters in same pack with breath weapons */
+	if (breath && (r_ptr->flags1 & RF1_GROUP_MASK) && who && m_list[who].r_idx == m_ptr->r_idx)
+		return (FALSE);
+#endif
+
 
 	/* Reduce damage by distance */
 	dam = (dam + r) / (r + 1);
 
@@ -3368,9 +3382,9 @@
 			if (p_ptr->resist_chaos)
 			{
 				dam *= 6; dam /= (randint(6) + 6);
 			}
-			if (!p_ptr->resist_confu)
+			if (!p_ptr->resist_confu && !p_ptr->resist_chaos)
 			{
 				(void)set_confused(p_ptr->confused + rand_int(20) + 10);
 			}
 			if (!p_ptr->resist_chaos)
@@ -4179,9 +4193,9 @@
 			y = gy[i];
 			x = gx[i];
 
 			/* Affect the monster in the grid */
-			if (project_m(who, dist, y, x, dam, typ)) notice = TRUE;
+			if (project_m(who, dist, y, x, dam, typ, rad > 0)) notice = TRUE;
 		}
 
 		/* Player affected one monster (without "jumping") */
 		if ((who < 0) && (project_m_n == 1) && !(flg & (PROJECT_JUMP)))
diff --recursive --unified=4 angband-291/src/spells2.c antiband/src/spells2.c
--- angband-291/src/spells2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/spells2.c	Thu Nov 15 01:46:46 2001
@@ -550,9 +550,11 @@
 	if (p_ptr->immune_acid)
 	{
 		info[i++] = "You are completely immune to acid.";
 	}
-	else if ((p_ptr->resist_acid) && (p_ptr->oppose_acid))
+	else if (((p_ptr->resist_acid) && (p_ptr->oppose_acid)) ||
+		     ((p_ptr->resist_acid) && (p_ptr->xresist_acid)) ||
+			 ((p_ptr->xresist_acid) && (p_ptr->oppose_acid)))
 	{
 		info[i++] = "You resist acid exceptionally well.";
 	}
 	else if ((p_ptr->resist_acid) || (p_ptr->oppose_acid))
@@ -563,9 +565,11 @@
 	if (p_ptr->immune_elec)
 	{
 		info[i++] = "You are completely immune to lightning.";
 	}
-	else if ((p_ptr->resist_elec) && (p_ptr->oppose_elec))
+	else if (((p_ptr->resist_elec) && (p_ptr->oppose_elec)) ||
+		     ((p_ptr->resist_elec) && (p_ptr->xresist_elec)) ||
+			 ((p_ptr->xresist_elec) && (p_ptr->oppose_elec)))
 	{
 		info[i++] = "You resist lightning exceptionally well.";
 	}
 	else if ((p_ptr->resist_elec) || (p_ptr->oppose_elec))
@@ -576,9 +580,11 @@
 	if (p_ptr->immune_fire)
 	{
 		info[i++] = "You are completely immune to fire.";
 	}
-	else if ((p_ptr->resist_fire) && (p_ptr->oppose_fire))
+	else if (((p_ptr->resist_fire) && (p_ptr->oppose_fire)) ||
+		     ((p_ptr->resist_fire) && (p_ptr->xresist_fire)) ||
+			 ((p_ptr->xresist_fire) && (p_ptr->oppose_fire)))
 	{
 		info[i++] = "You resist fire exceptionally well.";
 	}
 	else if ((p_ptr->resist_fire) || (p_ptr->oppose_fire))
@@ -589,9 +595,11 @@
 	if (p_ptr->immune_cold)
 	{
 		info[i++] = "You are completely immune to cold.";
 	}
-	else if ((p_ptr->resist_cold) && (p_ptr->oppose_cold))
+	else if (((p_ptr->resist_cold) && (p_ptr->oppose_cold)) ||
+		     ((p_ptr->resist_cold) && (p_ptr->xresist_cold)) ||
+			 ((p_ptr->xresist_cold) && (p_ptr->oppose_cold)))
 	{
 		info[i++] = "You resist cold exceptionally well.";
 	}
 	else if ((p_ptr->resist_cold) || (p_ptr->oppose_cold))
@@ -744,8 +752,20 @@
 	/* Analyze the weapon */
 	if (o_ptr->k_idx)
 	{
 		/* Special "Attack Bonuses" */
+		if (f1 & (TR1_BRAND_NETHR))
+		{
+			info[i++] = "Your weapon drains your foes of life.";
+		}
+		if (f1 & (TR1_BRAND_NEXUS))
+		{
+			info[i++] = "Your weapon warps space around your foes.";
+		}
+		if (f1 & (TR1_BRAND_CHAOS))
+		{
+			info[i++] = "Your weapon smites your foes with chaos.";
+		}
 		if (f1 & (TR1_BRAND_ACID))
 		{
 			info[i++] = "Your weapon melts your foes.";
 		}
@@ -1775,15 +1795,110 @@
 	return (TRUE);
 }
 
 
+static bool brand_spell(object_type *o_ptr)
+{
+	object_kind *k_ptr = &k_info[o_ptr->k_idx];
+	bool success;
+	ego_item_type *e_ptr;
+	int prob;
+
+	/* Some items can't be branded */
+	if (artifact_p(o_ptr) || ego_item_p(o_ptr) ||
+	    cursed_p(o_ptr) || broken_p(o_ptr))
+	{
+		return (FALSE);
+	}
+	
+#if 0
+	/* DSM can't be branded, either */
+	if (o_ptr->tval == TV_DRAG_ARMOR)
+	{
+		return (FALSE);
+	}
+#endif
+
+	/* DSM resists enchantment a lot */
+	if (o_ptr->tval == TV_DRAG_ARMOR && rand_int(20) != 0)
+		return (FALSE);
+
+	/* Large piles resist enchantment */
+	prob = o_ptr->number * 100;
+
+	/* Missiles are easy to enchant */
+	if ((o_ptr->tval == TV_BOLT) ||
+	    (o_ptr->tval == TV_ARROW) ||
+	    (o_ptr->tval == TV_SHOT))
+	{
+		prob = prob / 20;
+	}
+
+	/* Roll for pile resistance */
+	if (prob > 100 && rand_int(prob) >= 100) return (FALSE);
+
+	/* High level objects "resist" enchantment */
+	if (rand_int(k_ptr->level) >= 10 && rand_int(k_ptr->level) >= 10)
+		return (FALSE);
+
+	/* Enchantment occasionally fails even for normal items */
+	if (rand_int(100) < 15)
+		return (FALSE);
+
+	if (!make_ego_item(o_ptr, FALSE, k_ptr->level + randint(40)))
+		return (FALSE);
+
+	e_ptr = &e_info[o_ptr->name2];
+
+	/* Extra powers */
+	if (e_ptr->xtra)
+	{
+		o_ptr->xtra1 = e_ptr->xtra;
+	}
+
+	/* Hack -- obtain pval */
+	if (e_ptr->max_pval > 0) o_ptr->pval += randint(e_ptr->max_pval);
+
+	/* Add to-hit, to-dam and to-ac */
+	if (e_ptr->max_to_a > 0) o_ptr->to_a += randint(e_ptr->max_to_a);
+	if (e_ptr->max_to_h > 0) o_ptr->to_h += randint(e_ptr->max_to_h);
+	if (e_ptr->max_to_d > 0) o_ptr->to_d += randint(e_ptr->max_to_d);
+
+	/* Handle special powers */
+	if (o_ptr->xtra1)
+	{
+		switch (o_ptr->xtra1)
+		{
+			case OBJECT_XTRA_TYPE_SUSTAIN:
+			{
+				o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_SUSTAIN);
+				break;
+			}
+
+			case OBJECT_XTRA_TYPE_RESIST:
+			{
+				o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_RESIST);
+				break;
+			}
+
+			case OBJECT_XTRA_TYPE_POWER:
+			{
+				o_ptr->xtra2 = (byte)rand_int(OBJECT_XTRA_SIZE_POWER);
+				break;
+			}
+		}
+	}
+
+	return (TRUE);
+}
+
 
 /*
  * Enchant an item (in the inventory or on the floor)
  * Note that "num_ac" requires armour, else weapon
  * Returns TRUE if attempted, FALSE if cancelled
  */
-bool enchant_spell(int num_hit, int num_dam, int num_ac)
+bool enchant_spell(int num_hit, int num_dam, int num_ac, bool ego)
 {
 	int item;
 	bool okay = FALSE;
 
@@ -1830,8 +1945,14 @@
 	if (enchant(o_ptr, num_hit, ENCH_TOHIT)) okay = TRUE;
 	if (enchant(o_ptr, num_dam, ENCH_TODAM)) okay = TRUE;
 	if (enchant(o_ptr, num_ac, ENCH_TOAC)) okay = TRUE;
 
+	/* Try to brand */
+	if (ego)
+	{
+		if (brand_spell(o_ptr)) okay = TRUE;
+	}
+
 	/* Failure */
 	if (!okay)
 	{
 		/* Flush */
@@ -1983,24 +2104,25 @@
 
 	/* Describe */
 	if (item >= INVEN_WIELD)
 	{
-		msg_format("%^s: %s (%c).",
-		           describe_use(item), o_name, index_to_label(item));
+		strcpy(o_name, format("%^s: %s (%c)", describe_use(item), o_name, index_to_label(item)));
 	}
 	else if (item >= 0)
 	{
-		msg_format("In your pack: %s (%c).",
-		           o_name, index_to_label(item));
+		strcpy(o_name, format("In pack: %s (%c)", o_name, index_to_label(item)));
 	}
 	else
 	{
-		msg_format("On the ground: %s.",
-		           o_name);
+		strcpy(o_name, format("On ground: %s", o_name));
 	}
 
 	/* Describe it fully */
-	identify_fully_aux(o_ptr);
+	if (!identify_fully_aux(o_ptr, o_name))
+	{
+		msg_format("Examining %s... you see nothing special.", o_name);
+		msg_print(NULL);
+	}
 
 	/* Success */
 	return (TRUE);
 }
@@ -2346,8 +2468,55 @@
 	if (speed) msg_print("You feel a sudden stirring nearby!");
 	else if (sleep) msg_print("You hear a sudden stirring in the distance!");
 }
 
+/*
+ * Wake up "los" monsters.
+ */
+void wake_monsters(int who)
+{
+	int i;
+
+	/* Aggravate everyone nearby */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Wake up sleeping monsters in los of shouting monster */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			/* Wake up */
+			if (m_ptr->csleep)
+			{
+				/* Wake up */
+				m_ptr->csleep = 0;
+
+				/* Notice the "waking up" */
+				if (m_ptr->ml)
+				{
+					char m_name[80];
+
+					/* Get the monster name */
+					monster_desc(m_name, m_ptr, 0);
+
+					/* Dump a message */
+					msg_format("%^s wakes up.", m_name);
+
+					/* Hack -- Update the health bar */
+					if (p_ptr->health_who == who) p_ptr->redraw |= (PR_HEALTH);
+				}
+			}
+		}
+	}
+}
+
 
 
 /*
  * Delete all non-unique monsters of a given "type" from the level
@@ -3262,8 +3431,11 @@
 bool fire_ball(int typ, int dir, int dam, int rad)
 {
 	int py = p_ptr->py;
 	int px = p_ptr->px;
+	int sx, sy;
+
+	int d;
 
 	int ty, tx;
 
 	int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
@@ -3282,8 +3454,60 @@
 	}
 
 	/* Analyze the "dir" and the "target".  Hurt items on floor. */
 	return (project(-1, rad, ty, tx, dam, typ, flg));
+}
+
+bool fire_meteor(int typ, int dir, int dam, int rad, int scatter, int num)
+{
+	int py = p_ptr->py;
+	int px = p_ptr->px;
+	int sx, sy;
+
+	int d, i;
+
+	int ty, tx;
+	int fx, fy;
+	bool result = FALSE;
+
+	int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
+
+	/* Use the given direction */
+	ty = py + 99 * ddy[dir];
+	tx = px + 99 * ddx[dir];
+
+	/* Hack -- Use an actual "target" */
+	if ((dir == 5) && target_okay())
+	{
+		flg &= ~(PROJECT_STOP);
+
+		ty = p_ptr->target_row;
+		tx = p_ptr->target_col;
+	}
+
+	for (i = 0; i < num; i++)
+	{
+		fx = tx;
+		fy = ty;
+
+		/* Scatter a bit */
+		d = (distance(py, px, ty, tx) * scatter + 9) / 10;
+		if (d > 0)
+		{
+			do
+			{
+				sx = rand_int(2 * d + 1) - d;
+				sy = rand_int(2 * d + 1) - d;
+			}
+			while (distance(ty, tx, ty + sy, tx + sx) > d);
+			fy += sy;
+			fx += sx;
+		}
+
+		/* Analyze the "dir" and the "target".  Hurt items on floor. */
+		if (project(-1, rad, fy, fx, dam, typ, flg)) result = TRUE;
+	}
+	return (result);
 }
 
 
 /*
diff --recursive --unified=4 angband-291/src/store.c antiband/src/store.c
--- angband-291/src/store.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/store.c	Thu Nov  8 20:05:22 2001
@@ -472,9 +472,9 @@
 		case TV_HAFTED:
 		case TV_DIGGING:
 		case TV_BOW:
 		{
-			if (o_ptr->name2) break;
+			if (o_ptr->name2 || o_ptr->name3) break;
 			if (cost <= 10L) size += mass_roll(3, 5);
 			if (cost <= 100L) size += mass_roll(3, 5);
 			break;
 		}
@@ -591,8 +591,11 @@
 
 	/* Require identical "ego-item" names */
 	if (o_ptr->name2 != j_ptr->name2) return (0);
 
+	/* Require identical "randart" names */
+	if (o_ptr->name3 != j_ptr->name3) return (0);
+
 	/* Hack -- Never stack "powerful" items */
 	if (o_ptr->xtra1 || j_ptr->xtra1) return (0);
 
 	/* Hack -- Never stack recharging items */
@@ -959,9 +962,8 @@
 
 	/* Remove special inscription, if any */
 	if (o_ptr->discount >= INSCRIP_NULL) o_ptr->discount = 0;
 
-
 	/* Check each existing object (try to combine) */
 	for (slot = 0; slot < st_ptr->stock_num; slot++)
 	{
 		/* Get the existing object */
@@ -1061,8 +1063,12 @@
 
 	/* Must have no items */
 	if (o_ptr->number) return;
 
+	/* Reclaim randarts */
+	if (o_ptr->name3)
+		x_info[o_ptr->name3].name[0] = 0;
+
 	/* One less object */
 	st_ptr->stock_num--;
 
 	/* Slide everyone */
@@ -1161,21 +1167,29 @@
 
 	object_type *i_ptr;
 	object_type object_type_body;
 
+	bool random;
+
+	random = (rand_int(100) < 20);
 
 	/* Paranoia -- no room left */
 	if (st_ptr->stock_num >= st_ptr->stock_size) return;
 
 
-	/* Hack -- consider up to four items */
-	for (tries = 0; tries < 4; tries++)
+	/* Hack -- consider up to four items, fifty if random */
+	for (tries = 0; tries < random ? 50 : 4; tries++)
 	{
 		/* Black Market */
 		if (store_num == STORE_B_MARKET)
 		{
 			/* Pick a level for object/magic */
-			level = 25 + rand_int(25);
+			/* ANTIBAND: Increased maximum level for BM items */
+			level = 20 + rand_int(50);
+
+			/* Deliberate cruelty - stock some terrific stuff at the beginning */
+			if (turn < 50 && rand_int(4) == 0)
+				level = 120;
 
 			/* Random object kind (usually of given level) */
 			k_idx = get_obj_num(level);
 
@@ -1185,13 +1199,29 @@
 
 		/* Normal Store */
 		else
 		{
-			/* Hack -- Pick an object kind to sell */
-			k_idx = st_ptr->table[rand_int(st_ptr->table_num)];
+			/* ANTIBAND: Sometimes create random items of a type the store will buy */
+			if (random)
+			{
+				/* Pick a level for object/magic */
+				/* ANTIBAND: Increased maximum level for BM items, reduced minimum */
+				level = 5 + rand_int(30);
+
+				/* Random object kind (usually of given level) */
+				k_idx = get_obj_num(level);
+
+				/* Handle failure */
+				if (!k_idx) continue;
+			}
+			else
+			{
+				/* Hack -- Pick an object kind to sell */
+				k_idx = st_ptr->table[rand_int(st_ptr->table_num)];
 
-			/* Hack -- fake level for apply_magic() */
-			level = rand_range(1, STORE_OBJ_LEVEL);
+				/* Hack -- fake level for apply_magic() */
+				level = rand_range(1, STORE_OBJ_LEVEL);
+			}
 		}
 
 
 		/* Get local object */
@@ -1200,9 +1230,9 @@
 		/* Create a new object of the chosen kind */
 		object_prep(i_ptr, k_idx);
 
 		/* Apply some "low-level" magic (no artifacts) */
-		apply_magic(i_ptr, level, FALSE, FALSE, FALSE);
+		apply_magic(i_ptr, level, FALSE, FALSE, FALSE, FALSE);
 
 		/* Hack -- Charge lite's */
 		if (i_ptr->tval == TV_LITE)
 		{
@@ -1213,8 +1243,12 @@
 
 		/* The object is "known" */
 		object_known(i_ptr);
 
+		/* The object is *identified* if needed */
+		if (i_ptr->xtra1 || i_ptr->name3)
+			i_ptr->ident |= IDENT_MENTAL;
+
 		/* Mega-Hack -- no chests in stores */
 		if (i_ptr->tval == TV_CHEST) continue;
 
 		/* Prune the black market */
@@ -1236,8 +1270,11 @@
 			/* No "worthless" items */
 			if (object_value(i_ptr) <= 0) continue;
 		}
 
+		/* Prune all stores */
+		if (!store_will_buy(i_ptr)) continue;
+
 
 		/* Mass produce and/or Apply discount */
 		mass_produce(i_ptr);
 
@@ -2839,16 +2876,17 @@
 	/* Get the actual object */
 	o_ptr = &st_ptr->stock[item];
 
 	/* Description */
-	object_desc(o_name, o_ptr, TRUE, 3);
-
-	/* Describe */
-	msg_format("Examining %s...", o_name);
+	object_desc_store(o_name, o_ptr, TRUE, 3);
 
 	/* Describe it fully */
-	if (!identify_fully_aux(o_ptr))
-		msg_print("You see nothing special.");
+	if (!identify_fully_aux(o_ptr, o_name)) 
+	{
+		/* Redescribe */
+		object_desc_store(o_name, o_ptr, TRUE, 3);
+		msg_format("Examining %s... you see nothing special.", o_name);
+	}
 
 	return;
 }
 
diff --recursive --unified=4 angband-291/src/tables.c antiband/src/tables.c
--- angband-291/src/tables.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/tables.c	Wed Nov  7 20:06:40 2001
@@ -1359,9 +1359,9 @@
 		0,
 
 		99,
 		0,
-
+#if 0
 		{
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
@@ -1435,8 +1435,9 @@
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0}
 		}
+#endif
 	},
 
 	{
 		/*** Mage ***/
@@ -1448,84 +1449,85 @@
 		0,
 
 		1,
 		300,
-
+#if 0
 		{
-			{  1,  1, 22,   4},
-			{  1,  1, 23,   4},
-			{  1,  2, 24,   4},
-			{  1,  2, 26,   4},
-			{ 99,  0,  0,   0},
-			{  3,  3, 25,   3},
-			{ 99,  0,  0,   0},
-			{  3,  3, 25,   1},
-			{  3,  3, 27,   3},
-
-			{  3,  4, 30,   1},
-			{  5,  4, 30,   4},
-			{  5,  5, 30,   6},
-			{  5,  5, 30,   4},
-			{  5,  5, 35,   4},
-			{  7,  6, 35,   5},
-			{  7,  6, 30,   5},
-			{  7,  6, 40,   6},
-			{  9,  7, 44,   8},
-
-			{  9,  7, 45,   8},
-			{  9,  7, 75,   9},
-			{  9,  7, 45,   8},
-			{ 11,  7, 45,   9},
-			{ 11,  7, 75,   6},
-			{ 13,  7, 50,   6},
-			{ 15,  9, 50,   6},
-			{ 17,  9, 50,   7},
-
-			{ 19, 12, 55,   8},
-			{ 21, 12, 90,   8},
-			{ 23, 12, 60,   8},
-			{ 25, 12, 65,  10},
-			{ 29, 18, 65,  12},
-			{ 33, 21, 80,  15},
-			{ 37, 25, 95,  21},
-
-			{  7,  7, 20,  28},
-			{  9, 12, 40,  44},
-			{ 15, 17, 60,  29},
-			{ 20, 18, 60,  24},
-			{ 25, 25, 75,  19},
-
-			{ 10,  6, 50,  12},
-			{ 12,  9, 60,  16},
-			{ 20, 15, 70,  20},
-			{ 27, 25, 75,  29},
-			{ 35, 35, 85,  34},
-			{ 42, 45, 95, 200},
-
-			{ 5,  5,  50,   8},
-			{ 10, 10, 70,  40},
-			{ 25, 30, 95, 160},
-			{ 30, 50, 70,  40},
-			{ 40, 75, 80, 100},
-
-			{  4,  5, 50,  20},
-			{  4,  5, 50,  20},
-			{  4,  5, 50,  20},
-			{  8, 10, 75,  40},
-			{ 15, 20, 85,  60},
-
-			{  5,  5, 50,  80},
-			{ 10, 12, 75, 120},
-			{ 15, 20, 80, 200},
-			{ 22, 30, 50, 250},	/* 350 */
-			{ 45, 70, 75, 250},	/* 450 */
+			{  1,  1, 22,   4},		/* Magic Missile */
+			{  1,  1, 23,   4},		/* Detect Monsters */
+			{  1,  2, 24,   4},		/* Phase Door */
+			{  1,  2, 26,   4},		/* Light Area */
+			{ 99,  0,  0,   0},		/* Treasure Detection */
+			{  3,  3, 25,   3},		/* Cure Light Wounds */
+			{ 99,  0,  0,   0},		/* Object Detection */
+			{  3,  3, 25,   1},		/* Find Hidden Traps/Doors */
+			{  3,  3, 27,   3},		/* Stinking Cloud */
+
+			{  3,  4, 30,   1},		/* Confuse Monster */
+			{  5,  4, 30,   4},		/* Lightning Bolt */
+			{  5,  5, 30,   6},		/* Trap/Door Destruction */
+			{  5,  5, 30,   4},		/* Sleep I */
+			{  5,  5, 35,   4},		/* Cure Poison */
+			{  7,  6, 35,   5},		/* Teleport Self */
+			{  7,  6, 30,   5},		/* Spear of Light */
+			{  7,  6, 40,   6},		/* Frost Bolt */
+			{  9,  7, 44,   8},		/* Turn Stone to Mud */
+
+			{  9,  7, 45,   8},		/* Satisfy Hunger */
+			{  9,  7, 75,   9},		/* Recharge Item I */
+			{  9,  7, 45,   8},		/* Sleep II */
+			{ 11,  7, 45,   9},		/* Polymorph Other */
+			{ 11,  7, 75,   6},		/* Identify */
+			{ 13,  7, 50,   6},		/* Sleep III */
+			{ 15,  9, 50,   6},		/* Fire Bolt */
+			{ 17,  9, 50,   7},		/* Slow Monster */
+
+			{ 19, 12, 55,   8},		/* Frost Ball */
+			{ 21, 12, 90,   8},		/* Recharge Item II */
+			{ 23, 12, 60,   8},		/* Teleport Other */
+			{ 25, 12, 65,  10},		/* Haste Self */
+			{ 29, 18, 65,  12},		/* Fire Ball */
+			{ 33, 21, 80,  15},		/* Word of Destruction */
+			{ 37, 25, 95,  21},		/* Genocide */
+
+			{  7,  7, 20,  28},		/* Door Creation */
+			{  9, 12, 40,  44},		/* Stair Creation */
+			{ 15, 17, 60,  29},		/* Teleport Level */
+			{ 20, 18, 60,  24},		/* Earthquake */
+			{ 25, 25, 75,  19},		/* Word of Recall */
+
+			{ 10,  6, 50,  12},		/* Acid Bolt */
+			{ 12,  9, 60,  16},		/* Cloud Kill */
+			{ 20, 15, 70,  20},		/* Acid Ball */
+			{ 27, 25, 75,  29},		/* Ice Storm */
+			{ 35, 35, 85,  34},		/* Meteor Swarm */
+			{ 42, 45, 95, 200},		/* Mana Storm */
+
+			{ 5,  5,  50,   8},		/* Detect Evil */
+			{ 10, 10, 70,  40},		/* Detect Enchantment */
+			{ 25, 30, 95, 160},		/* Recharge Item III */
+			{ 30, 50, 70,  40},		/* Genocide */
+			{ 40, 75, 80, 100},		/* Mass Genocide */
+
+			{  4,  5, 50,  20},		/* Resist Fire */
+			{  4,  5, 50,  20},		/* Resist Cold */
+			{  4,  5, 50,  20},		/* Resist Acid */
+			{  8, 10, 75,  40},		/* Resist Poison */
+			{ 15, 20, 85,  60},		/* Resistance */
+
+			{  5,  5, 50,  80},		/* Heroism */
+			{ 10, 12, 75, 120},		/* Shield */
+			{ 15, 20, 80, 200},		/* Berserker */
+			{ 22, 30, 50, 250},	/* 350 */	/* Essence of Speed */
+			{ 45, 70, 75, 250},	/* 450 */	/* Globe of Invulnerability */
 
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0}
 		}
+#endif
 	},
 
 	{
 		/*** Priest ***/
@@ -1537,9 +1539,9 @@
 		1,
 
 		1,
 		350,
-
+#if 0
 		{
 			{  1,  1, 10,   4},
 			{  1,  2, 15,   4},
 			{  1,  2, 20,   4},
@@ -1613,8 +1615,9 @@
 			{ 99,  0,  0,    0},
 			{ 99,  0,  0,    0},
 			{ 99,  0,  0,    0}
 		}
+#endif
 	},
 
 	{
 		/*** Rogue ***/
@@ -1626,9 +1629,9 @@
 		0,
 
 		5,
 		350,
-
+#if 0
 		{
 			{ 99,  0,  0,   0},
 			{  5,  1, 50,   1},
 			{  7,  2, 55,   1},
@@ -1702,8 +1705,9 @@
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0}
 		}
+#endif
 	},
 
 	{
 		/*** Ranger ***/
@@ -1715,9 +1719,9 @@
 		0,
 
 		3,
 		400,
-
+#if 0
 		{
 			{  3,  1, 30,   1},
 			{  3,  2, 35,   2},
 			{  3,  2, 35,   2},
@@ -1791,8 +1795,9 @@
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0}
 		}
+#endif
 	},
 
 	{
 		/*** Paladin ***/
@@ -1804,9 +1809,9 @@
 		1,
 
 		1,
 		400,
-
+#if 0
 		{
 			{  1,  1, 30,   4},
 			{  2,  2, 35,   4},
 			{  3,  3, 35,   4},
@@ -1875,224 +1880,1408 @@
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
 			{ 99,  0,  0,   0},
-			{ 99,  0,  0,   0}
-		}
-	}
-};
-
-
-/*
- * Spells in each book (mage spells then priest spells)
- */
-u32b spell_flags[2][9][2] =
-{
-	{
-		/*** Mage spell books ***/
-		{ 0x000001ff, 0x00000000 },
-		{ 0x0003fe00, 0x00000000 },
-		{ 0x03fc0000, 0x00000000 },
-		{ 0xfc000000, 0x00000001 },
-		{ 0x00000000, 0x003e0000 },
-		{ 0x00000000, 0x0000003e },
-		{ 0x00000000, 0x0001f000 },
-		{ 0x00000000, 0x07c00000 },
-		{ 0x00000000, 0x00000fc0 }
-	},
-
-	{
-		/*** Priest spell books ***/
-		{ 0x000000ff, 0x00000000 },
-		{ 0x0000ff00, 0x00000000 },
-		{ 0x01ff0000, 0x00000000 },
-		{ 0x7e000000, 0x00000000 },
-		{ 0x00000000, 0x03f00000 },
-		{ 0x80000000, 0x0000000f },
-		{ 0x00000000, 0x000001f0 },
-		{ 0x00000000, 0x000fc000 },
-		{ 0x00000000, 0x00003e00 }
-	}
-};
-
-
-/*
- * Names of the spells (mage spells then priest spells)
- */
-cptr spell_names[2][64] =
-{
-	/*** Mage Spells ***/
-
-	{
-		/* Magic for Beginners (sval 0) */
-		"Magic Missile",
-		"Detect Monsters",
-		"Phase Door",
-		"Light Area",
-		"Treasure Detection",
-		"Cure Light Wounds",
-		"Object Detection",
-		"Find Hidden Traps/Doors",
-		"Stinking Cloud",
-
-		/* Conjurings and Tricks (sval 1) */
-		"Confuse Monster",
-		"Lightning Bolt",
-		"Trap/Door Destruction",
-		"Sleep I",
-		"Cure Poison",
-		"Teleport Self",
-		"Spear of Light",
-		"Frost Bolt",
-		"Turn Stone to Mud",
-
-		/* Incantations and Illusions (sval 2) */
-		"Satisfy Hunger",
-		"Recharge Item I",
-		"Sleep II",
-		"Polymorph Other",
-		"Identify",
-		"Sleep III",
-		"Fire Bolt",
-		"Slow Monster",
-
-		/* Sorcery and Evocations (sval 3) */
-		"Frost Ball",
-		"Recharge Item II",
-		"Teleport Other",
-		"Haste Self",
-		"Fire Ball",
-		"Word of Destruction",
-		"Genocide",
-
-		/* Mordenkainen's Escapes (sval 5) */
-		"Door Creation",
-		"Stair Creation",
-		"Teleport Level",
-		"Earthquake",
-		"Word of Recall",
-
-		/* Raal's Tome of Destruction (sval 8) */
-		"Acid Bolt",
-		"Cloud Kill",
-		"Acid Ball",
-		"Ice Storm",
-		"Meteor Swarm",
-		"Mana Storm",
-
-		/* Kelek's Grimoire of Power (sval 6) */
-		"Detect Evil",
-		"Detect Enchantment",
-		"Recharge Item III",
-		"Genocide",
-		"Mass Genocide",
-
-		/* Resistance of Scarabtarices (sval 4) */
-		"Resist Fire",
-		"Resist Cold",
-		"Resist Acid",
-		"Resist Poison",
-		"Resistance",
-
-		/* Tenser's transformations... (sval 7) */
-		"Heroism",
-		"Shield",
-		"Berserker",
-		"Essence of Speed",
-		"Globe of Invulnerability",
-
-		"(blank)",
-		"(blank)",
-		"(blank)",
-		"(blank)",
-		"(blank)"
-	},
-
-
-	/*** Priest Spells ***/
-
-	{
-		/* Beginners Handbook (sval 0) */
-		"Detect Evil",
-		"Cure Light Wounds",
-		"Bless",
-		"Remove Fear",
-		"Call Light",
-		"Find Traps",
-		"Detect Doors/Stairs",
-		"Slow Poison",
-
-		/* Words of Wisdom (sval 1) */
-		"Scare Monster",
-		"Portal",
-		"Cure Serious Wounds",
-		"Chant",
-		"Sanctuary",
-		"Satisfy Hunger",
-		"Remove Curse",
-		"Resist Heat and Cold",
-
-		/* Chants and Blessings (sval 2) */
-		"Neutralize Poison",
-		"Orb of Draining",
-		"Cure Critical Wounds",
-		"Sense Invisible",
-		"Protection from Evil",
-		"Earthquake",
-		"Sense Surroundings",
-		"Cure Mortal Wounds",
-		"Turn Undead",
-
-		/* Exorcism and Dispelling (sval 3) */
-		"Prayer",
-		"Dispel Undead",
-		"Heal",
-		"Dispel Evil",
-		"Glyph of Warding",
-		"Holy Word",
-
-		/* Godly Insights... (sval 5) */
-		"Detect Monsters",
-		"Detection",
-		"Perception",
-		"Probing",
-		"Clairvoyance",
-
-		/* Purifications and Healing (sval 6) */
-		"Cure Serious Wounds",
-		"Cure Mortal Wounds",
-		"Healing",
-		"Restoration",
-		"Remembrance",
-
-		/* Wrath of God (sval 8) */
-		"Dispel Undead",
-		"Dispel Evil",
-		"Banishment",
-		"Word of Destruction",
-		"Annihilation",
-
-		/* Holy Infusions (sval 7) */
-		"Unbarring Ways",
-		"Recharging",
-		"Dispel Curse",
-		"Enchant Weapon",
-		"Enchant Armour",
-		"Elemental Brand",
-
-		/* Ethereal openings (sval 4) */
-		"Blink",
-		"Teleport Self",
-		"Teleport Other",
-		"Teleport Level",
-		"Word of Recall",
-		"Alter Reality",
-
-		"(blank)",
-		"(blank)",
-		"(blank)",
-		"(blank)",
-		"(blank)"
+			{ 99,  0,  0,   0}
+		}
+#endif
+	}
+};
+
+#if 0
+/*
+ * Spells in each book (mage spells then priest spells)
+ */
+u32b spell_flags[2][9][2] =
+{
+	{
+		/*** Mage spell books ***/
+		{ 0x000001ff, 0x00000000 },
+		{ 0x0003fe00, 0x00000000 },
+		{ 0x03fc0000, 0x00000000 },
+		{ 0xfc000000, 0x00000001 },
+		{ 0x00000000, 0x003e0000 },
+		{ 0x00000000, 0x0000003e },
+		{ 0x00000000, 0x0001f000 },
+		{ 0x00000000, 0x07c00000 },
+		{ 0x00000000, 0x00000fc0 }
+	},
+
+	{
+		/*** Priest spell books ***/
+		{ 0x000000ff, 0x00000000 },
+		{ 0x0000ff00, 0x00000000 },
+		{ 0x01ff0000, 0x00000000 },
+		{ 0x7e000000, 0x00000000 },
+		{ 0x00000000, 0x03f00000 },
+		{ 0x80000000, 0x0000000f },
+		{ 0x00000000, 0x000001f0 },
+		{ 0x00000000, 0x000fc000 },
+		{ 0x00000000, 0x00003e00 }
+	}
+};
+#endif
+
+s16b spell_list[2][12][12] =
+{
+	{
+		/* Mage spell books */
+#if 0
+		{
+			SPELL_MAGIC_MISSILE, SPELL_DETECT_MONSTERS, SPELL_PHASE_DOOR,
+			SPELL_LIGHT_AREA, SPELL_TREASURE_DETECTION, SPELL_CURE_LIGHT_WOUNDS,
+			SPELL_OBJECT_DETECTION, SPELL_FIND_HIDDEN_TRAPS_AND_DOORS, SPELL_STINKING_CLOUD,
+			-1, -1, -1,
+		},
+		{
+			SPELL_CONFUSE_MONSTER, SPELL_LIGHTNING_BOLT, SPELL_TRAP_AND_DOOR_DESTRUCTION,
+			SPELL_SLEEP, SPELL_CURE_POISON, SPELL_TELEPORT_SELF,
+			SPELL_SPEAR_OF_LIGHT, SPELL_FROST_BOLT, SPELL_TURN_STONE_TO_MUD,
+			-1, -1, -1,
+		},
+		{
+			SPELL_SATISFY_HUNGER, SPELL_RECHARGE_ITEM, SPELL_SLEEP_2,
+			SPELL_POLYMORPH_OTHER, SPELL_IDENTIFY, SPELL_SLEEP_3,
+			SPELL_FIRE_BOLT, SPELL_SLOW_MONSTER, -1,
+			-1, -1, -1
+		},
+		{
+			SPELL_FROST_BALL, SPELL_RECHARGE_ITEM_2, SPELL_TELEPORT_OTHER,
+			SPELL_HASTE_SELF, SPELL_FIRE_BALL, SPELL_WORD_OF_DESTRUCTION,
+			SPELL_GENOCIDE, -1, -1,
+			-1, -1, -1
+		},
+		{
+			SPELL_RESIST_FIRE, SPELL_RESIST_COLD, SPELL_RESIST_ACID,
+			SPELL_RESIST_POISON, SPELL_RESISTANCE, -1,
+			-1, -1, -1,
+			-1, -1, -1,
+		},
+		{
+			SPELL_DOOR_CREATION, SPELL_STAIR_CREATION, SPELL_TELEPORT_LEVEL,
+			SPELL_EARTHQUAKE, SPELL_WORD_OF_RECALL, -1,
+			-1, -1, -1,
+			-1, -1, -1,
+		},
+		{
+			SPELL_DETECT_EVIL, SPELL_DETECT_ENCHANTMENT, SPELL_RECHARGE_ITEM_3,
+			SPELL_GENOCIDE2, SPELL_MASS_GENOCIDE, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		{
+			SPELL_HEROISM, SPELL_SHIELD, SPELL_BERSERKER,
+			SPELL_ESSENCE_OF_SPEED, SPELL_GLOBE_OF_INVULNERABILITY, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		{
+			SPELL_ACID_BOLT, SPELL_CLOUD_KILL, SPELL_ACID_BALL,
+			SPELL_ICE_STORM, SPELL_METEOR_SWARM, SPELL_MANA_STORM,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+#endif
+		/* Cantrips for Beginners */
+		{
+			SPELL_MAGIC_MISSILE, SPELL_DETECT_MONSTERS, SPELL_PHASE_DOOR, 
+			SPELL_LIGHT_AREA, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Conjurings & Tricks */
+		{
+			SPELL_CURE_LIGHT_WOUNDS, SPELL_FIND_HIDDEN_TRAPS_AND_DOORS, SPELL_STINKING_CLOUD,
+			SPELL_SLEEP, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Incantations & Illusions */
+		{
+			SPELL_TELEPORT_SELF, SPELL_SPEAR_OF_LIGHT, SPELL_TURN_STONE_TO_MUD, 
+			SPELL_SATISFY_HUNGER, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Sorcery & Evocations */
+		{
+			SPELL_RECHARGE_ITEM, SPELL_POLYMORPH_OTHER, SPELL_IDENTIFY,
+			SPELL_FROST_BALL, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Mystic Visions */
+		{
+			SPELL_DETECT_MONSTERS, SPELL_TREASURE_DETECTION, SPELL_OBJECT_DETECTION, 
+			SPELL_FIND_HIDDEN_TRAPS_AND_DOORS, SPELL_DETECT_EVIL, SPELL_DETECT_ENCHANTMENT,
+			SPELL_IDENTIFY, -1, -1,
+			-1, -1, -1
+		},
+		/* Planar Shifts */
+		{
+			SPELL_MAGIC_MISSILE, SPELL_PHASE_DOOR, SPELL_TELEPORT_SELF,
+			SPELL_TELEPORT_LEVEL, SPELL_TELEPORT_OTHER, SPELL_WORD_OF_RECALL,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Enchantment & Creation */
+		{
+			SPELL_LIGHT_AREA, SPELL_DOOR_CREATION, SPELL_TRAP_AND_DOOR_DESTRUCTION,
+			SPELL_SATISFY_HUNGER, SPELL_RECHARGE_ITEM, SPELL_STAIR_CREATION,
+			SPELL_POLYMORPH_OTHER, SPELL_RECHARGE_ITEM_2, SPELL_HASTE_SELF,
+			SPELL_RECHARGE_ITEM_3, -1, -1
+		},
+		/* Elemental Spirits */
+		{
+			SPELL_CURE_LIGHT_WOUNDS, SPELL_STINKING_CLOUD, SPELL_LIGHTNING_BOLT, 
+			SPELL_CURE_POISON, SPELL_SPEAR_OF_LIGHT, SPELL_FROST_BOLT, 
+			SPELL_TURN_STONE_TO_MUD, SPELL_CLOUD_KILL, SPELL_FIRE_BOLT,
+			SPELL_METEOR_SWARM, -1, -1
+		},
+		/* Resistances of Scarabtarices */
+		{
+			SPELL_RESIST_FIRE, SPELL_RESIST_COLD, SPELL_RESIST_ACID,
+			SPELL_RESIST_POISON, SPELL_RESISTANCE, -1,
+			-1, -1, -1,
+			-1, -1, -1,
+		},
+		/* Psychic Projections */
+		{
+			SPELL_CONFUSE_MONSTER, SPELL_SLEEP, SPELL_SLEEP_3, 
+			SPELL_SLOW_MONSTER, SPELL_GENOCIDE, SPELL_WORD_OF_DESTRUCTION, 
+			SPELL_MASS_GENOCIDE, -1, -1,
+			-1, -1, -1
+		},
+		/* Tenser's Transformations */
+		{
+			SPELL_HEROISM, SPELL_SHIELD, SPELL_BERSERKER, 
+			SPELL_ESSENCE_OF_SPEED, SPELL_GLOBE_OF_INVULNERABILITY, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Raal's Tome of Destruction */
+		{
+			SPELL_ACID_BOLT, SPELL_FROST_BALL, SPELL_ACID_BALL, 
+			SPELL_EARTHQUAKE, SPELL_ICE_STORM, SPELL_MANA_STORM, 
+			SPELL_FIRE_BALL, -1, -1,
+			-1, -1, -1
+		},
+	},
+	{
+		/* Priest prayerbooks */
+#if 0
+		{
+			PRAYER_DETECT_EVIL, PRAYER_CURE_LIGHT_WOUNDS, PRAYER_BLESS, 
+			PRAYER_REMOVE_FEAR, PRAYER_CALL_LIGHT, PRAYER_FIND_TRAPS,
+			PRAYER_DETECT_DOORS_AND_STAIRS, PRAYER_SLOW_POISON, -1,
+			-1, -1, -1,
+		},
+		{
+			PRAYER_SCARE_MONSTER, PRAYER_PORTAL, PRAYER_CURE_SERIOUS_WOUNDS,
+			PRAYER_CHANT, PRAYER_SANCTUARY, PRAYER_SATISFY_HUNGER,
+			PRAYER_REMOVE_CURSE, PRAYER_RESIST_HEAT_AND_COLD, -1,
+			-1, -1, -1
+		},
+		{
+			PRAYER_NEUTRALIZE_POISON, PRAYER_ORB_OF_DRAINING, PRAYER_CURE_CRITICAL_WOUNDS,
+			PRAYER_SENSE_INVISIBLE, PRAYER_PROTECTION_FROM_EVIL, PRAYER_EARTHQUAKE,
+			PRAYER_SENSE_SURROUNDINGS, PRAYER_CURE_MORTAL_WOUNDS, PRAYER_TURN_UNDEAD,
+			-1, -1, -1
+		},
+		{
+			PRAYER_PRAYER, PRAYER_DISPEL_UNDEAD, PRAYER_HEAL, 
+			PRAYER_DISPEL_EVIL, PRAYER_GLYPH_OF_WARDING, PRAYER_HOLY_WORD,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		{
+			PRAYER_BLINK, PRAYER_TELEPORT_SELF, PRAYER_TELEPORT_OTHER,
+			PRAYER_TELEPORT_LEVEL, PRAYER_WORD_OF_RECALL, PRAYER_ALTER_REALITY,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		{
+			PRAYER_DETECT_MONSTERS, PRAYER_DETECTION, PRAYER_PERCEPTION,
+			PRAYER_PROBING, PRAYER_CLAIRVOYANCE, -1,
+			-1, -1, -1,
+		},
+		{
+			PRAYER_CURE_SERIOUS_WOUNDS2, PRAYER_CURE_MORTAL_WOUNDS2, PRAYER_HEALING,
+			PRAYER_RESTORATION, PRAYER_REMEMBERANCE, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		{
+			PRAYER_UNBARRING_WAYS, PRAYER_RECHARGING, PRAYER_DISPEL_CURSE,
+			PRAYER_ENCHANT_WEAPON, PRAYER_ENCHANT_ARMOR, PRAYER_ELEMENTAL_BRAND,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		{
+			PRAYER_DISPEL_UNDEAD2, PRAYER_DISPEL_EVIL2, PRAYER_BANISHMENT,
+			PRAYER_WORD_OF_DESTRUCTION, PRAYER_ANNIHILATION, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		}
+#endif
+		/* Beginners Handbook */
+		{
+			PRAYER_DETECT_EVIL, PRAYER_CURE_LIGHT_WOUNDS, PRAYER_BLESS,
+			PRAYER_CALL_LIGHT, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Words of Wisdom */
+		{
+			PRAYER_DETECT_DOORS_AND_STAIRS, PRAYER_FIND_TRAPS, PRAYER_SLOW_POISON,
+			PRAYER_PORTAL, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Chants and Blessings */
+		{
+			PRAYER_CURE_SERIOUS_WOUNDS, PRAYER_SATISFY_HUNGER, PRAYER_ORB_OF_DRAINING,
+			PRAYER_CURE_CRITICAL_WOUNDS, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Exorcism and Dispelling */
+		{
+			PRAYER_PROTECTION_FROM_EVIL, PRAYER_DISPEL_UNDEAD, PRAYER_HEAL, 
+			PRAYER_GLYPH_OF_WARDING, -1, -1,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Minor Boons */
+		{
+			PRAYER_CURE_LIGHT_WOUNDS, PRAYER_BLESS, PRAYER_REMOVE_FEAR,
+			PRAYER_CALL_LIGHT, PRAYER_SLOW_POISON, PRAYER_SCARE_MONSTER,
+			PRAYER_UNBARRING_WAYS, PRAYER_REMOVE_CURSE, -1,
+			-1, -1, -1
+		},
+		/* Spirit Wards */
+		{
+			PRAYER_DETECT_EVIL, PRAYER_CHANT, PRAYER_RESIST_HEAT_AND_COLD,
+			PRAYER_PROTECTION_FROM_EVIL, PRAYER_TURN_UNDEAD, PRAYER_GLYPH_OF_WARDING,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Ethereal Openings */
+		{
+			PRAYER_BLINK, PRAYER_PORTAL, PRAYER_TELEPORT_SELF,
+			PRAYER_TELEPORT_OTHER, PRAYER_TELEPORT_LEVEL, PRAYER_WORD_OF_RECALL,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Godly Insights */
+		{
+			PRAYER_FIND_TRAPS, PRAYER_DETECT_DOORS_AND_STAIRS, PRAYER_DETECT_MONSTERS, 
+			PRAYER_DETECTION, PRAYER_SENSE_INVISIBLE, PRAYER_SENSE_SURROUNDINGS,
+			PRAYER_PERCEPTION, PRAYER_PROBING, PRAYER_CLAIRVOYANCE,
+			-1, -1, -1
+		},
+		/* Purifications and Healing */
+		{
+			PRAYER_CURE_SERIOUS_WOUNDS, PRAYER_NEUTRALIZE_POISON, PRAYER_CURE_CRITICAL_WOUNDS,
+			PRAYER_CURE_MORTAL_WOUNDS, PRAYER_PRAYER, PRAYER_HEALING,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Angelic Guidance */
+		{
+			PRAYER_SANCTUARY, PRAYER_ORB_OF_DRAINING, PRAYER_DISPEL_UNDEAD,
+			PRAYER_DISPEL_EVIL, PRAYER_RESTORATION, PRAYER_REMEMBERANCE,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Holy Infusions */
+		{
+			PRAYER_SATISFY_HUNGER, PRAYER_RECHARGING, PRAYER_HEAL,
+			PRAYER_ENCHANT_WEAPON, PRAYER_ENCHANT_ARMOR, PRAYER_ELEMENTAL_BRAND,
+			-1, -1, -1,
+			-1, -1, -1
+		},
+		/* Words of Power */
+		{
+			PRAYER_EARTHQUAKE, PRAYER_BANISHMENT, PRAYER_DISPEL_CURSE,
+			PRAYER_WORD_OF_DESTRUCTION, PRAYER_HOLY_WORD, PRAYER_ALTER_REALITY,
+			PRAYER_ANNIHILATION, -1, -1,
+			-1, -1, -1
+		},
+	}
+};
+
+
+/*
+ * Names of the spells (mage spells then priest spells)
+ */
+struct spell_data spells[2][64] =
+{
+	/*** Mage Spells ***/
+
+	{
+		/* Magic for Beginners (sval 0) */
+		{"Magic Missile", {
+			{ 99,  0,  0,   0},
+			{  1,  1, 22,   4},		/* Magic Missile */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  1, 30,   1},
+			{ 99,  0,  0,   0},
+		}},
+		{"Detect Monsters", {
+			{ 99,  0,  0,   0},
+			{  1,  1, 23,   4},		/* Detect Monsters */
+			{ 99,  0,  0,   0},
+			{  5,  1, 50,   1},
+			{  3,  2, 35,   2},
+			{ 99,  0,  0,   0},
+		}},
+		{"Phase Door", {
+			{ 99,  0,  0,   0},
+			{  1,  2, 24,   4},		/* Phase Door */
+			{ 99,  0,  0,   0},
+			{  7,  2, 55,   1},
+			{  3,  2, 35,   2},
+			{ 99,  0,  0,   0},
+		}},
+		{"Light Area", {
+			{ 99,  0,  0,   0},
+			{  1,  2, 26,   4},		/* Light Area */
+			{ 99,  0,  0,   0},
+			{  9,  3, 60,   1},
+			{  5,  3, 35,   1},
+			{ 99,  0,  0,   0},
+		}},
+		{"Treasure Detection", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},		/* Treasure Detection */
+			{ 99,  0,  0,   0},
+			{ 10,  3, 60,   1},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"Cure Light Wounds", {
+			{ 99,  0,  0,   0},
+			{  3,  3, 25,   3},		/* Cure Light Wounds */
+			{ 99,  0,  0,   0},
+			{ 11,  4, 65,   1},
+			{  5,  3, 40,   1},
+			{ 99,  0,  0,   0},
+		}},
+		{"Object Detection", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},		/* Object Detection */
+			{ 99,  0,  0,   0},
+			{ 12,  4, 65,   1},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"Find Hidden Traps/Doors", {
+			{ 99,  0,  0,   0},
+			{  3,  3, 25,   1},		/* Find Hidden Traps/Doors */
+			{ 99,  0,  0,   0},
+			{ 13,  5, 70,   1},
+			{  5,  4, 45,   2},
+			{ 99,  0,  0,   0},
+		}},
+		{"Stinking Cloud", {
+			{ 99,  0,  0,   0},
+			{  3,  3, 27,   3},		/* Stinking Cloud */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  5, 40,   3},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Conjurings and Tricks (sval 1) */
+		{"Confuse Monster", {
+			{ 99,  0,  0,   0},
+			{  3,  4, 30,   1},		/* Confuse Monster */
+			{ 99,  0,  0,   0},
+			{ 15,  6, 75,   1},
+			{  7,  6, 40,   2},
+			{ 99,  0,  0,   0},
+		}},
+		{"Lightning Bolt", {
+			{ 99,  0,  0,   0},
+			{  5,  4, 30,   4},		/* Lightning Bolt */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  7, 40,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Trap/Door Destruction", {
+			{ 99,  0,  0,   0},
+			{  5,  5, 30,   6},		/* Trap/Door Destruction */
+			{ 99,  0,  0,   0},
+			{ 17,  7, 80,   1},
+			{  9,  8, 45,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Sleep I", {
+			{ 99,  0,  0,   0},
+			{  5,  5, 30,   4},		/* Sleep I */
+			{ 99,  0,  0,   0},
+			{ 19,  8, 85,   1},
+			{ 11,  8, 40,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Cure Poison", {
+			{ 99,  0,  0,   0},
+			{  5,  5, 35,   4},		/* Cure Poison */
+			{ 99,  0,  0,   0},
+			{ 21,  9, 90,   1},
+			{ 11,  9, 45,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Teleport Self", {
+			{ 99,  0,  0,   0},
+			{  7,  6, 35,   5},		/* Teleport Self */
+			{ 99,  0,  0,   0},
+			{ 22,  9, 50,   1},
+			{ 13, 10, 45,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Spear of Light", {
+			{ 99,  0,  0,   0},
+			{  7,  6, 30,   5},		/* Spear of Light */
+			{ 99,  0,  0,   0},
+			{ 23, 10, 95,   1},
+			{ 13, 11, 55,   4},
+			{ 99,  0,  0,   0},
+		}},
+		{"Frost Bolt", {
+			{ 99,  0,  0,   0},
+			{  7,  6, 40,   6},		/* Frost Bolt */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 12, 50,   4},
+			{ 99,  0,  0,   0},
+		}},
+		{"Turn Stone to Mud", {
+			{ 99,  0,  0,   0},
+			{  9,  7, 44,   8},		/* Turn Stone to Mud */
+			{ 99,  0,  0,   0},
+			{ 24, 11, 70,   1},
+			{ 15, 13, 50,   4},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Incantations and Illusions (sval 2) */
+		{"Satisfy Hunger", {
+			{ 99,  0,  0,   0},
+			{  9,  7, 45,   8},		/* Satisfy Hunger */
+			{ 99,  0,  0,   0},
+			{ 25, 12, 95,   1},
+			{ 17, 17, 55,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Recharge Item I", {
+			{ 99,  0,  0,   0},
+			{  9,  7, 75,   9},		/* Recharge Item I */
+			{ 99,  0,  0,   0},
+			{ 27, 15, 99,   1},
+			{ 17, 17, 90,   4},
+			{ 99,  0,  0,   0},
+		}},
+		{"Sleep II", {
+			{ 99,  0,  0,   0},
+			{  9,  7, 45,   8},		/* Sleep II */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 21, 17, 55,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Polymorph Other", {
+			{ 99,  0,  0,   0},
+			{ 11,  7, 45,   9},		/* Polymorph Other */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 21, 19, 60,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Identify", {
+			{ 99,  0,  0,   0},
+			{ 11,  7, 75,   6},		/* Identify */
+			{ 99,  0,  0,   0},
+			{ 28, 18, 50,   2},
+			{ 23, 25, 90,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Sleep III", {
+			{ 99,  0,  0,   0},
+			{ 13,  7, 50,   6},		/* Sleep III */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 23, 20, 60,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Fire Bolt", {
+			{ 99,  0,  0,   0},
+			{ 15,  9, 50,   6},		/* Fire Bolt */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 20, 60,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Slow Monster", {
+			{ 99,  0,  0,   0},
+			{ 17,  9, 50,   7},		/* Slow Monster */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 21, 65,   3},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Sorcery and Evocations (sval 3) */
+		{"Frost Ball", {
+			{ 99,  0,  0,   0},
+			{ 19, 12, 55,   8},		/* Frost Ball */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 27, 21, 65,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Recharge Item II", {
+			{ 99,  0,  0,   0},
+			{ 21, 12, 90,   8},		/* Recharge Item II */
+			{ 99,  0,  0,   0},
+			{ 30, 20, 99,   6},
+			{ 29, 23, 95,   3},
+			{ 99,  0,  0,   0},
+		}},
+		{"Teleport Other", {
+			{ 99,  0,  0,   0},
+			{ 23, 12, 60,   8},		/* Teleport Other */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 31, 25, 70,   3},
+			{ 99,  0,  0,   0},
+		}},
+	    {"Haste Self", {
+			{ 99,  0,  0,   0},
+			{ 25, 12, 65,  10},		/* Haste Self */
+			{ 99,  0,  0,   0},
+			{ 32, 25, 70,   6},
+			{ 33, 25, 75,   4},
+			{ 99,  0,  0,   0},
+		}},
+		{"Fire Ball", {
+			{ 99,  0,  0,   0},
+			{ 29, 18, 65,  12},		/* Fire Ball */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 25, 80,   5},
+			{ 99,  0,  0,   0},
+		}},
+		{"Word of Destruction", {
+			{ 99,  0,  0,   0},
+			{ 33, 21, 80,  15},		/* Word of Destruction */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 37, 30, 95,  10},
+			{ 99,  0,  0,   0},
+		}},
+		{"Genocide", {
+			{ 99,  0,  0,   0},
+			{ 37, 25, 95,  21},		/* Genocide */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Mordenkainen's Escapes (sval 5) */
+		{"Door Creation", {
+			{ 99,  0,  0,   0},
+			{  7,  7, 20,  28},		/* Door Creation */
+			{ 99,  0,  0,   0},
+			{  7,  7, 20,  25},
+			{ 8,  17, 20,  25},
+			{ 99,  0,  0,   0},
+		}},
+		{"Stair Creation", {
+			{ 99,  0,  0,   0},
+			{  9, 12, 40,  44},		/* Stair Creation */
+			{ 99,  0,  0,   0},
+			{  9, 12, 40,  45},
+			{ 19, 22, 40,  21},
+			{ 99,  0,  0,   0},
+		}},
+		{"Teleport Level", {
+			{ 99,  0,  0,   0},
+			{ 15, 17, 60,  29},		/* Teleport Level */
+			{ 99,  0,  0,   0},
+			{ 15, 17, 60,  30},
+			{ 25, 27, 60,  17},
+			{ 99,  0,  0,   0},
+		}},
+		{"Earthquake", {
+			{ 99,  0,  0,   0},
+			{ 20, 18, 60,  24},		/* Earthquake */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 28, 60,  16},
+			{ 99,  0,  0,   0},
+		}},
+		{"Word of Recall", {
+			{ 99,  0,  0,   0},
+			{ 25, 25, 75,  19},		/* Word of Recall */
+			{ 99,  0,  0,   0},
+			{ 30, 35, 75,  15},
+			{ 35, 35, 75,  13},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Raal's Tome of Destruction (sval 8) */
+		{"Acid Bolt", {
+			{ 99,  0,  0,   0},
+			{ 10,  6, 50,  12},		/* Acid Bolt */
+			{ 99,  0,  0,   0},
+			{ 13, 16, 50,  10},
+			{ 20, 16, 50,   6},
+			{ 99,  0,  0,   0},
+		}},
+		{"Cloud Kill", {
+			{ 99,  0,  0,   0},
+			{ 12,  9, 60,  16},		/* Cloud Kill */
+			{ 99,  0,  0,   0},
+			{ 18, 20, 60,  10},
+			{ 22, 19, 60,   9},
+			{ 99,  0,  0,   0},
+		}},
+		{"Acid Ball", {
+			{ 99,  0,  0,   0},
+			{ 20, 15, 70,  20},		/* Acid Ball */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 25, 70,  13},
+			{ 99,  0,  0,   0},
+		}},
+		{"Ice Storm", {
+			{ 99,  0,  0,   0},
+			{ 27, 25, 75,  29},		/* Ice Storm */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 33, 35, 75,  25},
+			{ 99,  0,  0,   0},
+		}},
+		{"Meteor Swarm", {
+			{ 99,  0,  0,   0},
+			{ 35, 35, 85,  34},		/* Meteor Swarm */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 45, 85,  35},
+			{ 99,  0,  0,   0},
+		}},
+		{"Mana Storm", {
+			{ 99,  0,  0,   0},
+			{ 42, 45, 95, 200},		/* Mana Storm */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Kelek's Grimoire of Power (sval 6) */
+		{"Detect Evil", {
+			{ 99,  0,  0,   0},
+			{ 5,  5,  50,   8},		/* Detect Evil */
+			{ 99,  0,  0,   0},
+			{  5,  5, 50,  10},
+			{ 10, 15, 50,   4},
+			{ 99,  0,  0,   0},
+		}},
+		{"Detect Enchantment", {
+			{ 99,  0,  0,   0},
+			{ 10, 10, 70,  40},		/* Detect Enchantment */
+			{ 99,  0,  0,   0},
+			{ 10, 10, 70,  40},
+			{ 15, 20, 70,  25},
+			{ 99,  0,  0,   0},
+		}},
+		{"Recharge Item III", {
+			{ 99,  0,  0,   0},
+			{ 25, 30, 95, 160},		/* Recharge Item III */
+			{ 99,  0,  0,   0},
+			{ 35, 40, 95, 100},
+			{ 35, 60, 95, 115},
+			{ 99,  0,  0,   0},
+		}},
+		{"Genocide", {
+			{ 99,  0,  0,   0},
+			{ 30, 50, 70,  40},		/* Genocide */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"Mass Genocide", {
+			{ 99,  0,  0,   0},
+			{ 40, 75, 80, 100},		/* Mass Genocide */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Resistance of Scarabtarices (sval 4) */
+		{"Resist Fire", {
+			{ 99,  0,  0,   0},
+			{  4,  5, 50,  20},		/* Resist Fire */
+			{ 99,  0,  0,   0},
+			{ 10, 12, 50,  40},
+			{ 8, 15,  50,  30},
+			{ 99,  0,  0,   0},
+		}},
+		{"Resist Cold", {
+			{ 99,  0,  0,   0},
+			{  4,  5, 50,  20},		/* Resist Cold */
+			{ 99,  0,  0,   0},
+			{ 10, 12, 50,  40},
+			{ 8, 15,  50,  30},
+			{ 99,  0,  0,   0},
+		}},
+		{"Resist Acid", {
+			{ 99,  0,  0,   0},
+			{  4,  5, 50,  20},		/* Resist Acid */
+			{ 99,  0,  0,   0},
+			{ 10, 12, 50,  40},
+			{ 8, 15,  50,  30},
+			{ 99,  0,  0,   0},
+		}},
+		{"Resist Poison", {
+			{ 99,  0,  0,   0},
+			{  8, 10, 75,  40},		/* Resist Poison */
+			{ 99,  0,  0,   0},
+			{ 15, 20, 75,  60},
+			{ 16, 25, 75,  50},
+			{ 99,  0,  0,   0},
+		}},
+		{"Resistance", {
+			{ 99,  0,  0,   0},
+			{ 15, 20, 85,  60},		/* Resistance */
+			{ 99,  0,  0,   0},
+			{ 25, 30, 85,  80},
+			{ 25, 40, 85,  70},
+			{ 99,  0,  0,   0},
+		}},
+
+		/* Tenser's transformations... (sval 7) */
+		{"Heroism", {
+			{ 99,  0,  0,   0},
+			{  5,  5, 50,  80},		/* Heroism */
+			{ 99,  0,  0,   0},
+			{ 10, 11, 50,  40},
+			{ 10, 15, 50,  40},
+			{ 99,  0,  0,   0},
+		}},
+		{"Shield", {
+			{ 99,  0,  0,   0},
+			{ 10, 12, 75, 120},		/* Shield */
+			{ 99,  0,  0,   0},
+			{ 15, 20, 75,  80},
+			{ 15, 20, 75,  80},
+			{ 99,  0,  0,   0},
+		}},
+		{"Berserker", {
+			{ 99,  0,  0,   0},
+			{ 15, 20, 80, 200},		/* Berserker */
+			{ 99,  0,  0,   0},
+			{ 20, 25, 80, 160},
+			{ 25, 30, 80, 125},
+			{ 99,  0,  0,   0},
+		}},
+		{"Essence of Speed", {
+			{ 99,  0,  0,   0},
+			{ 22, 30, 50, 250},	/* 350 */	/* Essence of Speed */
+			{ 99,  0,  0,   0},
+			{ 26, 30, 50, 250},
+			{ 32, 50, 50, 250},
+			{ 99,  0,  0,   0},
+		}},
+		{"Globe of Invulnerability", {
+			{ 99,  0,  0,   0},
+			{ 45, 70, 75, 250},	/* 450 */	/* Globe of Invulnerability */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		/*
+		{"(blank)",
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}}
+		*/
+	},
+
+
+	/*** Priest Spells ***/
+
+	{
+		/* Beginners Handbook (sval 0) */
+		{"Detect Evil", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  1,  1, 10,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  1,  1, 30,   4},
+		}},
+		{"Cure Light Wounds", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  1,  2, 15,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  2,  2, 35,   4},
+		}},
+		{"Bless", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  1,  2, 20,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  3, 35,   4},
+		}},
+		{"Remove Fear", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  1,  2, 25,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  3, 35,   4},
+		}},
+		{"Call Light", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  2, 25,   1},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  4, 35,   4},
+		}},
+		{"Find Traps", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  3, 27,   2},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  5, 40,   3},
+		}},
+		{"Detect Doors/Stairs", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  3, 27,   2},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  5, 40,   3},
+		}},
+		{"Slow Poison", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  3, 28,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  7, 40,   3},
+		}},
+
+		/* Words of Wisdom (sval 1) */
+		{"Scare Monster", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  4, 29,   3},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  7, 40,   3},
+		}},
+		{"Portal", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  4, 30,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  8, 40,   3},
+		}},
+		{"Cure Serious Wounds", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  4, 32,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 11,  9, 40,   3},
+		}},
+		{"Chant", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  5, 34,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 11, 10, 45,   3},
+		}},
+		{"Sanctuary", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  5, 36,   3},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 11, 10, 45,   3},
+		}},
+		{"Satisfy Hunger", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  5, 38,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 13, 10, 45,   3},
+		}},
+		{"Remove Curse", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  6, 38,   5},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 13, 11, 45,   4},
+		}},
+		{"Resist Heat and Cold", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  7, 38,   5},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 13, 45,   4},
+		}},
+
+		/* Chants and Blessings (sval 2) */
+		{"Neutralize Poison", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  6, 38,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 15, 50,   4},
+		}},
+		{"Orb of Draining", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  7, 38,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 17, 15, 50,   4},
+		}},
+		{"Cure Critical Wounds", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  9,  7, 40,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 17, 15, 50,   4},
+		}},
+		{"Sense Invisible", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 11,  8, 42,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 19, 15, 50,   4},
+		}},
+		{"Protection from Evil", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 11,  8, 42,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 19, 15, 50,   4},
+		}},
+		{"Earthquake", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 11,  9, 55,   5},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 21, 17, 50,   3},
+		}},
+		{"Sense Surroundings", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 13, 10, 45,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 23, 17, 50,   3},
+		}},
+		{"Cure Mortal Wounds", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 13, 11, 45,   4},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 20, 50,   3},
+		}},
+		{"Turn Undead", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 12, 50,   5},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 27, 21, 50,   3},
+		}},
+
+		/* Exorcism and Dispelling (sval 3) */
+		{"Prayer", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 14, 50,   5},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 29, 22, 50,   3},
+		}},
+		{"Dispel Undead", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 17, 14, 55,   7},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 31, 24, 60,   3},
+		}},
+		{"Heal", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 21, 16, 60,   7},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 33, 28, 60,   3},
+		}},
+		{"Dispel Evil", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 20, 70,  12},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 32, 70,   4},
+		}},
+		{"Glyph of Warding", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 33, 55, 90,  15},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 37, 70, 90,   5},
+		}},
+		{"Holy Word", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 39, 32, 95,  20},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 39, 38, 95,  10},
+		}},
+
+		/* Godly Insights... (sval 5) */
+		{"Detect Monsters", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  3, 50,   2},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 5,  5,  50,   1},
+		}},
+		{"Detection", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 10, 10, 80,  20},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 15, 80,  12},
+		}},
+		{"Perception", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 20, 20, 80,  20},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 25, 80,  16},
+		}},
+		{"Probing", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 10, 80, 150},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 15, 80, 135},
+		}},
+		{"Clairvoyance", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 50, 80, 230},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 37, 55, 80, 215},
+		}},
+
+		/* Purifications and Healing (sval 6) */
+		{"Cure Serious Wounds", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15,  5, 50,  25},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 17, 15, 50,  25},
+		}},
+		{"Cure Mortal Wounds", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 17,  7, 60,  45},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 23, 25, 60,  35},
+		}},
+		{"Healing", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 50, 80, 130},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 60, 80, 115},
+		}},
+		{"Restoration", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 70, 90, 230},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 40, 80, 90, 200},
+		}},
+		{"Remembrance", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 70, 90, 250},	/* 350 */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 40, 80, 90, 250},	/* 300 */
+		}},
+
+		/* Wrath of God (sval 8) */
+		{"Dispel Undead", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15,  7, 70,  25},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 20, 13, 70,  20},
+		}},
+		{"Dispel Evil", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 20, 10, 75,  60},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 20, 75,  40},
+		}},
+		{"Banishment", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 25, 80, 250},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 35, 80, 200},
+		}},
+		{"Word of Destruction", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 35, 80, 115},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 40, 40, 80, 100},
+		}},
+		{"Annihilation", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 45, 60, 75, 250},	/* 350 */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 47, 70, 75, 250},	/* 350 */
+		}},
+
+		/* Holy Infusions (sval 7) */
+		{"Unbarring Ways", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  5,  6, 50,  40},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 10, 16, 50,  20},
+		}},
+		{"Recharging", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 15, 20, 80,  25},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 30, 80,  15},
+		}},
+		{"Dispel Curse", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 40, 80, 160},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 50, 80, 130},
+		}},
+		{"Enchant Weapon", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 50, 80, 230},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 40, 70, 80, 200},
+		}},
+		{"Enchant Armour", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 37, 60, 85, 250},	/* 325 */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 42, 80, 85, 250},	/* 285 */
+		}},
+		{"Elemental Brand", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 45, 95, 85, 250},	/* 530 */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 47, 95, 85, 250},	/* 500 */
+		}},
+
+		/* Ethereal openings (sval 4) */
+		{"Blink", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  3,  3, 50,   6},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{  7,  7, 50,   2},
+		}},
+		{"Teleport Self", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 10, 10, 50,   8},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 20, 20, 50,   4},
+		}},
+		{"Teleport Other", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 20, 20, 80,  16},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 25, 25, 80,  12},
+		}},
+		{"Teleport Level", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 30, 40, 75, 133},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 50, 75, 115},
+		}},
+		{"Word of Recall", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 35, 50, 75,  11},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 40, 60, 75,  10},
+		}},
+		{"Alter Reality", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 40, 60, 75, 250},	/* 300 */
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 45, 70, 75, 250},
+		}},
+
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		{"(blank)", {
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}},
+		/*
+		{"(blank)",
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+			{ 99,  0,  0,   0},
+		}}
+		*/
 	}
 };
 
 
@@ -2499,9 +3688,9 @@
 	"birth_preserve",			/* OPT_birth_preserve */
 	"birth_ironman",			/* OPT_birth_ironman */
 	"birth_no_stores",			/* OPT_birth_no_stores */
 	"birth_no_artifacts",		/* OPT_birth_no_artifacts */
-	"birth_rand_artifacts",		/* OPT_birth_rand_artifacts */
+	NULL,						/* xxx */
 	NULL,						/* xxx */
 	NULL,						/* xxx */
 	NULL,						/* xxx */
 	NULL,						/* xxx */
@@ -2563,9 +3752,9 @@
 	"adult_preserve",			/* OPT_adult_preserve */
 	"adult_ironman",			/* OPT_adult_ironman */
 	"adult_no_stores",			/* OPT_adult_no_stores */
 	"adult_no_artifacts",		/* OPT_adult_no_artifacts */
-	"adult_rand_artifacts",		/* OPT_adult_rand_artifacts */
+	NULL,						/* xxx */
 	NULL,						/* xxx */
 	NULL,						/* xxx */
 	NULL,						/* xxx */
 	NULL,						/* xxx */
@@ -2763,9 +3952,9 @@
 	"Birth: Preserve artifacts when leaving level",	/* OPT_birth_preserve */
 	"Birth: Restrict the use of stairs/recall",	/* OPT_birth_ironman */
 	"Birth: Restrict the use of stores/home",	/* OPT_birth_no_stores */
 	"Birth: Restrict creation of artifacts",	/* OPT_birth_no_artifacts */
-	"Birth: Randomize some of the artifacts",	/* OPT_birth_rand_artifacts */
+	NULL,										/* xxx */
 	NULL,										/* xxx */
 	NULL,										/* xxx */
 	NULL,										/* xxx */
 	NULL,										/* xxx */
@@ -2827,9 +4016,9 @@
 	"Adult: Preserve artifacts when leaving level",	/* OPT_adult_preserve */
 	"Adult: Restrict the use of stairs/recall",	/* OPT_adult_ironman */
 	"Adult: Restrict the use of stores/home",	/* OPT_adult_no_stores */
 	"Adult: Restrict creation of artifacts",	/* OPT_adult_no_artifacts */
-	"Adult: Randomize some of the artifacts",	/* OPT_adult_rand_artifacts */
+	NULL,										/* xxx */
 	NULL,										/* xxx */
 	NULL,										/* xxx */
 	NULL,										/* xxx */
 	NULL,										/* xxx */
@@ -2934,9 +4123,9 @@
 	TRUE,		/* OPT_view_perma_grids */
 	FALSE,		/* OPT_view_torch_grids */
 	TRUE,		/* OPT_dungeon_align */
 	TRUE,		/* OPT_dungeon_stair */
-	FALSE,		/* OPT_flow_by_sound */
+	TRUE,		/* OPT_flow_by_sound */
 	FALSE,		/* OPT_flow_by_smell */
 	FALSE,		/* xxx track_follow */
 	FALSE,		/* xxx track_target */
 	FALSE,		/* OPT_smart_learn */
@@ -2964,10 +4153,10 @@
 	FALSE,		/* OPT_center_player */
 	FALSE,		/* OPT_run_avoid_center */
 	FALSE,		/* OPT_scroll_target */
 	FALSE,		/* OPT_auto_more */
-	FALSE,		/* OPT_smart_monsters */
-	FALSE,		/* OPT_smart_packs */
+	TRUE,		/* OPT_smart_monsters */
+	TRUE,		/* OPT_smart_packs */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
@@ -3021,15 +4210,15 @@
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* OPT_birth_point_based */
-	FALSE,		/* OPT_birth_auto_roller */
+	TRUE,		/* OPT_birth_auto_roller */
 	TRUE,		/* OPT_birth_maximize */
 	TRUE,		/* OPT_birth_preserve */
 	FALSE,		/* OPT_birth_ironman */
 	FALSE,		/* OPT_birth_no_stores */
 	FALSE,		/* OPT_birth_no_artifacts */
-	FALSE,		/* OPT_birth_rand_artifacts */
+	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
@@ -3085,15 +4274,15 @@
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* OPT_adult_point_based */
-	FALSE,		/* OPT_adult_auto_roller */
+	TRUE,		/* OPT_adult_auto_roller */
 	TRUE,		/* OPT_adult_maximize */
 	TRUE,		/* OPT_adult_preserve */
 	FALSE,		/* OPT_adult_ironman */
 	FALSE,		/* OPT_adult_no_stores */
 	FALSE,		/* OPT_adult_no_artifacts */
-	FALSE,		/* OPT_adult_rand_artifacts */
+	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
 	FALSE,		/* xxx */
@@ -3268,9 +4457,9 @@
 		OPT_birth_preserve,
 		OPT_birth_ironman,
 		OPT_birth_no_stores,
 		OPT_birth_no_artifacts,
-		OPT_birth_rand_artifacts,
+		255,
 		255,
 		255,
 		255,
 		255,
diff --recursive --unified=4 angband-291/src/types.h antiband/src/types.h
--- angband-291/src/types.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/types.h	Thu Nov 15 01:41:04 2001
@@ -71,8 +71,9 @@
 typedef struct maxima maxima;
 typedef struct feature_type feature_type;
 typedef struct object_kind object_kind;
 typedef struct artifact_type artifact_type;
+typedef struct randart_type randart_type;
 typedef struct ego_item_type ego_item_type;
 typedef struct monster_blow monster_blow;
 typedef struct monster_race monster_race;
 typedef struct monster_lore monster_lore;
@@ -90,8 +91,9 @@
 typedef struct player_class player_class;
 typedef struct hist_type hist_type;
 typedef struct player_other player_other;
 typedef struct player_type player_type;
+typedef struct spell_data spell_data;
 
 
 
 /**** Available structs ****/
@@ -159,8 +161,9 @@
 	u16b f_max;		/* Max size for "f_info[]" */
 	u16b k_max;		/* Max size for "k_info[]" */
 
 	u16b a_max;		/* Max size for "a_info[]" */
+	u16b x_max;		/* Max size for "x_info[]" */
 	u16b e_max;		/* Max size for "e_info[]" */
 
 	u16b r_max;		/* Max size for "r_info[]" */
 	u16b v_max;		/* Max size for "v_info[]" */
@@ -303,8 +306,32 @@
 };
 
 
 /*
+ * Information about "random artifacts"
+ *
+ * This has much less info than artifact_type,
+ * because much of the info is in the object itself
+ */
+struct randart_type
+{
+	char name[20];		/* Name */
+
+	s32b cost;			/* Artifact "cost" */
+
+	u32b flags1;		/* Artifact Flags, set 1 */
+	u32b flags2;		/* Artifact Flags, set 2 */
+	u32b flags3;		/* Artifact Flags, set 3 */
+
+	byte level;			/* Artifact level */
+
+	byte activation;	/* Activation to use */
+	u16b time;			/* Activation time */
+	u16b randtime;		/* Activation time dice */
+};
+
+
+/*
  * Information about "ego-items".
  */
 struct ego_item_type
 {
@@ -528,8 +555,9 @@
 	s16b weight;		/* Item weight */
 
 	byte name1;			/* Artifact type, if any */
 	byte name2;			/* Ego-Item type, if any */
+	byte name3;			/* Randart type, if any */
 
 	byte xtra1;			/* Extra info type */
 	byte xtra2;			/* Extra info index */
 
@@ -706,9 +734,9 @@
 
 
 
 /*
- * The "name" of spell 'N' is stored as spell_names[X][N],
+ * The "name" of spell 'N' is stored as spells[X][N].name,
  * where X is 0 for mage-spells and 1 for priest-spells.
  */
 struct magic_type
 {
@@ -734,9 +762,20 @@
 
 	s16b spell_first;		/* Level of first spell */
 	s16b spell_weight;		/* Weight that hurts spells */
 
+#if 0
 	magic_type info[64];	/* The available spells */
+#endif
+};
+
+/*
+ * Information about a spell
+ */
+struct spell_data
+{
+	cptr name;
+	magic_type casters[MAX_CLASS];
 };
 
 
 
@@ -1076,8 +1116,13 @@
 	bool resist_fire;	/* Resist fire */
 	bool resist_cold;	/* Resist cold */
 	bool resist_pois;	/* Resist poison */
 
+	bool xresist_acid;	/* Resist acid */
+	bool xresist_elec;	/* Resist lightning */
+	bool xresist_fire;	/* Resist fire */
+	bool xresist_cold;	/* Resist cold */
+
 	bool resist_fear;	/* Resist fear */
 	bool resist_lite;	/* Resist light */
 	bool resist_dark;	/* Resist darkness */
 	bool resist_blind;	/* Resist blindness */
@@ -1103,8 +1148,12 @@
 	bool telepathy;		/* Telepathy */
 	bool see_inv;		/* See invisible */
 	bool free_act;		/* Free action */
 	bool hold_life;		/* Hold life */
+
+	bool nethr_brand;	/* Life draining blows */
+	bool nexus_brand;	/* Teleport blows */
+	bool chaos_brand;	/* Polymorph blows */
 
 	bool impact;		/* Earthquake blows */
 	bool aggravate;		/* Aggravate monsters */
 	bool teleport;		/* Random teleporting */
diff --recursive --unified=4 angband-291/src/variable.c antiband/src/variable.c
--- angband-291/src/variable.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/variable.c	Thu Nov  1 18:18:48 2001
@@ -534,8 +534,13 @@
 char *a_name;
 char *a_text;
 
 /*
+ * The randart array
+ */
+randart_type *x_info;
+
+/*
  * The ego-item arrays
  */
 header *e_head;
 ego_item_type *e_info;
diff --recursive --unified=4 angband-291/src/wizard1.c antiband/src/wizard1.c
--- angband-291/src/wizard1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/wizard1.c	Tue Oct 30 11:10:48 2001
@@ -486,8 +486,11 @@
  * Elemental brands for weapons
  */
 static flag_desc brand_flags_desc[] =
 {
+	{ TR1_BRAND_NETHR,		  "Nether Brand" },
+	{ TR1_BRAND_NEXUS,		  "Nexus Brand" },
+	{ TR1_BRAND_CHAOS,		  "Chaos Brand" },
 	{ TR1_BRAND_ACID,         "Acid Brand" },
 	{ TR1_BRAND_ELEC,         "Lightning Brand" },
 	{ TR1_BRAND_FIRE,         "Flame Tongue" },
 	{ TR1_BRAND_COLD,         "Frost Brand" },
@@ -562,9 +565,9 @@
 	{ TR3_HOLD_LIFE,          "Hold Life" },
 	{ TR3_BLESSED,            "Blessed Blade" },
 	{ TR3_IMPACT,             "Earthquake impact on hit" },
 	{ TR3_AGGRAVATE,          "Aggravates" },
-	{ TR3_DRAIN_EXP,          "Drains Experience" }
+	{ TR3_DRAIN_EXP,          "Drains Experience" },
 };
 
 /*
  * A special type used just for deailing with pvals
@@ -927,8 +930,10 @@
  */
 
 static void object_analyze(object_type *o_ptr, obj_desc_list *desc_x_ptr)
 {
+	static char buffer[80];
+
 	analyze_general(o_ptr, desc_x_ptr->description);
 
 	analyze_pval(o_ptr, &desc_x_ptr->pval_info);
 
@@ -945,18 +950,18 @@
 	analyze_misc_magic(o_ptr, desc_x_ptr->misc_magic);
 
 	analyze_misc(o_ptr, desc_x_ptr->misc_desc);
 
-	desc_x_ptr->activation = item_activation(o_ptr);
+	desc_x_ptr->activation = item_activation(o_ptr, buffer);
 }
 
 
 static void print_header(void)
 {
 	char buf[80];
 
-	sprintf(buf, "Artifact Spoilers for Angband Version %d.%d.%d",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	sprintf(buf, "Artifact Spoilers for Antiband Version %d.%d.%d",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	spoiler_underline(buf);
 }
 
 /*
@@ -1169,8 +1174,12 @@
 	o_ptr->to_h = a_ptr->to_h;
 	o_ptr->to_d = a_ptr->to_d;
 	o_ptr->weight = a_ptr->weight;
 
+	/* Curse it if needed */
+	if (a_ptr->flags3 & TR3_LIGHT_CURSE)
+		o_ptr->ident |= IDENT_CURSED;
+
 	/* Success */
 	return (TRUE);
 }
 
@@ -1297,10 +1306,10 @@
 		return;
 	}
 
 	/* Dump the header */
-	fprintf(fff, "Monster Spoilers for Angband Version %d.%d.%d\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	fprintf(fff, "Monster Spoilers for Antiband Version %d.%d.%d\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	fprintf(fff, "------------------------------------------\n\n");
 
 	/* Dump the header */
 	fprintf(fff, "%-40.40s%4s%4s%6s%8s%4s  %11.11s\n",
@@ -1529,10 +1538,10 @@
 	}
 
 
 	/* Dump the header */
-	sprintf(buf, "Monster Spoilers for Angband Version %d.%d.%d\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	sprintf(buf, "Monster Spoilers for Antiband Version %d.%d.%d\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	spoil_out(buf);
 	spoil_out("------------------------------------------\n\n");
 
 	/* Allocate the "who" array */
@@ -1726,9 +1735,9 @@
 
 		/* Collect inate attacks */
 		vn = 0;
 		if (flags4 & (RF4_SHRIEK)) vp[vn++] = "shriek for help";
-		if (flags4 & (RF4_XXX2)) vp[vn++] = "do something";
+		if (flags4 & (RF4_SCREAM)) vp[vn++] = "scream for help";
 		if (flags4 & (RF4_XXX3)) vp[vn++] = "do something";
 		if (flags4 & (RF4_XXX4)) vp[vn++] = "do something";
 		if (flags4 & (RF4_ARROW_1)) vp[vn++] = "fire arrows";
 		if (flags4 & (RF4_ARROW_2)) vp[vn++] = "fire arrows";
diff --recursive --unified=4 angband-291/src/wizard2.c antiband/src/wizard2.c
--- angband-291/src/wizard2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/wizard2.c	Sun Nov  4 13:34:40 2001
@@ -150,9 +150,9 @@
 	/* Query the stats */
 	for (i = 0; i < A_MAX; i++)
 	{
 		/* Prompt */
-		sprintf(ppp, "%s (3-118): ", stat_names[i]);
+		sprintf(ppp, "%s (3-%i): ", stat_names[i], p_ptr->stat_lim[i]);
 
 		/* Default */
 		sprintf(tmp_val, "%d", p_ptr->stat_max[i]);
 
@@ -162,9 +162,9 @@
 		/* Extract */
 		tmp_int = atoi(tmp_val);
 
 		/* Verify */
-		if (tmp_int > 18+100) tmp_int = 18+100;
+		if (tmp_int > p_ptr->stat_lim[i]) tmp_int = p_ptr->stat_lim[i];
 		else if (tmp_int < 3) tmp_int = 3;
 
 		/* Save it */
 		p_ptr->stat_cur[i] = p_ptr->stat_max[i] = tmp_int;
@@ -627,24 +627,27 @@
 
 		/* Apply normal magic, but first clear object */
 		else if (ch == 'n' || ch == 'N')
 		{
+			if (i_ptr->name3) x_info[i_ptr->name3].name[0] = 0;
 			object_prep(i_ptr, o_ptr->k_idx);
-			apply_magic(i_ptr, p_ptr->depth, FALSE, FALSE, FALSE);
+			apply_magic(i_ptr, p_ptr->depth, FALSE, FALSE, FALSE, FALSE);
 		}
 
 		/* Apply good magic, but first clear object */
 		else if (ch == 'g' || ch == 'g')
 		{
+			if (i_ptr->name3) x_info[i_ptr->name3].name[0] = 0;
 			object_prep(i_ptr, o_ptr->k_idx);
-			apply_magic(i_ptr, p_ptr->depth, FALSE, TRUE, FALSE);
+			apply_magic(i_ptr, p_ptr->depth, FALSE, TRUE, FALSE, FALSE);
 		}
 
 		/* Apply great magic, but first clear object */
 		else if (ch == 'e' || ch == 'e')
 		{
+			if (i_ptr->name3) x_info[i_ptr->name3].name[0] = 0;
 			object_prep(i_ptr, o_ptr->k_idx);
-			apply_magic(i_ptr, p_ptr->depth, FALSE, TRUE, TRUE);
+			apply_magic(i_ptr, p_ptr->depth, FALSE, TRUE, TRUE, FALSE);
 		}
 	}
 
 
@@ -784,9 +787,9 @@
 			/* Wipe the object */
 			object_wipe(i_ptr);
 
 			/* Create an object */
-			make_object(i_ptr, good, great);
+			make_object(i_ptr, good, great, FALSE);
 
 
 			/* Mega-Hack -- allow multiple artifacts XXX XXX XXX */
 			if (artifact_p(i_ptr)) a_info[i_ptr->name1].cur_num = 0;
@@ -1034,9 +1037,9 @@
 	/* Create the item */
 	object_prep(i_ptr, k_idx);
 
 	/* Apply magic (no messages, no artifacts) */
-	apply_magic(i_ptr, p_ptr->depth, FALSE, FALSE, FALSE);
+	apply_magic(i_ptr, p_ptr->depth, FALSE, FALSE, FALSE, FALSE);
 
 	/* Drop the object from heaven */
 	drop_near(i_ptr, -1, py, px);
 
@@ -1093,8 +1096,34 @@
 	/* All done */
 	msg_print("Allocated.");
 }
 
+/*
+ * Create a tremendously bogus randart
+ */
+static void create_wiz_randart(void)
+{
+	object_type *i_ptr;
+	object_type object_type_body;
+	int k_idx;
+
+	/* Get local object */
+	i_ptr = &object_type_body;
+
+	/* Wipe the object */
+	object_wipe(i_ptr);
+
+	/* Make a good (or great) object (if possible) */
+	if (!make_object(i_ptr, TRUE, TRUE, TRUE))
+		return;
+
+	/* Drop the randart from heaven */
+	drop_near(i_ptr, -1, p_ptr->py, p_ptr->px);
+
+	/* All done */
+	msg_print("Allocated.");
+}
+
 
 /*
  * Cure everything instantly
  */
@@ -1688,8 +1717,15 @@
 			else
 			{
 				gain_exp(p_ptr->exp + 1);
 			}
+			break;
+		}
+
+		/* Create stupid randart */
+		case 'X':
+		{
+			create_wiz_randart();
 			break;
 		}
 
 		/* Zap Monsters (Genocide) */
diff --recursive --unified=4 angband-291/src/xtra1.c antiband/src/xtra1.c
--- angband-291/src/xtra1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/xtra1.c	Thu Nov 15 01:39:52 2001
@@ -22,9 +22,13 @@
 	if (val > 18)
 	{
 		int bonus = (val - 18);
 
-		if (bonus >= 100)
+		if (bonus > 999)
+		{
+			strcpy(out_val, "18/***");
+		}
+		else if (bonus >= 100)
 		{
 			sprintf(out_val, "18/%03d", bonus);
 		}
 		else
@@ -130,9 +134,9 @@
 		c_put_str(TERM_L_GREEN, tmp, ROW_STAT + stat, COL_STAT + 6);
 	}
 
 	/* Indicate natural maximum */
-	if (p_ptr->stat_max[stat] == 18+100)
+	if (p_ptr->stat_max[stat] == p_ptr->stat_lim[stat])
 	{
 		put_str("!", ROW_STAT + stat, 3);
 	}
 }
@@ -1201,9 +1205,9 @@
 		/* Skip non-spells */
 		if (j >= 99) continue;
 
 		/* Get the spell */
-		s_ptr = &mp_ptr->info[j];
+		s_ptr = &spells[mp_ptr->spell_type][j].casters[p_ptr->pclass];
 
 		/* Skip spells we are allowed to know */
 		if (s_ptr->slevel <= p_ptr->lev) continue;
 
@@ -1233,9 +1237,9 @@
 			}
 
 			/* Message */
 			msg_format("You have forgotten the %s of %s.", p,
-			           spell_names[mp_ptr->spell_type][j]);
+			           spells[mp_ptr->spell_type][j].name);
 
 			/* One more can be learned */
 			p_ptr->new_spells++;
 		}
@@ -1283,9 +1287,9 @@
 			}
 
 			/* Message */
 			msg_format("You have forgotten the %s of %s.", p,
-			           spell_names[mp_ptr->spell_type][j]);
+			           spells[mp_ptr->spell_type][j].name);
 
 			/* One more can be learned */
 			p_ptr->new_spells++;
 		}
@@ -1307,9 +1311,9 @@
 		/* Skip unknown spells */
 		if (j >= 99) break;
 
 		/* Get the spell */
-		s_ptr = &mp_ptr->info[j];
+		s_ptr = &spells[mp_ptr->spell_type][j].casters[p_ptr->pclass];
 
 		/* Skip spells we cannot remember */
 		if (s_ptr->slevel > p_ptr->lev) continue;
 
@@ -1339,9 +1343,9 @@
 			}
 
 			/* Message */
 			msg_format("You have remembered the %s of %s.",
-			           p, spell_names[mp_ptr->spell_type][j]);
+			           p, spells[mp_ptr->spell_type][j].name);
 
 			/* One less can be learned */
 			p_ptr->new_spells--;
 		}
@@ -1354,9 +1358,9 @@
 	/* Count spells that can be learned */
 	for (j = 0; j < 64; j++)
 	{
 		/* Get the spell */
-		s_ptr = &mp_ptr->info[j];
+		s_ptr = &spells[mp_ptr->spell_type][j].casters[p_ptr->pclass];
 
 		/* Skip spells we cannot remember */
 		if (s_ptr->slevel > p_ptr->lev) continue;
 
@@ -1599,11 +1603,8 @@
 
 	/* Assume no light */
 	p_ptr->cur_lite = 0;
 
-	/* Player is glowing */
-	if (p_ptr->lite) p_ptr->cur_lite = 1;
-
 	/* Examine actual lites */
 	if (o_ptr->tval == TV_LITE)
 	{
 		/* Torches (with fuel) provide some lite */
@@ -1621,8 +1622,14 @@
 		/* Artifact Lites provide permanent, bright, lite */
 		if (artifact_p(o_ptr)) p_ptr->cur_lite = 3;
 	}
 
+	/* Player is glowing */
+	if (p_ptr->lite) p_ptr->cur_lite++;
+
+	/* Max radius */
+	/* if (p_ptr->cur_lite > 3) p_ptr->cur_lite = 3; */
+
 	/* Reduce lite when running if requested */
 	if (p_ptr->running && view_reduce_lite)
 	{
 		/* Reduce the lite radius if needed */
@@ -1755,8 +1762,11 @@
 	p_ptr->aggravate = FALSE;
 	p_ptr->teleport = FALSE;
 	p_ptr->exp_drain = FALSE;
 	p_ptr->bless_blade = FALSE;
+	p_ptr->nethr_brand = FALSE;
+	p_ptr->nexus_brand = FALSE;
+	p_ptr->chaos_brand = FALSE;
 	p_ptr->impact = FALSE;
 	p_ptr->see_inv = FALSE;
 	p_ptr->free_act = FALSE;
 	p_ptr->slow_digest = FALSE;
@@ -1790,8 +1800,12 @@
 	p_ptr->immune_acid = FALSE;
 	p_ptr->immune_elec = FALSE;
 	p_ptr->immune_fire = FALSE;
 	p_ptr->immune_cold = FALSE;
+	p_ptr->xresist_acid = FALSE;
+	p_ptr->xresist_elec = FALSE;
+	p_ptr->xresist_fire = FALSE;
+	p_ptr->xresist_cold = FALSE;
 
 
 	/*** Extract race/class info ***/
 
@@ -1832,8 +1846,20 @@
 
 	/* Extract the player flags */
 	player_flags(&f1, &f2, &f3);
 
+	/* Affect speed */
+	if (f1 & (TR1_SPEED)) p_ptr->pspeed += (p_ptr->lev + 4) / 5;
+
+	/* Affect blows */
+	if (f1 & (TR1_BLOWS)) extra_blows += 1 + p_ptr->lev / 20;
+
+	/* Affect shots */
+	if (f1 & (TR1_SHOTS)) extra_shots += 1;
+
+	/* Affect Might */
+	if (f1 & (TR1_MIGHT)) extra_might += 1;
+
 	/* Good flags */
 	if (f3 & (TR3_SLOW_DIGEST)) p_ptr->slow_digest = TRUE;
 	if (f3 & (TR3_FEATHER)) p_ptr->ffall = TRUE;
 	if (f3 & (TR3_LITE)) p_ptr->lite = TRUE;
@@ -1858,12 +1884,12 @@
 	if (f2 & (TR2_IM_COLD)) p_ptr->immune_cold = TRUE;
 	if (f2 & (TR2_IM_ELEC)) p_ptr->immune_elec = TRUE;
 
 	/* Resistance flags */
-	if (f2 & (TR2_RES_ACID)) p_ptr->resist_acid = TRUE;
-	if (f2 & (TR2_RES_ELEC)) p_ptr->resist_elec = TRUE;
-	if (f2 & (TR2_RES_FIRE)) p_ptr->resist_fire = TRUE;
-	if (f2 & (TR2_RES_COLD)) p_ptr->resist_cold = TRUE;
+	if (f2 & (TR2_RES_ACID)) p_ptr->xresist_acid = TRUE;
+	if (f2 & (TR2_RES_ELEC)) p_ptr->xresist_elec = TRUE;
+	if (f2 & (TR2_RES_FIRE)) p_ptr->xresist_fire = TRUE;
+	if (f2 & (TR2_RES_COLD)) p_ptr->xresist_cold = TRUE;
 	if (f2 & (TR2_RES_POIS)) p_ptr->resist_pois = TRUE;
 	if (f2 & (TR2_RES_FEAR)) p_ptr->resist_fear = TRUE;
 	if (f2 & (TR2_RES_LITE)) p_ptr->resist_lite = TRUE;
 	if (f2 & (TR2_RES_DARK)) p_ptr->resist_dark = TRUE;
@@ -1945,13 +1971,22 @@
 
 		/* Weird flags */
 		if (f3 & (TR3_BLESSED)) p_ptr->bless_blade = TRUE;
 
+		/* Weirder flags */
+		if (f1 & (TR1_BRAND_NETHR)) p_ptr->nethr_brand = TRUE;
+		if (f1 & (TR1_BRAND_NEXUS)) p_ptr->nexus_brand = TRUE;
+		if (f1 & (TR1_BRAND_CHAOS)) p_ptr->chaos_brand = TRUE;
+
 		/* Bad flags */
-		if (f3 & (TR3_IMPACT)) p_ptr->impact = TRUE;
-		if (f3 & (TR3_AGGRAVATE)) p_ptr->aggravate = TRUE;
-		if (f3 & (TR3_TELEPORT)) p_ptr->teleport = TRUE;
-		if (f3 & (TR3_DRAIN_EXP)) p_ptr->exp_drain = TRUE;
+		/* ANTIBAND: These only have effect on cursed items, or items cursed by default. */
+		if (cursed_p(o_ptr) || (f3 & TR3_CURSED_MASK))
+		{
+			if (f3 & (TR3_IMPACT)) p_ptr->impact = TRUE;
+			if (f3 & (TR3_AGGRAVATE)) p_ptr->aggravate = TRUE;
+			if (f3 & (TR3_TELEPORT)) p_ptr->teleport = TRUE;
+			if (f3 & (TR3_DRAIN_EXP)) p_ptr->exp_drain = TRUE;
+		}
 
 		/* Immunity flags */
 		if (f2 & (TR2_IM_FIRE)) p_ptr->immune_fire = TRUE;
 		if (f2 & (TR2_IM_ACID)) p_ptr->immune_acid = TRUE;
diff --recursive --unified=4 angband-291/src/xtra2.c antiband/src/xtra2.c
--- angband-291/src/xtra2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/xtra2.c	Sun Nov  4 12:55:04 2001
@@ -1772,10 +1772,10 @@
 static int get_coin_type(monster_race *r_ptr)
 {
 	cptr name = (r_name + r_ptr->name);
 
-	/* Analyze "coin" monsters */
-	if (r_ptr->d_char == '$')
+	/* Analyze "coin" monsters and golems */
+	if (strchr("$g", r_ptr->d_char))
 	{
 		/* Look for textual clues */
 		if (strstr(name, " copper ")) return (2);
 		if (strstr(name, " silver ")) return (5);
@@ -1888,9 +1888,9 @@
 		/* Mega-Hack -- Mark this item as "Grond" */
 		i_ptr->name1 = ART_GROND;
 
 		/* Mega-Hack -- Actually create "Grond" */
-		apply_magic(i_ptr, -1, TRUE, TRUE, TRUE);
+		apply_magic(i_ptr, -1, TRUE, TRUE, TRUE, FALSE);
 
 		/* Drop it in the dungeon */
 		drop_near(i_ptr, -1, y, x);
 
@@ -1904,9 +1904,9 @@
 		/* Mega-Hack -- Mark this item as "Morgoth" */
 		i_ptr->name1 = ART_MORGOTH;
 
 		/* Mega-Hack -- Actually create "Morgoth" */
-		apply_magic(i_ptr, -1, TRUE, TRUE, TRUE);
+		apply_magic(i_ptr, -1, TRUE, TRUE, TRUE, FALSE);
 
 		/* Drop it in the dungeon */
 		drop_near(i_ptr, -1, y, x);
 	}
@@ -1948,9 +1948,9 @@
 		/* Make Object */
 		else
 		{
 			/* Make an object */
-			if (!make_object(i_ptr, good, great)) continue;
+			if (!make_object(i_ptr, good, great, FALSE)) continue;
 
 			/* Assume seen XXX XXX XXX */
 			dump_item++;
 		}
