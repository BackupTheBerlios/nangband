diff [unapplied] from object.txt; a few objects to add

+N:170:Clairvoyance
+G:":d
+I:40:9:0
+W:20:0:3:500
+A:20/3
+F:TELEPATHY | EASY_KNOW

+N:633:the Planes
+G:":d
+I:40:10:0
+W:50:0:3:30000
+A:50/4
+F:SEE_INVIS | REGEN | HOLD_LIFE | RES_NEXUS | RES_DARK | 
+F:IGNORE_ACID | IGNORE_ELEC | IGNORE_FIRE | IGNORE_COLD | EASY_KNOW
+
+N:634:Resist Confusion
+G:":d
+I:40:11:0
+W:30:0:3:750
+A:40/2
+F:RES_CONFU | EASY_KNOW

diff --recursive --unified=4 angband-291/lib/edit/r_info.txt antiband/lib/edit/r_info.txt
--- angband-291/lib/edit/r_info.txt	Tue Jul 25 19:57:47 2000
+++ antiband/lib/edit/r_info.txt	Sat Nov 10 11:35:12 2001
@@ -155,9 +155,9 @@


 # Version stamp (required)

-V:2.9.1
+V:12.9.1


 ##### Non-race (contains the "player" picture) #####

@@ -949,9 +949,9 @@
 B:HIT:HURT:1d4
 B:TOUCH:POISON:2d4
 F:ONLY_GOLD | DROP_1D2 |
 F:COLD_BLOOD | BASH_DOOR |
-F:ANIMAL | IM_POIS |
+F:IM_POIS |
 F:NO_CONF | NO_SLEEP
 D:It is a pile of coins.
 
 N:73:Giant white rat
@@ -1210,9 +1210,9 @@
 B:HIT:HURT:1d6
 B:TOUCH:POISON:2d6
 F:ONLY_GOLD | DROP_60 | DROP_1D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | IM_POIS | NO_CONF | NO_SLEEP
+F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, crawling forward on thousands of tiny legs.
 
 N:96:Snaga
 G:o:U
@@ -1222,8 +1222,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_10 | 
+S:SCREAM
 D:He is one of the many weaker 'slave' orcs, often mistakenly known as a 
 D:goblin.
 
 N:97:Rattlesnake
@@ -1245,8 +1247,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_8 | 
+S:SCREAM
 D:He is often found in huge numbers in deep caves.
 
 N:99:Wood spider
 G:S:U
@@ -1512,8 +1516,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC
+S:1_IN_6 | 
+S:SCREAM
 D:He is a hardy well-weathered survivor.
 
 N:121:Bandit
 G:p:b
@@ -1856,9 +1862,8 @@
 B:HIT:HURT:2d5
 B:TOUCH:POISON:3d5
 F:ONLY_GOLD | DROP_90 | DROP_1D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, crawling forward on thousands of tiny legs.
 
 N:147:Wolf
@@ -2212,8 +2217,10 @@
 F:FRIENDS | 
 F:DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_10 | 
+S:SCREAM
 D:A hideous, smallish giant that is often found near or with orcs.
 
 N:175:Creeping mithril coins
 G:$:B
@@ -2222,9 +2229,8 @@
 B:HIT:HURT:2d5
 B:TOUCH:POISON:3d5
 F:ONLY_GOLD | DROP_90 | DROP_2D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, shambling forward on thousands of tiny legs.
 
 N:176:Illusionist
@@ -2263,8 +2269,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | HURT_LITE
+S:1_IN_6 | 
+S:SCREAM
 D:He is a large orc with powerful arms and deep black skin.
 
 N:179:Ochre jelly
 G:j:U
@@ -2418,8 +2426,10 @@
 F:RAND_25 | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_10 | 
+S:SCREAM
 D:A massive orc-like figure with black skin and powerful arms.
 
 N:191:Magic mushroom patch
 G:,:B
@@ -2481,8 +2491,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC
+S:1_IN_4 | 
+S:SCREAM
 D:He is a hideous deformed cross-breed with man and orc, combining man's 
 D:strength and cunning with orcish evil.
 
 N:196:Giant tarantula
@@ -2729,8 +2741,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | HURT_LITE
+S:1_IN_16 | 
+S:SCREAM
 D:He is green skinned and ugly.
 
 N:215:Nar, the Dwarf
 G:h:y
@@ -2865,9 +2879,9 @@
 W:18:3:0:60
 B:HIT:POISON:3d4
 B:HIT:HURT:2d3
 B:HIT:HURT:2d3
-F:CHAR_MULTI | 
+F:CHAR_MULTI | ATTR_RANDOM |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_6 | 
@@ -2898,8 +2912,10 @@
 F:MALE | 
 F:FORCE_MAXHP | FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | ORC | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:He is a cunning orc of power, as tall as a man, and stronger.  It fears 
 D:little.
 
 N:227:Shagrat, the Orc Captain
@@ -3250,9 +3266,9 @@
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:HURT:2d3
 B:HIT:HURT:2d3
-F:CHAR_MULTI | 
+F:CHAR_MULTI |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_5 | 
@@ -3626,8 +3642,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | HURT_LITE | HURT_ROCK
+S:1_IN_12 | 
+S:SCREAM
 D:He is a giant troll with scabrous black skin.
 
 N:279:Troll priest
 G:T:G
@@ -3733,8 +3751,10 @@
 B:HIT:HURT:3d8
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | GIANT
+S:1_IN_8 | 
+S:SCREAM
 D:A giant orc-like figure with an awesomely muscled frame.
 
 N:288:White wraith
 G:W:w
@@ -3807,9 +3827,8 @@
 B:HIT:HURT:1d12
 B:HIT:HURT:1d12
 F:ONLY_GOLD | DROP_90 | DROP_2D2 | 
 F:COLD_BLOOD | BASH_DOOR | 
-F:ANIMAL | 
 F:IM_POIS | NO_CONF | NO_SLEEP
 D:It is a pile of coins, slithering forward on thousands of tiny legs.
 
 N:293:Algroth
@@ -3821,8 +3840,10 @@
 B:BITE:HURT:1d6
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL
+S:1_IN_8 | 
+S:SCREAM
 D:A powerful troll form.  Venom drips from its needlelike claws.
 
 N:294:Vibration hound
 G:Z:y
@@ -3858,9 +3879,9 @@
 D:A locus of conflicting points coalesce to form the vague shape of a huge 
 D:hound.  Or is it just your imagination?
 
 N:296:Ogre mage
-G:O:r
+G:O:R
 I:110:30d12:20:40:30
 W:27:2:0:300
 B:HIT:HURT:3d8
 B:HIT:HURT:3d8
@@ -4081,8 +4102,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_COLD | HURT_LITE
+S:1_IN_8 | 
+S:SCREAM
 D:He is a white troll with powerfully clawed hands.
 
 N:310:Giant purple worm
 G:w:v
@@ -4134,9 +4157,9 @@
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
 B:HIT:POISON:3d4
-F:CHAR_MULTI | 
+F:CHAR_MULTI | ATTR_RANDOM |
 F:FORCE_SLEEP | NEVER_MOVE | 
 F:EMPTY_MIND | COLD_BLOOD | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_4 | 
@@ -4449,8 +4472,10 @@
 F:MALE | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS | HURT_LITE
+S:1_IN_6 | 
+S:SCREAM
 D:He is a vicious monster, feared for his ferocity.
 
 N:335:Half-troll
 G:T:U
@@ -4464,8 +4489,10 @@
 F:FRIENDS | 
 F:ONLY_ITEM | DROP_90 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:A huge, ugly, half-human in search of plunder.
 
 N:336:Mystic
 G:p:o
@@ -4683,8 +4710,10 @@
 F:FORCE_MAXHP | 
 F:FRIENDS | DROP_60 | 
 F:OPEN_DOOR | BASH_DOOR | 
 F:EVIL | TROLL | IM_COLD | IM_POIS | HURT_LITE
+S:1_IN_10 | 
+S:SCREAM
 D:He is a troll that reeks of brine.
 
 N:349:Fire elemental
 G:E:r
@@ -4909,8 +4938,10 @@
 B:BITE:HURT:2d3
 F:FORCE_MAXHP | OPEN_DOOR | FRIENDS | DROP_60 | 
 F:SMART | BASH_DOOR | 
 F:EVIL | TROLL | IM_POIS
+S:1_IN_6 | 
+S:SCREAM
 D:It is a massive intelligent troll with needle sharp fangs.
 
 N:364:Dagashi
 G:p:y
@@ -6004,9 +6035,8 @@
 I:120:16d10:20:1:0
 W:40:1:0:1500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TPORT | 
 S:S_UNDEAD
@@ -7041,9 +7071,8 @@
 I:120:48d10:20:1:0
 W:51:1:0:3000
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TPORT | 
 S:S_DEMON
@@ -7775,9 +7804,8 @@
 I:120:20d100:20:1:0
 W:71:3:0:12000
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:S_MONSTER | S_MONSTERS | S_UNDEAD | S_DRAGON | S_HI_UNDEAD |
 S:S_HI_DRAGON | S_HI_DEMON
@@ -7788,9 +7816,8 @@
 I:120:15d100:20:1:0
 W:71:3:0:10500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TELE_TO | 
 S:S_HI_DRAGON
@@ -7802,9 +7829,8 @@
 I:120:15d100:20:1:0
 W:71:3:0:10500
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:INVISIBLE | EMPTY_MIND | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BLINK | TELE_TO | 
 S:S_HI_UNDEAD
@@ -7929,9 +7955,8 @@
 F:UNIQUE | 
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:ONLY_ITEM | DROP_4D2 | 
 F:INVISIBLE | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_2 | 
 S:BRAIN_SMASH | 
 S:S_HI_UNDEAD | S_HI_DRAGON | S_HI_DEMON
@@ -7946,9 +7971,8 @@
 F:UNIQUE | 
 F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
 F:ONLY_ITEM | DROP_4D2 | 
 F:INVISIBLE | 
-F:ANIMAL | EVIL | 
 F:NO_CONF | NO_SLEEP | NO_FEAR
 S:1_IN_1 | 
 S:S_MONSTER | S_MONSTERS | S_UNDEAD | S_DEMON | S_DRAGON | S_ANGEL | 
 S:S_HYDRA | S_SPIDER | S_ANT | S_HOUND | S_UNIQUE | S_WRAITH | 
@@ -8250,4 +8274,128 @@
 D:two remaining Silmarils forever burning him.  Grond, the mighty Hammer of 
 D:the Underworld, cries defiance as he strides towards you to crush you to a 
 D:pulp!
 
+N:548:Mimic (chest)
+G:~:s
+I:120:20d80:30:90:5
+W:35:3:0:600
+B:HIT:POISON:8d6
+B:HIT:POISON:8d6
+B:TOUCH:PARALYZE:6d4
+B:TOUCH:PARALYZE:6d4
+F:CHAR_MULTI | 
+F:FORCE_SLEEP | NEVER_MOVE | 
+F:EMPTY_MIND | COLD_BLOOD | 
+F:DROP_2D2 | 
+F:SMART | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_4 | 
+S:BLIND | CONF | BRAIN_SMASH | TELE_TO
+D:A strange creature that disguises itself as discarded objects to lure 
+D:unsuspecting adventurers within reach of its venomous claws.
+
+N:549:Animated armor
+G:[:W
+I:100:60d20:10:150:20
+W:28:4:0:500
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+B:HIT:HURT:6d10
+F:EMPTY_MIND | COLD_BLOOD | BASH_DOOR | 
+F:IM_FIRE | IM_COLD | IM_ELEC | IM_POIS | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+D:It is a huge suit of armor animated by magic.
+
+N:550:Neeker-breeker
+G:I:v
+I:110:1d1:5:0:20
+W:2:6:0:1
+F:WEIRD_MIND | COLD_BLOOD |
+F:MULTIPLY | NO_FEAR | RAND_25 | RAND_50
+S:1_IN_10 |
+S:CONF
+D:You never thought such a small insect could make such noise.
+
+N:551:Psychic quylthulg
+G:Q:v
+I:110:13d10:10:1:0
+W:35:2:0:360
+F:FORCE_SLEEP | NEVER_MOVE | NEVER_BLOW | 
+F:INVISIBLE | WEIRD_MIND | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_1 | 
+S:BLINK | TPORT | BRAIN_SMASH | FORGET | DRAIN_MANA
+D:It is a strange brain-like pulsing mound of flesh.
+
+N:552:Chaos quylthulg
+G:Q:v
+I:120:24d10:20:1:0
+W:45:2:0:1500
+F:ATTR_MULTI | 
+F:FORCE_SLEEP | FORCE_MAXHP | NEVER_MOVE | NEVER_BLOW | 
+F:INVISIBLE | EMPTY_MIND | 
+F:NO_CONF | NO_SLEEP | NO_FEAR
+S:1_IN_2 | 
+S:BLINK | TPORT | BR_CHAO
+D:It is a pulsing flesh mound that changes form as you watch.
+
+N:553:Fire ogre
+G:O:r
+I:110:30d12:20:33:30
+W:28:1:0:70
+B:HIT:FIRE:3d10
+B:HIT:FIRE:3d10
+F:FRIENDS | DROP_60 | 
+F:OPEN_DOOR | BASH_DOOR | 
+F:EVIL | GIANT | IM_FIRE
+S:1_IN_8 | 
+S:SCREAM
+D:A huge ogre covered in dark red fur.
+
+N:554:Faerie dragon
+G:d:v
+I:110:8d10:20:25:15
+W:8:2:0:30
+B:BITE:HURT:1d5
+F:FORCE_MAXHP | FORCE_SLEEP | 
+F:ONLY_GOLD | DROP_90 | 
+F:OPEN_DOOR | BASH_DOOR | 
+F:DRAGON
+S:1_IN_8 | 
+S:BR_LITE | 
+S:HASTE | BLINK | BLIND | CONF | DARKNESS
+D:This tiny dragon appears and disappears in great agitation.
+
+N:555:Quickling
+G:h:W
+I:130:4d6:16:5:3
+W:5:3:0:15
+B:HIT:HURT:1d2
+F:MALE | 
+F:ONLY_GOLD | DROP_90 | 
+F:OPEN_DOOR
+S:1_IN_4 | 
+S:ARROW_1 | MISSILE | BLINK
+D:A tiny elf-like figure moving incredibly quickly.
+
+N:556:Giant slime mold
+G:,:g
+I:100:2d10:5:3:20
+W:1:1:0:2
+B:HIT:HURT:1d4
+B:TOUCH:ACID:1d2
+F:EMPTY_MIND | BASH_DOOR | 
+F:ANIMAL
+D:A giant green blob searching mindlessly for food.
+
+N:557:Carnivorous slime mold
+G:,:y
+I:100:3d8:5:8:20
+W:2:1:0:3
+B:HIT:HURT:1d4
+B:HIT:HURT:1d4
+B:TOUCH:ACID:1d3
+F:EMPTY_MIND | BASH_DOOR | 
+F:ANIMAL
+D:A giant yellow blob searching mindlessly for food.

diff --recursive --unified=4 angband-291/src/cmd2.c antiband/src/cmd2.c
--- angband-291/src/cmd2.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd2.c	Sun Nov  4 12:43:44 2001
@@ -234,9 +234,9 @@
 		/* Otherwise drop an item */
 		else
 		{
 			/* Make an object */
-			if (!make_object(i_ptr, FALSE, FALSE)) continue;
+			if (!make_object(i_ptr, FALSE, FALSE, FALSE)) continue;
 		}

 		/* Drop it in the dungeon */
 		drop_near(i_ptr, -1, y, x);
diff --recursive --unified=4 angband-291/src/cmd5.c antiband/src/cmd5.c
--- angband-291/src/cmd5.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd5.c	Wed Oct 31 16:46:56 2001
@@ -1603,15 +1593,15 @@
 			}
 
 			case 49:
 			{
-				(void)enchant_spell(rand_int(4) + 1, rand_int(4) + 1, 0);
+				(void)enchant_spell(rand_int(4) + 1, rand_int(4) + 1, 0, FALSE);
 				break;
 			}
 
 			case 50:
 			{
-				(void)enchant_spell(0, 0, rand_int(3) + 2);
+				(void)enchant_spell(0, 0, rand_int(3) + 2, FALSE);
 				break;
 			}
 
 			case 51:
diff --recursive --unified=4 angband-291/src/cmd6.c antiband/src/cmd6.c
--- angband-291/src/cmd6.c	Tue Jul 25 19:57:47 2000
+++ antiband/src/cmd6.c	Thu Nov  1 22:42:28 2001
@@ -1221,36 +1223,36 @@
 
 		case SV_SCROLL_ENCHANT_ARMOR:
 		{
 			ident = TRUE;
-			if (!enchant_spell(0, 0, 1)) used_up = FALSE;
+			if (!enchant_spell(0, 0, 1, FALSE)) used_up = FALSE;
 			break;
 		}
 
 		case SV_SCROLL_ENCHANT_WEAPON_TO_HIT:
 		{
-			if (!enchant_spell(1, 0, 0)) used_up = FALSE;
+			if (!enchant_spell(1, 0, 0, FALSE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_ENCHANT_WEAPON_TO_DAM:
 		{
-			if (!enchant_spell(0, 1, 0)) used_up = FALSE;
+			if (!enchant_spell(0, 1, 0, FALSE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_STAR_ENCHANT_ARMOR:
 		{
-			if (!enchant_spell(0, 0, randint(3) + 2)) used_up = FALSE;
+			if (!enchant_spell(0, 0, randint(3) + 2, TRUE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}
 
 		case SV_SCROLL_STAR_ENCHANT_WEAPON:
 		{
-			if (!enchant_spell(randint(3), randint(3), 0)) used_up = FALSE;
+			if (!enchant_spell(randint(3), randint(3), 0, TRUE)) used_up = FALSE;
 			ident = TRUE;
 			break;
 		}

diff --recursive --unified=4 angband-291/src/externs.h antiband/src/externs.h
--- angband-291/src/externs.h	Tue Jul 25 19:57:49 2000
+++ antiband/src/externs.h	Sun Nov  4 12:55:04 2001
@@ -477,11 +480,11 @@
 extern void object_flags(object_type *o_ptr, u32b *f1, u32b *f2, u32b *f3);
 extern void object_flags_known(object_type *o_ptr, u32b *f1, u32b *f2, u32b *f3);
 extern void object_desc(char *buf, object_type *o_ptr, int pref, int mode);
 extern void object_desc_store(char *buf, object_type *o_ptr, int pref, int mode);
-extern cptr item_activation(object_type *o_ptr);
+extern cptr item_activation(object_type *o_ptr, char *buffer);
 extern int identify_random_gen(object_type *o_ptr, cptr *info, int len);
-extern bool identify_fully_aux(object_type *o_ptr);
+extern bool identify_fully_aux(object_type *o_ptr, char *o_name);
 extern char index_to_label(int i);
 extern s16b label_to_inven(int c);
 extern s16b label_to_equip(int c);
 extern s16b wield_slot(object_type *o_ptr);
diff --recursive --unified=4 angband-291/src/files.c antiband/src/files.c
--- angband-291/src/files.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/files.c	Tue Nov 20 12:09:14 2001
@@ -1222,9 +1222,9 @@
 	char buf[160];
 
 
 	/* Upper middle */
-	col = 26;
+	col = 19;
 
 
 	/* Age */
 	Term_putstr(col, 3, -1, TERM_WHITE, "Age");
@@ -1659,8 +1659,27 @@
 				{
 					c_put_str(TERM_WHITE, "*", row, col+n);
 				}
 
+				/* Check bonus flags */
+				else if ((x == 3) && (f[set] & flag))
+				{
+					byte a;
+					char c;
+
+					if (o_ptr->pval >= 0)
+						a = TERM_L_GREEN;
+					else
+						a = TERM_RED;
+
+					if (ABS(o_ptr->pval) < 10)
+						c = '0' + ABS(o_ptr->pval);
+					else
+						c = '*';
+
+					Term_putch(row, col+n, a, c);
+				}
+
 				/* Check flags */
 				else if (f[set] & flag)
 				{
 					c_put_str(TERM_WHITE, "+", row, col+n);
@@ -1678,10 +1697,19 @@
 
 			/* Default */
 			c_put_str(TERM_SLATE, ".", row, col+n);
 
+			/* Hack - basic resists are special */
+			if ((x == 0) && (y < 4) && (f[set] & flag))
+			{
+				c_put_str(TERM_WHITE, "!", row, col+n);
+			}
+
 			/* Check flags */
-			if (f[set] & flag) c_put_str(TERM_WHITE, "+", row, col+n);
+			else if (f[set] & flag)
+			{
+				c_put_str(TERM_WHITE, "+", row, col+n);
+			}
 
 			/* Advance */
 			row++;
 		}
@@ -1776,20 +1804,24 @@
 	/* Row */
 	row = 3;
 
 	/* Column */
-	col = 42;
+	col = 35;
 
 	/* Print out the labels for the columns */
 	c_put_str(TERM_WHITE, "  Self", row-1, col+5);
 	c_put_str(TERM_WHITE, " RB", row-1, col+12);
 	c_put_str(TERM_WHITE, " CB", row-1, col+16);
 	c_put_str(TERM_WHITE, " EB", row-1, col+20);
 	c_put_str(TERM_WHITE, "  Best", row-1, col+24);
+	c_put_str(TERM_WHITE, " Limit", row-1, col+31);
 
 	/* Display the stats */
 	for (i = 0; i < A_MAX; i++)
 	{
+		int limit;
+		int bonus;
+
 		/* Reduced */
 		if (p_ptr->stat_use[i] < p_ptr->stat_top[i])
 		{
 			/* Use lowercase stat name */
@@ -1803,9 +1835,9 @@
 			put_str(stat_names[i], row+i, col);
 		}
 
 		/* Indicate natural maximum */
-		if (p_ptr->stat_max[i] == 18+100)
+		if (p_ptr->stat_max[i] == p_ptr->stat_lim[i])
 		{
 			put_str("!", row+i, col+3);
 		}
 
@@ -1828,13 +1860,23 @@
 		/* Resulting "modified" maximum value */
 		cnv_stat(p_ptr->stat_top[i], buf);
 		c_put_str(TERM_L_GREEN, buf, row+i, col+24);
 
+		/* Absolute limit */
+		if (adult_maximize)
+			bonus = rp_ptr->r_adj[i] + cp_ptr->c_adj[i];
+		else
+			bonus = 0;
+		limit = modify_stat_value(p_ptr->stat_lim[i], p_ptr->stat_add[i] + bonus);
+
+		cnv_stat(limit, buf);
+		c_put_str(TERM_L_GREEN, buf, row+i, col+31);
+
 		/* Only display stat_use if not maximal */
 		if (p_ptr->stat_use[i] < p_ptr->stat_top[i])
 		{
 			cnv_stat(p_ptr->stat_use[i], buf);
-			c_put_str(TERM_YELLOW, buf, row+i, col+31);
+			c_put_str(TERM_YELLOW, buf, row+i, col+38);
 		}
 	}
 }
 
@@ -1865,9 +1907,9 @@
 	/* Row */
 	row = 3;
 
 	/* Column */
-	col = 26;
+	col = 19;
 
 	/* Header */
 	c_put_str(TERM_WHITE, "abcdefghijkl@", row-1, col);
 
@@ -1957,9 +1999,9 @@
 		Term_putch(col, row+stat, a, c);
 	}
 
 	/* Column */
-	col = 26;
+	col = 19;
 
 	/* Footer */
 	c_put_str(TERM_WHITE, "abcdefghijkl@", row+6, col);
 
@@ -3727,8 +3817,34 @@
 	return (0);
 }
 
 
+/*
+ * Add the current character to the high score file (used by the borg to simulate
+ * a death)
+ */
+errr score_current(void)
+{
+	char buf[1024];
+	errr result;
+
+	/* Build the filename */
+	path_build(buf, 1024, ANGBAND_DIR_APEX, "scores.raw");
+
+	/* Open the high score file, for reading/writing */
+	highscore_fd = fd_open(buf, O_RDWR);
+
+	/* Get time of death */
+	(void)time(&death_time);
+
+	result = enter_score();
+
+	/* Shut the high score file */
+	fd_close(highscore_fd);
+
+	return result;
+}

diff --recursive --unified=4 angband-291/src/generate.c antiband/src/generate.c
--- angband-291/src/generate.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/generate.c	Thu Nov 15 02:19:28 2001
@@ -103,9 +103,9 @@
 /*
  * Dungeon generation values
  */
 #define DUN_ROOMS	50	/* Number of rooms to attempt */
-#define DUN_UNUSUAL	200	/* Level/chance of unusual room */
+#define DUN_UNUSUAL	150	/* Level/chance of unusual room */
 #define DUN_DEST	30	/* 1/chance of having a destroyed level */
 
 /*
  * Dungeon tunnel generation values
@@ -993,30 +993,41 @@
 
 	/* Hack -- Occasional pillar room */
 	if (rand_int(20) == 0)
 	{
-		for (y = y1; y <= y2; y += 2)
+		int pillar_p = 5 + rand_int(20);
+
+		for (y = y1 + 1; y <= y2 - 1; y++)
 		{
-			for (x = x1; x <= x2; x += 2)
+			for (x = x1 + 1; x <= x2 - 1; x++)
 			{
-				cave_set_feat(y, x, FEAT_WALL_INNER);
+				if (!cave_naked_bold(y - 1, x - 1)) continue;
+				if (!cave_naked_bold(y - 1, x)) continue;
+				if (!cave_naked_bold(y - 1, x + 1)) continue;
+				if (!cave_naked_bold(y, x - 1)) continue;
+				if (rand_int(100) < ((x == x1 + 1 || y == y1 + 1) ? pillar_p : pillar_p * 2))
+					cave_set_feat(y, x, FEAT_WALL_INNER);
 			}
 		}
 	}
 
 	/* Hack -- Occasional ragged-edge room */
-	else if (rand_int(50) == 0)
+	if (rand_int(50) == 0)
 	{
-		for (y = y1 + 2; y <= y2 - 2; y += 2)
+		for (y = y1 + 2; y <= y2 - 2; y++)
 		{
-			cave_set_feat(y, x1, FEAT_WALL_INNER);
-			cave_set_feat(y, x2, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y, x1, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y, x2, FEAT_WALL_INNER);
 		}
 
-		for (x = x1 + 2; x <= x2 - 2; x += 2)
+		for (x = x1 + 2; x <= x2 - 2; x++)
 		{
-			cave_set_feat(y1, x, FEAT_WALL_INNER);
-			cave_set_feat(y2, x, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y1, x, FEAT_WALL_INNER);
+			if (rand_int(100) < 50)
+				cave_set_feat(y2, x, FEAT_WALL_INNER);
 		}
 	}
 }
 
@@ -1377,20 +1388,20 @@
 			break;
 		}
 
 
-		/* An inner room with a checkerboard */
+		/* An inner room with an odd layout */
 		case 4:
 		{
 			/* Open the inner room with a secret door */
 			generate_hole(y1-1, x1-1, y2+1, x2+1, FEAT_SECRET);
 
-			/* Checkerboard */
+			/* Random */
 			for (y = y1; y <= y2; y++)
 			{
 				for (x = x1; x <= x2; x++)
 				{
-					if ((x + y) & 0x01)
+					if (rand_int(100) < 40)
 					{
 						cave_set_feat(y, x, FEAT_WALL_INNER);
 					}
 				}
@@ -1500,8 +1511,25 @@
 	/* Okay */
 	return (TRUE);
 }
 
+/*
+ * Helper function for "monster nest (kennel)"
+ */
+static bool vault_aux_kennel(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require canine or hound */
+	if (!strchr("CZ", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
 
 /*
  * Helper function for "monster nest (undead)"
  */
@@ -1518,8 +1546,83 @@
 	/* Okay */
 	return (TRUE);
 }
 
+/*
+ * Helper function for "monster nest (terrarium)"
+ */
+static bool vault_aux_terrarium(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require reptile */
+	if (!strchr("JRM", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (elemental)"
+ */
+static bool vault_aux_elemental(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require elemental or vortex */
+	if (!strchr("Ev", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (hive)"
+ */
+static bool vault_aux_hive(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require insect or spider */
+	if (!strchr("FSIlcaK", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster nest (greater dragon)"
+ */
+static bool vault_aux_greater_dragon(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Require greater dragon */
+	if (!strchr("D", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
 
 /*
  * Helper function for "monster pit (orc)"
  */
@@ -1538,8 +1641,26 @@
 }
 
 
 /*
+ * Helper function for "monster pit (yeek)"
+ */
+static bool vault_aux_yeek(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "y" monsters */
+	if (!strchr("y", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+/*
  * Helper function for "monster pit (troll)"
  */
 static bool vault_aux_troll(int r_idx)
 {
@@ -1620,8 +1741,103 @@
 
 
 
 /*
+ * Helper function for "monster pit (human)"
+ */
+static bool vault_aux_human(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "p" monsters */
+	if (!strchr("p", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (mimic)"
+ */
+static bool vault_aux_mimic(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require mimic monsters */
+	if (!strchr("$?!=~[", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (ogre)"
+ */
+static bool vault_aux_ogre(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require ogre */
+	if (!strchr("O", r_ptr->d_char)) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (chapel)"
+ */
+static bool vault_aux_chapel(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require "A" monsters or priests */
+	if (!strchr("A", r_ptr->d_char) && !strstr((r_name + r_ptr->name), "riest")) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
+ * Helper function for "monster pit (dark elf)"
+ */
+static bool vault_aux_dark_elf(int r_idx)
+{
+	monster_race *r_ptr = &r_info[r_idx];
+
+	/* Decline unique monsters */
+	if (r_ptr->flags1 & (RF1_UNIQUE)) return (FALSE);
+
+	/* Hack -- Require dark elves */
+	if (!strstr((r_name + r_ptr->name), "ark el")) return (FALSE);
+
+	/* Okay */
+	return (TRUE);
+}
+
+
+
+/*
  * Type 5 -- Monster nests
  *
  * A monster nest is a "big" room, with an "inner" room, containing
  * a "collection" of monsters of a given type strewn about the room.
@@ -1691,38 +1907,102 @@
 
 	/* Hack -- Choose a nest type */
 	tmp = randint(p_ptr->depth);
 
+	/* Sometimes boost depth */
+	while (rand_int(5) == 0)
+		tmp += randint(10);
+
+	/* Monster nest (hive) */
+	if (tmp < 10)
+	{
+		/* Describe */
+		name = "hive";
+
+		/* Restrict to insect */
+		get_mon_num_hook = vault_aux_hive;
+	}
+
 	/* Monster nest (jelly) */
-	if (tmp < 30)
+	else if (tmp < 15)
 	{
 		/* Describe */
 		name = "jelly";
 
 		/* Restrict to jelly */
 		get_mon_num_hook = vault_aux_jelly;
 	}
 
+	/* Monster nest (terrarium) */
+	else if (tmp < 20)
+	{
+		/* Describe */
+		name = "terrarium";
+
+		/* Restrict to reptiles */
+		get_mon_num_hook = vault_aux_terrarium;
+	}
+
+	/* Monster nest (mimic) */
+	else if (tmp < 25)
+	{
+		/* Message */
+		name = "mimic";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_mimic;
+	}
+	
 	/* Monster nest (animal) */
-	else if (tmp < 50)
+	else if (tmp < 35)
 	{
 		/* Describe */
 		name = "animal";
 
 		/* Restrict to animal */
 		get_mon_num_hook = vault_aux_animal;
 	}
 
+	/* Monster nest (kennel) */
+	else if (tmp < 40)
+	{
+		/* Describe */
+		name = "kennel";
+
+		/* Restrict to kennel */
+		get_mon_num_hook = vault_aux_kennel;
+	}
+
+	/* Monster nest (elemental) */
+	else if (tmp < 45)
+	{
+		/* Describe */
+		name = "elemental";
+
+		/* Restrict to elemental */
+		get_mon_num_hook = vault_aux_elemental;
+	}
+
 	/* Monster nest (undead) */
-	else
+	else if (tmp < 70)
 	{
 		/* Describe */
 		name = "undead";
 
 		/* Restrict to undead */
 		get_mon_num_hook = vault_aux_undead;
 	}
 
+	/* Monster nest (greater dragon) */
+	else
+	{
+		/* Describe */
+		name = "greater dragon";
+
+		/* Restrict to greater dragons */
+		get_mon_num_hook = vault_aux_greater_dragon;
+	}
+
 	/* Prepare allocation table */
 	get_mon_num_prep();
 
 
@@ -1756,9 +2036,9 @@
 	}
 
 
 	/* Increase the level rating */
-	rating += 10;
+	/* rating += 10; */
 
 	/* (Sometimes) Cause a "special feeling" (for "Monster Nests") */
 	if ((p_ptr->depth <= 40) &&
 	    (randint(p_ptr->depth * p_ptr->depth + 1) < 300))
@@ -1870,18 +2150,62 @@
 
 	/* Choose a pit type */
 	tmp = randint(p_ptr->depth);
 
+	/* Sometimes boost depth */
+	while (rand_int(5) == 0)
+		tmp += randint(10);
+
+	/* Yeek pit */
+	if (tmp < 3)
+	{
+		/* Message */
+		name = "yeek";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_yeek;
+	}
+
 	/* Orc pit */
-	if (tmp < 20)
+	else if (tmp < 20)
 	{
 		/* Message */
 		name = "orc";
 
 		/* Restrict monster selection */
 		get_mon_num_hook = vault_aux_orc;
 	}
 
+	/* Ogre pit */
+	else if (tmp < 25)
+	{
+		/* Message */
+		name = "ogre";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_ogre;
+	}
+
+	/* Human pit */
+	else if (tmp < 30)
+	{
+		/* Message */
+		name = "human";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_human;
+	}
+
+	/* Dark elf pit */
+	else if (tmp < 35)
+	{
+		/* Message */
+		name = "dark elf";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_dark_elf;
+	}
+
 	/* Troll pit */
 	else if (tmp < 40)
 	{
 		/* Message */
@@ -1901,9 +2225,9 @@
 		get_mon_num_hook = vault_aux_giant;
 	}
 
 	/* Dragon pit */
-	else if (tmp < 80)
+	else if (tmp < 75)
 	{
 		/* Pick dragon type */
 		switch (rand_int(6))
 		{
@@ -1992,8 +2316,18 @@
 		/* Restrict monster selection */
 		get_mon_num_hook = vault_aux_dragon;
 	}
 
+	/* Chapel */
+	else if (tmp < 80)
+	{
+		/* Message */
+		name = "chapel";
+
+		/* Restrict monster selection */
+		get_mon_num_hook = vault_aux_chapel;
+	}
+
 	/* Demon pit */
 	else
 	{
 		/* Message */
@@ -2067,9 +2401,9 @@
 	}
 
 
 	/* Increase the level rating */
-	rating += 10;
+	/* rating += 10; */
 
 	/* (Sometimes) Cause a "special feeling" (for "Monster Pits") */
 	if ((p_ptr->depth <= 40) &&
 	    (randint(p_ptr->depth * p_ptr->depth + 1) < 300))
@@ -2312,9 +2646,9 @@
 		if (v_ptr->typ == 7) break;
 	}
 
 	/* Message */
-	if (cheat_room) msg_print("Lesser Vault");
+	if (cheat_room) msg_format("Lesser Vault (%s)", v_ptr->name + v_name);
 
 	/* Boost the rating */
 	rating += v_ptr->rat;
 
@@ -2348,9 +2682,9 @@
 		if (v_ptr->typ == 8) break;
 	}
 
 	/* Message */
-	if (cheat_room) msg_print("Greater Vault");
+	if (cheat_room) msg_format("Greater Vault (%s)", v_ptr->name + v_name);
 
 	/* Boost the rating */
 	rating += v_ptr->rat;
 
@@ -2728,8 +3062,10 @@
 
 	/* Restrict level */
 	if (p_ptr->depth < room[typ].level) return (FALSE);
 
+	dun->crowded = (z_info->m_max - m_max < 400);
+
 	/* Restrict "crowded" rooms */
 	if (dun->crowded && ((typ == 5) || (typ == 6))) return (FALSE);
 
 	/* Extract blocks */
@@ -2861,8 +3197,16 @@
 
 	/* Build some rooms */
 	for (i = 0; i < DUN_ROOMS; i++)
 	{
+		int unusual = DUN_UNUSUAL;
+
+		/* Generate some interesting levels */
+		if (p_ptr->depth % 7 == 0)
+			unusual = unusual * 4 / 5;
+		if (p_ptr->depth % 13 == 0)
+			unusual = unusual * 3 / 4;
+
 		/* Pick a block for the room */
 		by = rand_int(dun->row_rooms);
 		bx = rand_int(dun->col_rooms);
 
@@ -2886,27 +3230,34 @@
 			continue;
 		}
 
 		/* Attempt an "unusual" room */
-		if (rand_int(DUN_UNUSUAL) < p_ptr->depth)
+		if (rand_int(unusual) < p_ptr->depth)
 		{
 			/* Roll for room type */
 			k = rand_int(100);
 
+			/* Try to fit a greater vault on the level by placing it early */
+			if (i < 2)
+				k = rand_int(35);
+			/* Some extra-interesting levels */
+			else if (p_ptr->depth % 13 == 0)
+				k = rand_int(95 - p_ptr->depth / 13 * 5);
+
 			/* Attempt a very unusual room */
-			if (rand_int(DUN_UNUSUAL) < p_ptr->depth)
+			if (rand_int(unusual) < p_ptr->depth)
 			{
-				/* Type 8 -- Greater vault (10%) */
-				if ((k < 10) && room_build(by, bx, 8)) continue;
+				/* Type 8 -- Greater vault (15%) */
+				if ((k < 15) && room_build(by, bx, 8)) continue;
 
-				/* Type 7 -- Lesser vault (15%) */
-				if ((k < 25) && room_build(by, bx, 7)) continue;
+				/* Type 7 -- Lesser vault (20%) */
+				if ((k < 35) && room_build(by, bx, 7)) continue;
 
-				/* Type 6 -- Monster pit (15%) */
-				if ((k < 40) && room_build(by, bx, 6)) continue;
+				/* Type 6 -- Monster pit (20%) */
+				if ((k < 55) && room_build(by, bx, 6)) continue;
 
-				/* Type 5 -- Monster nest (10%) */
-				if ((k < 50) && room_build(by, bx, 5)) continue;
+				/* Type 5 -- Monster nest (15%) */
+				if ((k < 70) && room_build(by, bx, 5)) continue;
 			}
 
 			/* Type 4 -- Large room (25%) */
 			if ((k < 25) && room_build(by, bx, 4)) continue;
@@ -3026,9 +3377,9 @@
 	/* Place 3 or 4 down stairs near some walls */
 	alloc_stairs(FEAT_MORE, rand_range(3, 4), 3);
 
 	/* Place 1 or 2 up stairs near some walls */
-	alloc_stairs(FEAT_LESS, rand_range(1, 2), 3);
+	alloc_stairs(FEAT_LESS, rand_range(2, 3), 3);
 
 
 	/* Basic "amount" */
 	k = (p_ptr->depth / 3);
@@ -3447,23 +3798,23 @@
 		}
 
 
 		/* Extract the feeling */
-		if (rating > 100) feeling = 2;
-		else if (rating > 80) feeling = 3;
-		else if (rating > 60) feeling = 4;
-		else if (rating > 40) feeling = 5;
-		else if (rating > 30) feeling = 6;
-		else if (rating > 20) feeling = 7;
-		else if (rating > 10) feeling = 8;
+		if (rating > 150) feeling = 2;
+		else if (rating > 120) feeling = 3;
+		else if (rating > 90) feeling = 4;
+		else if (rating > 60) feeling = 5;
+		else if (rating > 45) feeling = 6;
+		else if (rating > 30) feeling = 7;
+		else if (rating > 15) feeling = 8;
 		else if (rating > 0) feeling = 9;
 		else feeling = 10;
 
 		/* Hack -- Have a special feeling sometimes */
 		if (good_item_flag && !adult_preserve) feeling = 1;
 
 		/* It takes 1000 game turns for "feelings" to recharge */
-		if ((turn - old_turn) < 1000) feeling = 0;
+		/* if ((turn - old_turn) < 1000) feeling = 0; */
 
 		/* Hack -- no feeling in the town */
 		if (!p_ptr->depth) feeling = 0;
 
@@ -3490,14 +3841,15 @@
 
 		/* Mega-Hack -- "auto-scum" */
 		if (auto_scum && (num < 100))
 		{
+			int req = 2 * p_ptr->depth;
+
+			if (p_ptr->depth > 20) req = p_ptr->depth + 20;
+			if (req > 90) req = 90;
+
 			/* Require "goodness" */
-			if ((feeling > 9) ||
-			    ((p_ptr->depth >= 5) && (feeling > 8)) ||
-			    ((p_ptr->depth >= 10) && (feeling > 7)) ||
-			    ((p_ptr->depth >= 20) && (feeling > 6)) ||
-			    ((p_ptr->depth >= 40) && (feeling > 5)))
+			if (rating < req)
 			{
 				/* Give message to cheaters */
 				if (cheat_room || cheat_hear ||
 				    cheat_peek || cheat_xtra)

diff --recursive --unified=4 angband-291/src/load2.c antiband/src/load2.c
--- angband-291/src/load2.c	Tue Jul 25 19:57:48 2000
+++ antiband/src/load2.c	Fri Nov  2 12:19:32 2001
@@ -1275,8 +1322,18 @@
 	/* Read the stat info */
 	for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_max[i]);
 	for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_cur[i]);

+	/* Read stat limits */
+	if (older_than(12,9,1))
+	{
+		for (i = 0; i < A_MAX; i++) p_ptr->stat_lim[i] = 18+100;
+	}
+	else
+	{
+		for (i = 0; i < A_MAX; i++) rd_s16b(&p_ptr->stat_lim[i]);
+	}
+
 	strip_bytes(24);	/* oops */

 	rd_s32b(&p_ptr->au);

--- angband-291/src/melee2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/melee2.c	Thu Nov 15 02:26:04 2001
@@ -417,13 +417,10 @@
  * Cast a breath (or ball) attack at the player
  * Pass over any monsters that may be in the way
  * Affect grids, objects, monsters, and the player
  */
-static void breath(int m_idx, int typ, int dam_hp)
+static void breath(int m_idx, int py, int px, int typ, int dam_hp)
 {
-	int py = p_ptr->py;
-	int px = p_ptr->px;
-
 	int rad;
 
 	int flg = PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
 
@@ -437,8 +434,129 @@
 	(void)project(m_idx, rad, py, px, dam_hp, typ, flg);
 }
 
 
+static bool should_wake_friends(int who)
+{
+	int i;
+
+	/* Aggravate everyone nearby */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Skip monsters of a different race (should check 'symbol'?) */
+		if (m_ptr->r_idx != m_list[who].r_idx) continue;
+
+		/* Check for sleeping monsters in los of shouting monster */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			if (m_ptr->csleep)
+			{
+				return TRUE;
+			}
+		}
+	}
+	
+	return FALSE;
+}
+
+static bool pack_indirect_fire_okay(int who, int py, int px)
+{
+	int i;
+
+	/* If the monster has los, it can still try to hit an out-of-range player */
+	if (los(m_list[who].fy, m_list[who].fy, py, px))
+		return TRUE;
+
+	/* Check all monsters of same race */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Skip monsters of a different race (should check 'symbol'?) */
+		if (m_ptr->r_idx != m_list[who].r_idx) continue;
+
+		/* Check for monsters in los who themselves have los to the player */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			if (los(m_ptr->fy, m_ptr->fx, py, px))
+			{
+  				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+
+static bool find_indirect_fire(int who, int *py, int *px)
+{
+	int cur_r, x, y;
+	int fx = m_list[who].fx, fy = m_list[who].fy;
+	int found = 0;
+	int best_x, best_y;
+	int rad;
+
+	monster_type *m_ptr = &m_list[who];
+	monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+	/* Determine the radius of the blast */
+	rad = (r_ptr->flags2 & (RF2_POWERFUL)) ? 3 : 2;
+
+	for (cur_r = 1; cur_r <= rad; cur_r++)
+	{
+		for (y = *py - cur_r; y <= *py + cur_r; y++)
+		{
+			for (x = *px - cur_r; x <= *px + cur_r; x++)
+			{
+				if (!in_bounds(y, x) || !cave_floor_bold(y, x))
+					continue;
+
+				if (distance(*py, *px, y, x) > cur_r)
+					continue;
+
+				if (distance(fy, fx, y, x) > MAX_RANGE)
+					continue;
+
+				if (!projectable(fy, fx, y, x))
+					continue;
+
+				if (rand_int(++found) == 0)
+				{
+					best_x = x;
+					best_y = y;
+				}
+			}
+		}
+
+		if (found > 0)
+		{
+			*px = best_x;
+			*py = best_y;
+			return (TRUE);
+		}
+	}
+
+	return (FALSE);
+}
+
+
 /*
  * Offsets for the spell indices
  */
 #define RF4_OFFSET 32 * 3
@@ -594,15 +712,19 @@
 		/* Keep only the interesting spells */
 		f4 &= f4_mask;
 		f5 &= f5_mask;
 		f6 &= f6_mask;
-
-		/* Anything left? */
-		if (!(f4 || f5 || f6)) return (0);
 	}
 
 #endif /* MONSTER_AI */
 
+	/* Don't try to shout for help if there's none around */
+	if ((f4 & RF4_SCREAM) && !should_wake_friends(m_idx))
+		f4 &= ~RF4_SCREAM;
+
+	/* Anything left? */
+	if (!(f4 || f5 || f6)) return (0);
+
 	/* Extract the "innate" spells */
 	for (i = 0; i < 32; i++)
 	{
 		if (f4 & (1L << i)) spells[num++] = i + RF4_OFFSET;
@@ -755,20 +877,18 @@
 
 #endif /* MONSTER_AI */
 
 
-
 	/* Hack -- require projectable player */
 	if (normal)
 	{
 		/* Check range */
-		if (m_ptr->cdis > MAX_RANGE) return (FALSE);
+		if (m_ptr->cdis > MAX_RANGE) direct = FALSE;
 
 		/* Check path */
-		if (!projectable(m_ptr->fy, m_ptr->fx, py, px)) return (FALSE);
+		if (!projectable(m_ptr->fy, m_ptr->fx, py, px)) direct = FALSE;
 	}
 
-
 	/* Extract the monster level */
 	rlev = ((r_ptr->level >= 1) ? r_ptr->level : 1);
 
 
@@ -789,8 +909,52 @@
 	}
 
 #endif /* MONSTER_AI */
 
+
+#ifdef MONSTER_AI
+
+	if (!direct)
+	{
+#if 0
+		/* Summoners are nasty */
+		if (f4 & (RF4_SUMMON_MASK) ||
+			f5 & (RF5_SUMMON_MASK) ||
+			f6 & (RF6_SUMMON_MASK))
+		{
+			/* Only summon sometimes */
+			if (rand_int(3) != 0) return (FALSE);
+
+			/* Must be nearby */
+			if (m_ptr->cdis > r_ptr->aaf) return (FALSE);
+			if (m_ptr->cdis > MAX_RANGE) return (FALSE);
+
+			x = m_ptr->fx;
+			y = m_ptr->fy;
+		}
+#endif
+		/* Pack monsters can sometimes fire on the player indirectly */
+		if (smart_packs && (r_ptr->flags1 & RF1_GROUP_MASK) &&
+			(f4 & (RF4_INDIRECT_MASK) || 
+			 f5 & (RF5_INDIRECT_MASK) ||
+			 f6 & (RF6_INDIRECT_MASK)) && 
+			pack_indirect_fire_okay(m_idx, py, px))
+		{
+			if (!find_indirect_fire(m_idx, &py, &px)) return (FALSE);
+		}
+		else
+		{
+			return (FALSE);
+		}
+	}
+
+#else /* MONSTER_AI */
+
+	if (!direct) return (FALSE);
+
+#endif /* MONSTER_AI */
+
+
 	/* Hack -- allow "desperate" spells */
 	if ((r_ptr->flags2 & (RF2_SMART)) &&
 	    (m_ptr->hp < m_ptr->maxhp / 10) &&
 	    (rand_int(100) < 50))
@@ -804,8 +968,19 @@
 		if (!f4 && !f5 && !f6) return (FALSE);
 	}
 
 
+	/* Only allow breaths & balls to use indirect fire */
+	if (!direct)
+	{
+		f4 &= (RF4_INDIRECT_MASK) | (RF4_SUMMON_MASK);
+		f5 &= (RF5_INDIRECT_MASK) | (RF5_SUMMON_MASK);
+		f6 &= (RF6_INDIRECT_MASK) | (RF6_SUMMON_MASK);
+
+		if (!f4 && !f5 && !f6) return (FALSE);
+	}
+
+
 #ifdef DRS_SMART_OPTIONS
 
 	/* Remove the "ineffective" spells */
 	remove_bad_spells(m_idx, &f4, &f5, &f6);
@@ -895,11 +1070,14 @@
 			aggravate_monsters(m_idx);
 			break;
 		}
 
-		/* RF4_XXX2X4 */
+		/* RF4_SCREAM */
 		case RF4_OFFSET+1:
 		{
+			disturb(1, 0);
+			msg_format("%^s screams for help.", m_name);
+			wake_monsters(m_idx);
 			break;
 		}
 
 		/* RF4_XXX3X4 */
@@ -959,9 +1137,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes acid.", m_name);
-			breath(m_idx, GF_ACID,
+			breath(m_idx, py, px,  GF_ACID,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_ACID);
 			break;
 		}
@@ -971,9 +1149,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes lightning.", m_name);
-			breath(m_idx, GF_ELEC,
+			breath(m_idx, py, px, GF_ELEC,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_ELEC);
 			break;
 		}
@@ -983,9 +1161,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes fire.", m_name);
-			breath(m_idx, GF_FIRE,
+			breath(m_idx, py, px, GF_FIRE,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_FIRE);
 			break;
 		}
@@ -995,9 +1173,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes frost.", m_name);
-			breath(m_idx, GF_COLD,
+			breath(m_idx, py, px, GF_COLD,
 			       ((m_ptr->hp / 3) > 1600 ? 1600 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_COLD);
 			break;
 		}
@@ -1007,9 +1185,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes gas.", m_name);
-			breath(m_idx, GF_POIS,
+			breath(m_idx, py, px, GF_POIS,
 			       ((m_ptr->hp / 3) > 800 ? 800 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_POIS);
 			break;
 		}
@@ -1019,9 +1197,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes nether.", m_name);
-			breath(m_idx, GF_NETHER,
+			breath(m_idx, py, px, GF_NETHER,
 			       ((m_ptr->hp / 6) > 550 ? 550 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_NETHR);
 			break;
 		}
@@ -1031,9 +1209,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes light.", m_name);
-			breath(m_idx, GF_LITE,
+			breath(m_idx, py, px, GF_LITE,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_LITE);
 			break;
 		}
@@ -1043,9 +1221,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes darkness.", m_name);
-			breath(m_idx, GF_DARK,
+			breath(m_idx, py, px, GF_DARK,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_DARK);
 			break;
 		}
@@ -1055,9 +1233,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes confusion.", m_name);
-			breath(m_idx, GF_CONFUSION,
+			breath(m_idx, py, px, GF_CONFUSION,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_CONFU);
 			break;
 		}
@@ -1067,9 +1245,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes sound.", m_name);
-			breath(m_idx, GF_SOUND,
+			breath(m_idx, py, px, GF_SOUND,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_SOUND);
 			break;
 		}
@@ -1079,9 +1257,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes chaos.", m_name);
-			breath(m_idx, GF_CHAOS,
+			breath(m_idx, py, px, GF_CHAOS,
 			       ((m_ptr->hp / 6) > 600 ? 600 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_CHAOS);
 			break;
 		}
@@ -1091,9 +1269,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes disenchantment.", m_name);
-			breath(m_idx, GF_DISENCHANT,
+			breath(m_idx, py, px, GF_DISENCHANT,
 			       ((m_ptr->hp / 6) > 500 ? 500 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_DISEN);
 			break;
 		}
@@ -1103,9 +1281,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes nexus.", m_name);
-			breath(m_idx, GF_NEXUS,
+			breath(m_idx, py, px, GF_NEXUS,
 			       ((m_ptr->hp / 3) > 250 ? 250 : (m_ptr->hp / 3)));
 			update_smart_learn(m_idx, DRS_RES_NEXUS);
 			break;
 		}
@@ -1115,9 +1293,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes time.", m_name);
-			breath(m_idx, GF_TIME,
+			breath(m_idx, py, px, GF_TIME,
 			       ((m_ptr->hp / 3) > 150 ? 150 : (m_ptr->hp / 3)));
 			break;
 		}
 
@@ -1126,9 +1304,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes inertia.", m_name);
-			breath(m_idx, GF_INERTIA,
+			breath(m_idx, py, px, GF_INERTIA,
 			       ((m_ptr->hp / 6) > 200 ? 200 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1137,9 +1315,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes gravity.", m_name);
-			breath(m_idx, GF_GRAVITY,
+			breath(m_idx, py, px, GF_GRAVITY,
 			       ((m_ptr->hp / 3) > 200 ? 200 : (m_ptr->hp / 3)));
 			break;
 		}
 
@@ -1148,9 +1326,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes shards.", m_name);
-			breath(m_idx, GF_SHARD,
+			breath(m_idx, py, px, GF_SHARD,
 			       ((m_ptr->hp / 6) > 400 ? 400 : (m_ptr->hp / 6)));
 			update_smart_learn(m_idx, DRS_RES_SHARD);
 			break;
 		}
@@ -1160,9 +1338,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes plasma.", m_name);
-			breath(m_idx, GF_PLASMA,
+			breath(m_idx, py, px, GF_PLASMA,
 			       ((m_ptr->hp / 6) > 150 ? 150 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1171,9 +1349,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s breathes.", m_name);
 			else msg_format("%^s breathes force.", m_name);
-			breath(m_idx, GF_FORCE,
+			breath(m_idx, py, px, GF_FORCE,
 			       ((m_ptr->hp / 6) > 200 ? 200 : (m_ptr->hp / 6)));
 			break;
 		}
 
@@ -1215,9 +1393,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts an acid ball.", m_name);
-			breath(m_idx, GF_ACID,
+			breath(m_idx, py, px, GF_ACID,
 			       randint(rlev * 3) + 15);
 			update_smart_learn(m_idx, DRS_RES_ACID);
 			break;
 		}
@@ -1227,9 +1405,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a lightning ball.", m_name);
-			breath(m_idx, GF_ELEC,
+			breath(m_idx, py, px, GF_ELEC,
 			       randint(rlev * 3 / 2) + 8);
 			update_smart_learn(m_idx, DRS_RES_ELEC);
 			break;
 		}
@@ -1239,9 +1417,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a fire ball.", m_name);
-			breath(m_idx, GF_FIRE,
+			breath(m_idx, py, px, GF_FIRE,
 			       randint(rlev * 7 / 2) + 10);
 			update_smart_learn(m_idx, DRS_RES_FIRE);
 			break;
 		}
@@ -1251,9 +1429,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a frost ball.", m_name);
-			breath(m_idx, GF_COLD,
+			breath(m_idx, py, px, GF_COLD,
 			       randint(rlev * 3 / 2) + 10);
 			update_smart_learn(m_idx, DRS_RES_COLD);
 			break;
 		}
@@ -1263,9 +1441,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a stinking cloud.", m_name);
-			breath(m_idx, GF_POIS,
+			breath(m_idx, py, px, GF_POIS,
 			       damroll(12, 2));
 			update_smart_learn(m_idx, DRS_RES_POIS);
 			break;
 		}
@@ -1275,9 +1453,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s casts a nether ball.", m_name);
-			breath(m_idx, GF_NETHER,
+			breath(m_idx, py, px, GF_NETHER,
 			       (50 + damroll(10, 10) + rlev));
 			update_smart_learn(m_idx, DRS_RES_NETHR);
 			break;
 		}
@@ -1288,9 +1466,9 @@
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles.", m_name);
 			else msg_format("%^s gestures fluidly.", m_name);
 			msg_print("You are engulfed in a whirlpool.");
-			breath(m_idx, GF_WATER,
+			breath(m_idx, py, px, GF_WATER,
 			       randint(rlev * 5 / 2) + 50);
 			break;
 		}
 
@@ -1299,9 +1477,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles powerfully.", m_name);
 			else msg_format("%^s invokes a mana storm.", m_name);
-			breath(m_idx, GF_MANA,
+			breath(m_idx, py, px, GF_MANA,
 			       (rlev * 5) + damroll(10, 10));
 			break;
 		}
 
@@ -1310,9 +1488,9 @@
 		{
 			disturb(1, 0);
 			if (blind) msg_format("%^s mumbles powerfully.", m_name);
 			else msg_format("%^s invokes a darkness storm.", m_name);
-			breath(m_idx, GF_DARK,
+			breath(m_idx, py, px, GF_DARK,
 			       (rlev * 5) + damroll(10, 10));
 			update_smart_learn(m_idx, DRS_RES_DARK);
 			break;
 		}
@@ -1793,8 +1971,10 @@
 
 		/* RF6_HEAL */
 		case RF6_OFFSET+2:
 		{
+			int healing;
+
 			disturb(1, 0);
 
 			/* Message */
 			if (blind)
@@ -1806,9 +1986,12 @@
 				msg_format("%^s concentrates on %s wounds.", m_name, m_poss);
 			}
 
 			/* Heal some */
-			m_ptr->hp += (rlev * 6);
+			healing = m_ptr->maxhp * randint(10) / 15;
+			if (healing > rlev * 6) healing = rlev * 6;
+			if (healing < rlev) healing = rlev;
+			m_ptr->hp += healing;
 
 			/* Fully healed */
 			if (m_ptr->hp >= m_ptr->maxhp)
 			{
@@ -2941,8 +3124,9 @@
 
 
 #ifdef MONSTER_AI
 
+#if 0
 	/* Normal animal packs try to get the player out of corridors. */
 	if (smart_packs &&
 	    (r_ptr->flags1 & RF1_FRIENDS) && (r_ptr->flags3 & RF3_ANIMAL) &&
 	    !((r_ptr->flags2 & (RF2_PASS_WALL)) || (r_ptr->flags2 & (RF2_KILL_WALL))))
@@ -2966,8 +3150,9 @@
 			/* Find hiding place */
 			if (find_hiding(m_idx, &y, &x)) done = TRUE;
 		}
 	}
+#endif
 
 #endif /* MONSTER_AI */
 
 	/* Apply fear */
@@ -3002,39 +3187,73 @@
 
 #ifdef MONSTER_AI
 
 	/* Monster groups try to surround the player */
-	if (!done && smart_packs && (r_ptr->flags1 & RF1_FRIENDS))
+	if (!done && smart_packs && (r_ptr->flags1 & RF1_GROUP_MASK))
 	{
-		int i;
+		int i, i2;
+		int tx, ty, tx2, ty2;
+ 		int count = 0, count2;
+		int found = 0;
 
-		/* Find an empty square near the player to fill */
+		/* Count monsters near current position */
 		for (i = 0; i < 8; i++)
 		{
-			/* Pick squares near player (semi-randomly) */
-			y2 = py + ddy_ddd[(m_idx + i) & 7];
-			x2 = px + ddx_ddd[(m_idx + i) & 7];
+			tx = m_ptr->fx + ddx_ddd[i];
+			ty = m_ptr->fy + ddy_ddd[i];
+
+			if (tx == px && ty == py)
+				continue;
 
-			/* Already there? */
-			if ((m_ptr->fy == y2) && (m_ptr->fx == x2))
+			if (cave_m_idx[ty][tx])
 			{
-				/* Attack the player */
-				y2 = py;
-				x2 = px;
+				bool blocked = TRUE;
 
-				break;
-			}
+				/* Check if this monster can reach the player easily */
+				for (i2 = 0; i2 < 8; i2++)
+				{
+					tx2 = tx + ddx_ddd[i2];
+					ty2 = ty + ddy_ddd[i2];
 
-			/* Ignore filled grids */
-			if (!cave_empty_bold(y2, x2)) continue;
+					if (!cave_empty_bold(ty2, tx2))
+						continue;
 
-			/* Try to fill this hole */
-			break;
+					if (ABS(tx2 - px) > 1 || ABS(ty2 - py) > 1)
+						continue;
+
+					blocked = FALSE;
+					break;
+				}
+
+				if (blocked)
+					count++;
+			}
 		}
 
-		/* Extract the new "pseudo-direction" */
-		y = m_ptr->fy - y2;
-		x = m_ptr->fx - x2;
+		if (count)
+		{
+			/* Check options */
+			for (i = 0; i < 8; i++)
+			{
+				tx = m_ptr->fx + ddx_ddd[i];
+				ty = m_ptr->fy + ddy_ddd[i];
+
+				if (tx == px && ty == py)
+					continue;
+
+				if (!cave_empty_bold(ty, tx))
+					continue;
+
+				if (ABS(tx - px) > 1 || ABS(ty - py) > 1)
+					continue;
+
+				if (rand_int(++found) == 0)
+				{
+					y = -ddy_ddd[i];
+					x = -ddx_ddd[i];
+				}
+			}
+		}
 
 		/* Done */
 		done = TRUE;
 	}
diff --recursive --unified=4 angband-291/src/monster2.c antiband/src/monster2.c
--- angband-291/src/monster2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/monster2.c	Thu Nov 15 01:43:34 2001
@@ -415,22 +415,30 @@
 		/* Occasional "nasty" monster */
 		if (rand_int(NASTY_MON) == 0)
 		{
 			/* Pick a level bonus */
-			int d = level / 4 + 2;
+			int d = randint(level / 2 + 3);
+
+			/* Reduce very dangerous monsters a bit */
+			while (d > 5 && rand_int(3) != 0)
+				d--;
 
 			/* Boost the level */
-			level += ((d < 5) ? d : 5);
+			level += d;
 		}
 
 		/* Occasional "nasty" monster */
 		if (rand_int(NASTY_MON) == 0)
 		{
 			/* Pick a level bonus */
-			int d = level / 4 + 2;
+			int d = randint(level / 2 + 3);
+
+			/* Reduce very dangerous monsters a bit */
+			while (d > 5 && rand_int(3) != 0)
+				d--;
 
 			/* Boost the level */
-			level += ((d < 5) ? d : 5);
+			level += d;
 		}
 	}
 
 
@@ -2025,9 +2033,9 @@
 	/* Look for a location */
 	for (i = 0; i < 20; ++i)
 	{
 		/* Pick a distance */
-		int d = (i / 15) + 1;
+		int d = (i / 3) + 3;
 
 		/* Pick a location */
 		scatter(&y, &x, y1, x1, d, 0);
 
diff --recursive --unified=4 angband-291/src/object1.c antiband/src/object1.c
--- angband-291/src/object1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/object1.c	Thu Nov 15 02:17:00 2001


+/*
+ * Fill an array with a description of the item flags.
+ *
+ * "info" must point to a cptr array that is big enough to store all
+ * descriptions.
+ *
+ * Returns the number of lines.
+ *
+ * ToDo: Check the len of the array to prevent buffer overflows
+ * (yes, this is paranoid).
+ *
+ * ToDo: Allow dynamic generation of strings.
+ */
+static bool identify_fully_aux2(object_type *o_ptr, int mode)
+{
+	char buffer[80];
+
+	u32b f1, f2, f3;
+
+	int i;
+
+	int vn;
+	cptr vp[64];
+
+	bool worked = FALSE;
+	bool f;
+	bool has_brand = FALSE;
+	bool has_slay = FALSE;
+
+	/* Calculate average damage */
+	if ((p_ptr->pclass == CLASS_WARRIOR || p_ptr->wizard) &&
+		wield_slot(o_ptr) == INVEN_WIELD)
+	{
+		int dam2;
+
+		dam2 = o_ptr->dd * (o_ptr->ds + 1);
+		if (o_ptr->ident & (IDENT_KNOWN))
+			dam2 += 2 * o_ptr->to_d;
+		if (has_brand)
+			dam2 = dam2 * 3 / 2;
+		dam2 += 2 * p_ptr->to_d;
+
+		roff(format("It does about %i damage on an average hit against ", dam2 / 2));
+		if (has_slay || has_brand)
+			roff("most monsters.  ");
+		else
+			roff("all monsters.  ");
+
+		worked = TRUE;
+	}
+	/* Hack - determine type of ammo needed */
+	if ((p_ptr->pclass == CLASS_RANGER || p_ptr->wizard) &&
+		inventory[INVEN_BOW].number &&
+		o_ptr->tval == TV_SHOT + inventory[INVEN_BOW].sval / 10)
+	{
+		int dam2;
+
+		dam2 = o_ptr->dd * (o_ptr->ds + 1);
+		if (o_ptr->ident & (IDENT_KNOWN))
+			dam2 += 2 * o_ptr->to_d;
+		if (inventory[INVEN_BOW].ident & (IDENT_KNOWN))
+			dam2 += 2 * inventory[INVEN_BOW].to_d;
+
+		roff(format("It does about %i damage with your current missile weapon ", dam2 / 2));
+		if (has_slay || has_brand)
+			roff("on an average shot against most monsters.  ");
+		else
+			roff("on an average shot against all monsters.  ");
+
+		worked = TRUE;
+	}
+
+
+	/* Collect sustains */
+	vn = 0;
+	if (f2 & (TR2_SUST_STR)) vp[vn++] = "strength";
+	if (f2 & (TR2_SUST_INT)) vp[vn++] = "intelligence";
+	if (f2 & (TR2_SUST_WIS)) vp[vn++] = "wisdom";
+	if (f2 & (TR2_SUST_DEX)) vp[vn++] = "dexterity";
+	if (f2 & (TR2_SUST_CON)) vp[vn++] = "constitution";
+	if (f2 & (TR2_SUST_CHR)) vp[vn++] = "charisma";
+	/* Hack - shorten to "all stats" if appropriate */
+	if (vn == 6)
+		roff("It sustains all your stats.  ");
+	else if (vn > 0)
+	{
+		roff("It sustains your ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+

+	/* Collect minor powers */
+	vn = 0;
+	if (f3 & (TR3_SLOW_DIGEST)) vp[vn++] = "slows your metabolism";
+	if (f3 & (TR3_FEATHER))     vp[vn++] = "induces feather falling";
+	if (f3 & (TR3_LITE))        vp[vn++] = "provides permanent light";
+	if (f3 & (TR3_REGEN))       vp[vn++] = "speeds your regenerative powers";
+	if (f3 & (TR3_TELEPATHY))   vp[vn++] = "gives telepathic powers";
+	if (f3 & (TR3_SEE_INVIS))   vp[vn++] = "allows you to see invisible monsters";
+	if (f3 & (TR3_FREE_ACT))    vp[vn++] = "provides immunity to paralysis";
+	if (f3 & (TR3_HOLD_LIFE))   vp[vn++] = "provides resistance to life draining";
+	if (vn > 0)
+	{
+		roff("It ");
+
+		for (i = 0; i < vn; i++)
+		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
+		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	/* Collect curses */
+	vn = 0;
+	if (f3 & (TR3_TELEPORT))  vp[vn++] = "induces random teleportation";
+	if (f3 & (TR3_AGGRAVATE)) vp[vn++] = "aggravates nearby creatures";
+	if (f3 & (TR3_DRAIN_EXP)) vp[vn++] = "drains experience";
+
+	if (vn > 0)
+	{
+		roff("It ");
+
+		for (i = 0; i < vn; i++)
 		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" and ");
 		}
+
+		roff(".  ");
+		worked = TRUE;
+	}
+
+	if (f3 & (TR3_BLESSED))
+	{
+		roff("It has been blessed by the gods.  ");
+		worked = TRUE;
+	}
+
+	if (object_known_p(o_ptr) && cursed_p(o_ptr))
+	{
+		if (f3 & (TR3_PERMA_CURSE))
+			roff("It is permanently cursed.  ");
+		else if (f3 & (TR3_HEAVY_CURSE))
+			roff("It is heavily cursed.  ");
+		else
+			roff("It is cursed.  ");
+		worked = TRUE;
+	}
+
+	/* Collect immunities */
+	vn = 0;
+	if (f3 & (TR3_IGNORE_ACID)) vp[vn++] = "acid";
+	if (f3 & (TR3_IGNORE_ELEC)) vp[vn++] = "electricity";
+	if (f3 & (TR3_IGNORE_FIRE)) vp[vn++] = "fire";
+	if (f3 & (TR3_IGNORE_COLD)) vp[vn++] = "cold";
+	/* Hack - shorten to "the elements" if appropriate */
+	if (vn == 4)
+	{
+		vn = 0;
+		vp[vn++] = "the elements";
+	}
+
+	if (object_known_p(o_ptr) && artifact_p(o_ptr))
+	{
+		roff("It is an artifact.  ");
+		worked = TRUE;
+	}
+	else if (vn > 0)
+	{
+		roff("It cannot be harmed by ");
+
+		for (i = 0; i < vn; i++)
 		{
+			roff(vp[i]);
+			if (i < vn - 2)
+				roff(", ");
+			else if (i < vn - 1)
+				roff(" or ");
 		}
+
+		roff(".  ");
+		worked = TRUE;
 	}
 
+	if (p_ptr->pclass == CLASS_ROGUE || p_ptr->wizard)
+	{
+		s32b value = object_value(o_ptr);

+		if (value > 0)
+			roff(format("It is worth about %i gold.  ", value));
+		else
+			roff("It is worthless.  ");
+
+		worked = TRUE;
+	}
+
+	if (p_ptr->wizard && object_known_p(o_ptr) && (o_ptr->ident & IDENT_MENTAL) && o_ptr->name3)
+	{
+		roff(format("Current power is %i.  ", artifact_power(o_ptr)));
+		worked = TRUE;
+	}
+
+	/* Unknown extra powers (ego-item with random extras or artifact) */
+	if (object_known_p(o_ptr) &&
+		(!(o_ptr->ident & IDENT_MENTAL)) &&
+	    ((o_ptr->xtra1) || artifact_p(o_ptr)))
+	{
+		roff("It has hidden powers.  ");
+		worked = TRUE;
+	}
+
+	/* All done */
+	roff("\n");
+
+
+	/* Return the number of lines */
+	return (worked);
 }
 
+/* XXX XXX XXX Hack */
+static char id_aux3_buffer[80];

+static bool identify_fully_aux3(object_type *o_ptr, int mode, cptr *info, int len)
 {
 	int i = 0;

 	u32b f1, f2, f3;

diff --recursive --unified=4 angband-291/src/randart.c antiband/src/randart.c
--- angband-291/src/randart.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/randart.c	Sun Nov  4 14:21:16 2001
@@ -12,17 +12,17 @@
 #include "angband.h"
 
 
 /*
- * Random artifact generator (randart) by Greg Wooledge.
+ * Random artifact generator (randart) 
+ *
+ * Original code by Greg Wooledge, heavily mutilated by Ross Morgan-Linial
  *
  * Note that the direct use of malloc/free is a bad idea.  XXX XXX XXX
  *
  * The external "names.txt" file was sucked into this file for simplicity.
  */
 
-#ifdef GJW_RANDART
-
 static const char *names_list =
 "adanedhel\n"
 "adurant\n"
 "aeglos\n"
@@ -655,8 +655,11 @@
 	if (t) strcpy(t, s);
 	return t;
 }
 
+/* Hackish */
+static bool probs_built = FALSE;
+
 
 /*
  * Use W. Sheldon Simms' random name generator.  This function builds
  * probability tables which are used later on for letter selection.  It
@@ -706,8 +709,15 @@
 	int tries, lnum, vow;
 	int c_prev, c_cur, c_next;
 	char *cp;
 
+	/* If we haven't built the probability tables, do so now */
+	if (!probs_built)
+	{
+		build_prob(names_list);
+		probs_built = TRUE;
+	}
+
 startover:
 	vow = 0;
 	lnum = 0;
 	tries = 0;
@@ -759,98 +769,28 @@
 
 /*
  * Use W. Sheldon Simms' random name generator.
  */
-static int init_names(void)
+static void name_randart(randart_type *x_ptr)
 {
-	char buf[BUFLEN];
-	size_t name_size;
-	char *a_base;
-	char *a_next;
-	int i;
-
-	/* Temporary space for names, while reading and randomizing them. */
-	char **names;
-	int nnames = 0;
-
-
-	build_prob(names_list);
-
-	/* Allocate the "names" array */
-	/* ToDo: Make sure the memory is freed correctly in case of errors */
-	C_MAKE(names, z_info->a_max, char*);
+	char *cp;
 
-	for (i = 0; i < z_info->a_max; i++)
+	while (1)
 	{
-		char *word = make_word();
+		cp = make_word();
+
+		if (strlen(cp) >= 17)
+			continue;
 
 		if (rand_int(3) == 0)
-			sprintf(buf, "'%s'", word);
+			sprintf(x_ptr->name, "'%s'", cp);
 		else
-			sprintf(buf, "of %s", word);
-		names[i] = my_strdup(buf);
-	}
+			sprintf(x_ptr->name, "of %s", cp);
 
-	/* Special cases -- keep these three names separate. */
-	free(names[ART_POWER - 1]);
-	free(names[ART_GROND - 1]);
-	free(names[ART_MORGOTH - 1]);
-
-	if ((names[ART_POWER - 1] = my_strdup("of Power (The One Ring)")) == NULL)
-	{
-		msg_format("Memory allocation error");
-		return 1;
-	}
-
-	if ((names[ART_GROND - 1] = my_strdup("'Grond'")) == NULL)
-	{
-		msg_format("Memory allocation error");
-		return 1;
-	}
-
-	if ((names[ART_MORGOTH - 1] = my_strdup("of Morgoth")) == NULL)
-	{
-		msg_format("Memory allocation error");
-		return 1;
-	}
-
-	/* Convert our names array into an a_name structure for later use. */
-	name_size = 0;
-
-	for (i = 1; i < z_info->a_max; i++)
-	{
-		name_size += strlen(names[i-1]) + 2;	/* skip first char */
-	}
-
-	C_MAKE(a_base, name_size, char);
-
-	a_next = a_base + 1;	/* skip first char */
-
-	for (i = 1; i < z_info->a_max; i++)
-	{
-		strcpy(a_next, names[i-1]);
-		if (a_info[i].tval > 0)		/* skip unused! */
-			a_info[i].name = a_next - a_base;
-		a_next += strlen(names[i-1]) + 1;
-	}
-
-	/* Free some of our now unneeded memory. */
-	KILL(a_name, char);
-
-	for (i = 0; i < nnames; i++)
-	{
-		free(names[i]);
+		return;
 	}
-
-	/* Free the "names" array */
-	C_KILL(names, z_info->a_max, char*);
-
-	a_name = a_base;
-
-	return 0;
 }
 
-
 /*
  * Calculate the multiplier we'll get with a given bow type.  This is done
  * differently in 2.8.2 than it was in 2.8.1.
  */
@@ -873,107 +813,107 @@
 	return 0;
 }
 
 
+static s32b pval_table[9] = {0, 1, 2, 4, 6, 8, 10, 13, 10000};
+
 /*
  * Evaluate the artifact's overall power level.
  */
-static s32b artifact_power(int a_idx, bool cannot_use_kind_cache)
+s32b artifact_power(object_type *o_ptr)
 {
-	const artifact_type *a_ptr = &a_info[a_idx];
-	s32b p = 0;
+	const randart_type *x_ptr = &x_info[o_ptr->name3];
+	s32b p = 0, b;
 	s16b k_idx;
 	object_kind *k_ptr = NULL;	/* silence the warning */
 	int immunities = 0;
 
-	/* Start with a "power" rating derived from the base item's level. */
-	if (a_idx >= ART_MIN_NORMAL)
-	{
-		if (cannot_use_kind_cache)
-			k_idx = lookup_kind(a_ptr->tval, a_ptr->sval);
-		else
-			k_idx = kinds[a_idx];
+	if (!o_ptr->name3) return 0;
 
-		if (k_idx)
-		{
-			k_ptr = &k_info[k_idx];
-			p = (k_ptr->level + 7) / 8;
-		}
-		/* Otherwise just forget it and use 0. ;-) */
-	}
+	k_idx = o_ptr->k_idx;
+	k_ptr = &k_info[k_idx];
+	p = (k_ptr->level + 7) / 8;
 
 	/* Evaluate certain abilities based on type of object. */
-	switch (a_ptr->tval)
+	switch (o_ptr->tval)
 	{
 		case TV_BOW:
 		{
 			int mult;
 
-			p += (a_ptr->to_d + sign(a_ptr->to_d)) / 2;
-			mult = bow_multiplier(a_ptr->sval);
-			if (a_ptr->flags1 & TR1_MIGHT)
+			p += (o_ptr->to_d + sign(o_ptr->to_d)) / 2;
+			mult = bow_multiplier(o_ptr->sval);
+			if (x_ptr->flags1 & TR1_MIGHT)
 			{
-				if (a_ptr->pval > 3)
+				if (o_ptr->pval > 3)
 				{
 					p += 20000;	/* inhibit */
 					mult = 1;	/* don't overflow */
 				}
 				else
-					mult += a_ptr->pval;
+					mult += o_ptr->pval;
 			}
 			p *= mult;
-			if (a_ptr->flags1 & TR1_SHOTS)
+			if (x_ptr->flags1 & TR1_SHOTS)
 			{
-				if (a_ptr->pval > 3)
+				if (o_ptr->pval > 3)
 					p += 20000;	/* inhibit */
-				else if (a_ptr->pval > 0)
-					p *= (2 * a_ptr->pval);
+				else if (o_ptr->pval > 0)
+					p *= (1 + o_ptr->pval);
 			}
-			p += (a_ptr->to_h + 3 * sign(a_ptr->to_h)) / 4;
-			if (a_ptr->weight < k_ptr->weight) p++;
+			p += (o_ptr->to_h + 3 * sign(o_ptr->to_h)) / 4;
+			if (o_ptr->weight < k_ptr->weight) p++;
 			break;
 		}
 		case TV_DIGGING:
 		case TV_HAFTED:
 		case TV_POLEARM:
 		case TV_SWORD:
+		case TV_SHOT:
+		case TV_ARROW:
+		case TV_BOLT:
 		{
-			p += (a_ptr->dd * a_ptr->ds + 1) / 2;
-			if (a_ptr->flags1 & TR1_SLAY_EVIL) p = (p * 3) / 2;
-			if (a_ptr->flags1 & TR1_KILL_DRAGON) p = (p * 3) / 2;
-			if (a_ptr->flags1 & TR1_SLAY_ANIMAL) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_SLAY_UNDEAD) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_SLAY_DRAGON) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_SLAY_DEMON) p = (p * 5) / 4;
-			if (a_ptr->flags1 & TR1_SLAY_TROLL) p = (p * 5) / 4;
-			if (a_ptr->flags1 & TR1_SLAY_ORC) p = (p * 5) / 4;
-			if (a_ptr->flags1 & TR1_SLAY_GIANT) p = (p * 6) / 5;
-
-			if (a_ptr->flags1 & TR1_BRAND_ACID) p = p * 2;
-			if (a_ptr->flags1 & TR1_BRAND_ELEC) p = (p * 3) / 2;
-			if (a_ptr->flags1 & TR1_BRAND_FIRE) p = (p * 4) / 3;
-			if (a_ptr->flags1 & TR1_BRAND_COLD) p = (p * 4) / 3;
-
-			p += (a_ptr->to_d + 2 * sign(a_ptr->to_d)) / 3;
-			if (a_ptr->to_d > 15) p += (a_ptr->to_d - 14) / 2;
+			p += (o_ptr->dd * (o_ptr->ds + 1)) / 5;
+			p += (o_ptr->to_d + 2 * sign(o_ptr->to_d)) / 3;
+			if (o_ptr->to_d > 15) p += (o_ptr->to_d - 14) / 2;
+
+			b = p;
+
+			if (x_ptr->flags1 & TR1_SLAY_EVIL)   p += b / 4;	/* + 50% dam, rarity factor 2 */
+			if (x_ptr->flags1 & TR1_KILL_DRAGON) p += b / 3;	/* +200% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_ANIMAL) p += b / 6;	/* + 50% dam, rarity factor 3 */
+			if (x_ptr->flags1 & TR1_SLAY_UNDEAD) p += b / 4;	/* +100% dam, rarity factor 4 */
+			if (x_ptr->flags1 & TR1_SLAY_DRAGON) p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_DEMON)  p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_TROLL)  p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_ORC)    p += b / 6;	/* +100% dam, rarity factor 6 */
+			if (x_ptr->flags1 & TR1_SLAY_GIANT)  p += b / 9;	/* +100% dam, rarity factor 9 */
+
+			if (x_ptr->flags1 & TR1_BRAND_NETHR) p += b / 2;	/* + 50% dam, rarity factor 1 */
+			if (x_ptr->flags1 & TR1_BRAND_NEXUS) p += b / 2;	/* + 50% dam, rarity factor 1 */
+			if (x_ptr->flags1 & TR1_BRAND_CHAOS) p += b / 2;	/* + 50% dam, rarity factor 1 */
+			if (x_ptr->flags1 & TR1_BRAND_ACID)  p += b / 3;	/* + 50% dam, rarity factor 1.5 */
+			if (x_ptr->flags1 & TR1_BRAND_ELEC)  p += b / 4;	/* + 50% dam, rarity factor 2 */
+			if (x_ptr->flags1 & TR1_BRAND_FIRE)  p += b / 5;	/* + 50% dam, rarity factor 2.5 */
+			if (x_ptr->flags1 & TR1_BRAND_COLD)  p += b / 4;	/* + 50% dam, rarity factor 2 */
 
-			if (a_ptr->flags1 & TR1_BLOWS)
+			if (x_ptr->flags1 & TR1_BLOWS)
 			{
-				if (a_ptr->pval > 3)
+				if (o_ptr->pval > 3)
 					p += 20000;	/* inhibit */
-				else if (a_ptr->pval > 0)
-					p = (p * 6) / (4 - a_ptr->pval);
+				else if (o_ptr->pval > 0)
+					p = (p * 6) / (4 - o_ptr->pval);
 			}
 
-			if ((a_ptr->flags1 & TR1_TUNNEL) &&
-			    (a_ptr->tval != TV_DIGGING))
-				p += a_ptr->pval * 3;
+			if ((x_ptr->flags1 & TR1_TUNNEL) &&
+			    (o_ptr->tval != TV_DIGGING))
+				p += o_ptr->pval * 3;
 
-			p += (a_ptr->to_h + 3 * sign(a_ptr->to_h)) / 4;
+			p += (o_ptr->to_h + 3 * sign(o_ptr->to_h)) / 4;
 
 			/* Remember, weight is in 0.1 lb. units. */
-			if (a_ptr->weight != k_ptr->weight)
-				p += (k_ptr->weight - a_ptr->weight) / 20;
+			if (o_ptr->weight != k_ptr->weight)
+				p += (k_ptr->weight - o_ptr->weight) / 20;
 
 			break;
 		}
 		case TV_BOOTS:
@@ -984,13 +924,13 @@
 		case TV_CLOAK:
 		case TV_SOFT_ARMOR:
 		case TV_HARD_ARMOR:
 		{
-			p += (a_ptr->ac + 4 * sign(a_ptr->ac)) / 5;
-			p += (a_ptr->to_h + sign(a_ptr->to_h)) / 2;
-			p += (a_ptr->to_d + sign(a_ptr->to_d)) / 2;
-			if (a_ptr->weight != k_ptr->weight)
-				p += (k_ptr->weight - a_ptr->weight) / 30;
+			p += (o_ptr->ac + 4 * sign(o_ptr->ac)) / 5;
+			p += (o_ptr->to_h + sign(o_ptr->to_h)) / 2;
+			p += (o_ptr->to_d + sign(o_ptr->to_d)) / 2;
+			if (o_ptr->weight != k_ptr->weight)
+				p += (k_ptr->weight - o_ptr->weight) / 30;
 			break;
 		}
 		case TV_LITE:
 		{
@@ -1005,915 +945,1107 @@
 		}
 	}
 
 	/* Other abilities are evaluated independent of the object type. */
-	p += (a_ptr->to_a + 3 * sign(a_ptr->to_a)) / 4;
-	if (a_ptr->to_a > 20) p += (a_ptr->to_a - 19) / 2;
-	if (a_ptr->to_a > 30) p += (a_ptr->to_a - 29) / 2;
-	if (a_ptr->to_a > 40) p += 20000;	/* inhibit */
-
-	if (a_ptr->pval > 0)
-	{
-		if (a_ptr->flags1 & TR1_STR) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_INT) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_WIS) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_DEX) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_CON) p += a_ptr->pval * a_ptr->pval;
-		if (a_ptr->flags1 & TR1_STEALTH) p += a_ptr->pval * a_ptr->pval;
-	}
-	else if (a_ptr->pval < 0)	/* hack: don't give large negatives */
-	{
-		if (a_ptr->flags1 & TR1_STR) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_INT) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_WIS) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_DEX) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_CON) p += a_ptr->pval;
-		if (a_ptr->flags1 & TR1_STEALTH) p += a_ptr->pval;
-	}
-	if (a_ptr->flags1 & TR1_CHR) p += a_ptr->pval;
-	if (a_ptr->flags1 & TR1_INFRA) p += (a_ptr->pval + sign(a_ptr->pval)) / 2;
-	if (a_ptr->flags1 & TR1_SPEED) p += (a_ptr->pval * 3) / 2;
-
-	if (a_ptr->flags2 & TR2_SUST_STR) p += 6;
-	if (a_ptr->flags2 & TR2_SUST_INT) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_WIS) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_DEX) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_CON) p += 4;
-	if (a_ptr->flags2 & TR2_SUST_CHR) p += 1;
-	if (a_ptr->flags2 & TR2_IM_ACID)
+	p += (o_ptr->to_a + 3 * sign(o_ptr->to_a)) / 4;
+	if (o_ptr->to_a > 20) p += (o_ptr->to_a - 19) / 2;
+	if (o_ptr->to_a > 30) p += (o_ptr->to_a - 29) / 2;
+	if (o_ptr->to_a > 40) p += 20000;	/* inhibit */
+
+	if (o_ptr->pval > 0)
+	{
+		int b = o_ptr->pval;
+		if (b > 8) b = 8;
+
+		if (x_ptr->flags1 & TR1_STR) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_INT) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_WIS) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_DEX) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_CON) p += 3 * pval_table[b];
+		if (x_ptr->flags1 & TR1_STEALTH) p += pval_table[b];
+	}
+	else if (o_ptr->pval < 0)	/* hack: don't give large negatives */
+	{
+		if (x_ptr->flags1 & TR1_STR) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_INT) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_WIS) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_DEX) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_CON) p += 2 * o_ptr->pval;
+		if (x_ptr->flags1 & TR1_STEALTH) p += o_ptr->pval;
+	}
+	if (x_ptr->flags1 & TR1_CHR) p += 3 * o_ptr->pval;
+	if (x_ptr->flags1 & TR1_INFRA) p += (o_ptr->pval + sign(o_ptr->pval));
+	if (x_ptr->flags1 & TR1_SPEED)
+	{
+		p += 2 * o_ptr->pval;
+		if (o_ptr->pval > 3)
+			p += (o_ptr->pval - 3) * 3;
+	}
+
+	if (x_ptr->flags2 & TR2_SUST_STR) p += 3;
+	if (x_ptr->flags2 & TR2_SUST_INT) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_WIS) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_DEX) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_CON) p += 2;
+	if (x_ptr->flags2 & TR2_SUST_CHR) p += 1;
+	if (x_ptr->flags2 & TR2_IM_ACID)
 	{
-		p += 20;
+		p += 35;
 		immunities++;
 	}
-	if (a_ptr->flags2 & TR2_IM_ELEC)
+	if (x_ptr->flags2 & TR2_IM_ELEC)
 	{
-		p += 24;
+		p += 30;
 		immunities++;
 	}
-	if (a_ptr->flags2 & TR2_IM_FIRE)
+	if (x_ptr->flags2 & TR2_IM_FIRE)
 	{
-		p += 36;
+		p += 40;
 		immunities++;
 	}
-	if (a_ptr->flags2 & TR2_IM_COLD)
+	if (x_ptr->flags2 & TR2_IM_COLD)
 	{
-		p += 24;
+		p += 30;
 		immunities++;
 	}
-	if (immunities > 1) p += 16;
-	if (immunities > 2) p += 16;
-	if (immunities > 3) p += 20000;		/* inhibit */
-	if (a_ptr->flags3 & TR3_FREE_ACT) p += 8;
-	if (a_ptr->flags3 & TR3_HOLD_LIFE) p += 10;
-	if (a_ptr->flags2 & TR2_RES_ACID) p += 6;
-	if (a_ptr->flags2 & TR2_RES_ELEC) p += 6;
-	if (a_ptr->flags2 & TR2_RES_FIRE) p += 6;
-	if (a_ptr->flags2 & TR2_RES_COLD) p += 6;
-	if (a_ptr->flags2 & TR2_RES_POIS) p += 12;
-	if (a_ptr->flags2 & TR2_RES_LITE) p += 8;
-	if (a_ptr->flags2 & TR2_RES_DARK) p += 10;
-	if (a_ptr->flags2 & TR2_RES_BLIND) p += 10;
-	if (a_ptr->flags2 & TR2_RES_CONFU) p += 8;
-	if (a_ptr->flags2 & TR2_RES_SOUND) p += 10;
-	if (a_ptr->flags2 & TR2_RES_SHARD) p += 8;
-	if (a_ptr->flags2 & TR2_RES_NETHR) p += 12;
-	if (a_ptr->flags2 & TR2_RES_NEXUS) p += 10;
-	if (a_ptr->flags2 & TR2_RES_CHAOS) p += 12;
-	if (a_ptr->flags2 & TR2_RES_DISEN) p += 12;
-
-	if (a_ptr->flags3 & TR3_FEATHER) p += 2;
-	if (a_ptr->flags3 & TR3_LITE) p += 2;
-	if (a_ptr->flags3 & TR3_SEE_INVIS) p += 8;
-	if (a_ptr->flags3 & TR3_TELEPATHY) p += 20;
-	if (a_ptr->flags3 & TR3_SLOW_DIGEST) p += 4;
-	if (a_ptr->flags3 & TR3_REGEN) p += 8;
-	if (a_ptr->flags3 & TR3_TELEPORT) p -= 20;
-	if (a_ptr->flags3 & TR3_DRAIN_EXP) p -= 16;
-	if (a_ptr->flags3 & TR3_AGGRAVATE) p -= 8;
-	if (a_ptr->flags3 & TR3_BLESSED) p += 4;
-	if (a_ptr->flags3 & TR3_LIGHT_CURSE) p -= 4;
-	if (a_ptr->flags3 & TR3_HEAVY_CURSE) p -= 20;
+	if (immunities > 1) p += 20000;		/* inhibit */
+	if (x_ptr->flags3 & TR3_FREE_ACT) p += 10;
+	if (x_ptr->flags3 & TR3_HOLD_LIFE) p += 12;
+	if (x_ptr->flags2 & TR2_RES_ACID) p += 4;
+	if (x_ptr->flags2 & TR2_RES_ELEC) p += 4;
+	if (x_ptr->flags2 & TR2_RES_FIRE) p += 4;
+	if (x_ptr->flags2 & TR2_RES_COLD) p += 4;
+	if (x_ptr->flags2 & TR2_RES_POIS) p += 12;
+	if (x_ptr->flags2 & TR2_RES_LITE) p += 6;
+	if (x_ptr->flags2 & TR2_RES_DARK) p += 6;
+	if (x_ptr->flags2 & TR2_RES_BLIND) p += 8;
+	if (x_ptr->flags2 & TR2_RES_CONFU) p += 10;
+	if (x_ptr->flags2 & TR2_RES_SOUND) p += 8;
+	if (x_ptr->flags2 & TR2_RES_SHARD) p += 8;
+	if (x_ptr->flags2 & TR2_RES_NETHR) p += 12;
+	if (x_ptr->flags2 & TR2_RES_NEXUS) p += 10;
+	if (x_ptr->flags2 & TR2_RES_CHAOS) p += 12;
+	if (x_ptr->flags2 & TR2_RES_DISEN) p += 12;
+
+	if (x_ptr->flags3 & TR3_FEATHER) p += 1;
+	if (x_ptr->flags3 & TR3_LITE) p += 3;
+	if (x_ptr->flags3 & TR3_SEE_INVIS) p += 4;
+	if (x_ptr->flags3 & TR3_TELEPATHY) p += 12;
+	if (x_ptr->flags3 & TR3_SLOW_DIGEST) p += 2;
+	if (x_ptr->flags3 & TR3_REGEN) p += 6;
+	if (x_ptr->flags3 & TR3_TELEPORT) p -= 12;
+	if (x_ptr->flags3 & TR3_DRAIN_EXP) p -= 16;
+	if (x_ptr->flags3 & TR3_AGGRAVATE) p -= 8;
+	if (x_ptr->flags3 & TR3_BLESSED) p += 2;
+	if (x_ptr->flags3 & TR3_LIGHT_CURSE) p -= 4;
+	if (x_ptr->flags3 & TR3_HEAVY_CURSE) p -= 12;
 /*	if (a_ptr->flags3 & TR3_PERMA_CURSE) p -= 40; */
 
 	return p;
 }
 
-
-/*
- * Randomly select a base item type (tval,sval).  Assign the various fields
- * corresponding to that choice.
- */
-static void choose_item(int a_idx)
-{
-	artifact_type *a_ptr = &a_info[a_idx];
-	int tval, sval;
-	object_kind *k_ptr;
-	int r;
-	s16b k_idx, r2;
-	byte target_level;
-
-	/*
-	 * Look up the original artifact's base object kind to get level and
-	 * rarity information to supplement the artifact level/rarity.  As a
-	 * degenerate case consider Bladeturner, which has artifact lvl/rar
-	 * of only 95/3, but which is based on an object with 110/64!
-	 */
-	k_idx = lookup_kind(a_ptr->tval, a_ptr->sval);
-	k_ptr = &k_info[k_idx];
-	target_level = k_ptr->level;
-
-	/*
-	 * Add base object kind's rarity to artifact rarity.  Later we will
-	 * subtract the new object kind's rarity.
-	 */
-	a_ptr->rarity += k_ptr->chance[0];
-
-	/*
-	 * Pick a category (tval) of weapon randomly.  Within each tval, roll
-	 * an sval (specific item) based on the target level.  The number we
-	 * roll should be a bell curve.  The mean and standard variation of the
-	 * bell curve are based on the target level; the distribution of
-	 * kinds versus the bell curve is hand-tweaked. :-(
-	 */
-	r = rand_int(100);
-
-	if (r < 5)
-	{
-		/* Create a missile weapon. */
-		tval = TV_BOW;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 3) sval = SV_SLING;
-		else if (r2 < 10) sval = SV_SHORT_BOW;
-		else if (r2 < 30) sval = SV_LONG_BOW;
-		else if (r2 < 45) sval = SV_LIGHT_XBOW;
-		else sval = SV_HEAVY_XBOW;
-	}
-	else if (r < 9)
-	{
-		/* Create a digging tool. */
-		tval = TV_DIGGING;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 15) sval = SV_SHOVEL;
-		else if (r2 < 30) sval = SV_PICK;
-		else if (r2 < 60) sval = SV_GNOMISH_SHOVEL;
-		else if (r2 < 90) sval = SV_ORCISH_PICK;
-		else if (r2 < 120) sval = SV_DWARVEN_SHOVEL;
-		else sval = SV_DWARVEN_PICK;
-	}
-	else if (r < 19)
-	{
-		/* Create a "blunt" weapon. */
-		tval = TV_HAFTED;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 6) sval = SV_WHIP;
-		else if (r2 < 12) sval = SV_MACE;
-		else if (r2 < 20) sval = SV_WAR_HAMMER;
-		else if (r2 < 30) sval = SV_QUARTERSTAFF;
-		else if (r2 < 34) sval = SV_LUCERN_HAMMER;
-		else if (r2 < 38) sval = SV_MORNING_STAR;
-		else if (r2 < 45) sval = SV_FLAIL;
-		else if (r2 < 55) sval = SV_LEAD_FILLED_MACE;
-		else if (r2 < 80) sval = SV_BALL_AND_CHAIN;
-		else if (r2 < 120) sval = SV_TWO_HANDED_FLAIL;
-		else sval = SV_MACE_OF_DISRUPTION;
-	}
-	else if (r < 33)
-	{
-		/* Create a long, sharp-edged weapon. */
-		tval = TV_SWORD;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 0) sval = SV_BROKEN_DAGGER;
-		else if (r2 < 1) sval = SV_BROKEN_SWORD;
-		else if (r2 < 5) sval = SV_DAGGER;
-		else if (r2 < 9) sval = SV_MAIN_GAUCHE;
-		else if (r2 < 10) sval = SV_RAPIER;	/* or at least pointy ;-) */
-		else if (r2 < 12) sval = SV_SMALL_SWORD;
-		else if (r2 < 14) sval = SV_SHORT_SWORD;
-		else if (r2 < 16) sval = SV_SABRE;
-		else if (r2 < 18) sval = SV_CUTLASS;
-		else if (r2 < 20) sval = SV_TULWAR;
-		else if (r2 < 23) sval = SV_BROAD_SWORD;
-		else if (r2 < 26) sval = SV_LONG_SWORD;
-		else if (r2 < 30) sval = SV_SCIMITAR;
-		else if (r2 < 45) sval = SV_BASTARD_SWORD;
-		else if (r2 < 60) sval = SV_KATANA;
-		else if (r2 < 90) sval = SV_TWO_HANDED_SWORD;
-		else if (r2 < 120) sval = SV_EXECUTIONERS_SWORD;
-		else sval = SV_BLADE_OF_CHAOS;
-	}
-	else if (r < 42)
-	{
-		/* Create a weapon that's not blunt or sword-shaped. */
-		tval = TV_POLEARM;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 12) sval = SV_SPEAR;
-		else if (r2 < 20) sval = SV_TRIDENT;
-		else if (r2 < 27) sval = SV_LANCE;
-		else if (r2 < 35) sval = SV_AWL_PIKE;
-		else if (r2 < 45) sval = SV_PIKE;
-		else if (r2 < 50) sval = SV_BEAKED_AXE;
-		else if (r2 < 55) sval = SV_BROAD_AXE;
-		else if (r2 < 60) sval = SV_BATTLE_AXE;
-		else if (r2 < 65) sval = SV_GLAIVE;
-		else if (r2 < 80) sval = SV_HALBERD;
-		else if (r2 < 120) sval = SV_GREAT_AXE;
-		else if (r2 < 128) sval = SV_SCYTHE;
-		else if (r2 < 135) sval = SV_LOCHABER_AXE;
-		else sval = SV_SCYTHE_OF_SLICING;
-	}
-	else if (r < 64)
-	{
-		/* Create light or hard body armor. */
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 45) tval = TV_SOFT_ARMOR; else tval = TV_HARD_ARMOR;
-
-		/* Soft stuff. */
-		if (r2 < 0) sval = SV_FILTHY_RAG;
-		else if (r2 < 5) sval = SV_ROBE;
-		else if (r2 < 10) sval = SV_SOFT_LEATHER_ARMOR;
-		else if (r2 < 15) sval = SV_SOFT_STUDDED_LEATHER;
-		else if (r2 < 20) sval = SV_HARD_LEATHER_ARMOR;
-		else if (r2 < 30) sval = SV_HARD_STUDDED_LEATHER;
-		else if (r2 < 45) sval = SV_LEATHER_SCALE_MAIL;
-
-		/* Hard stuff. */
-		else if (r2 < 55) sval = SV_RUSTY_CHAIN_MAIL;
-		else if (r2 < 65) sval = SV_METAL_SCALE_MAIL;
-		else if (r2 < 75) sval = SV_CHAIN_MAIL;
-		else if (r2 < 85) sval = SV_AUGMENTED_CHAIN_MAIL;
-		else if (r2 < 90) sval = SV_DOUBLE_CHAIN_MAIL;
-		else if (r2 < 97) sval = SV_BAR_CHAIN_MAIL;
-		else if (r2 < 105) sval = SV_METAL_BRIGANDINE_ARMOUR;
-		else if (r2 < 115) sval = SV_PARTIAL_PLATE_ARMOUR;
-		else if (r2 < 125) sval = SV_METAL_LAMELLAR_ARMOUR;
-		else if (r2 < 135) sval = SV_FULL_PLATE_ARMOUR;
-		else if (r2 < 140) sval = SV_RIBBED_PLATE_ARMOUR;
-		else if (r2 < 150) sval = SV_MITHRIL_CHAIN_MAIL;
-		else if (r2 < 170) sval = SV_MITHRIL_PLATE_MAIL;
-		else sval = SV_ADAMANTITE_PLATE_MAIL;
-	}
-	else if (r < 71)
-	{
-		/* Make shoes. */
-		tval = TV_BOOTS;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 9) sval = SV_PAIR_OF_SOFT_LEATHER_BOOTS;
-		else if (r2 < 15) sval = SV_PAIR_OF_HARD_LEATHER_BOOTS;
-		else sval = SV_PAIR_OF_METAL_SHOD_BOOTS;
-	}
-	else if (r < 78)
-	{
-		/* Make gloves. */
-		tval = TV_GLOVES;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 10) sval = SV_SET_OF_LEATHER_GLOVES;
-		else if (r2 < 30) sval = SV_SET_OF_GAUNTLETS;
-		else sval = SV_SET_OF_CESTI;
-	}
-	else if (r < 87)
-	{
-		/* Make headgear. */
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 50) tval = TV_HELM; else tval = TV_CROWN;
-
-		if (r2 < 9) sval = SV_HARD_LEATHER_CAP;
-		else if (r2 < 20) sval = SV_METAL_CAP;
-		else if (r2 < 40) sval = SV_IRON_HELM;
-		else if (r2 < 50) sval = SV_STEEL_HELM;
-
-		else if (r2 < 60) sval = SV_IRON_CROWN;
-		else if (r2 < 90) sval = SV_GOLDEN_CROWN;
-		else sval = SV_JEWELED_CROWN;
-	}
-	else if (r < 94)
-	{
-		/* Make a shield. */
-		tval = TV_SHIELD;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 9) sval = SV_SMALL_LEATHER_SHIELD;
-		else if (r2 < 20) sval = SV_SMALL_METAL_SHIELD;
-		else if (r2 < 40) sval = SV_LARGE_LEATHER_SHIELD;
-		else if (r2 < 60) sval = SV_LARGE_METAL_SHIELD;
-		else sval = SV_SHIELD_OF_DEFLECTION;
-	}
-	else
-	{
-		/* Make a cloak. */
-		tval = TV_CLOAK;
-		r2 = Rand_normal(target_level * 2, target_level);
-		if (r2 < 90) sval = SV_CLOAK;
-		else sval = SV_SHADOW_CLOAK;
-	}
-
-	k_idx = lookup_kind(tval, sval);
-	k_ptr = &k_info[k_idx];
-	kinds[a_idx] = k_idx;
-
-	/*
-	 * Subtract the new object kind's rarity (see above).  We can't
-	 * blindly subtract, because a_ptr->rarity is a byte.
-	 */
-	if (a_ptr->rarity <= k_ptr->chance[0])
-		a_ptr->rarity = 1;
-	else
-		a_ptr->rarity -= k_ptr->chance[0];
-
-	a_ptr->tval = k_ptr->tval;
-	a_ptr->sval = k_ptr->sval;
-	a_ptr->pval = k_ptr->pval;
-	a_ptr->to_h = k_ptr->to_h;
-	a_ptr->to_d = k_ptr->to_d;
-	a_ptr->to_a = k_ptr->to_a;
-	a_ptr->ac = k_ptr->ac;
-	a_ptr->dd = k_ptr->dd;
-	a_ptr->ds = k_ptr->ds;
-	a_ptr->weight = k_ptr->weight;
-	a_ptr->flags1 = k_ptr->flags1;
-	a_ptr->flags2 = k_ptr->flags2;
-	a_ptr->flags3 = k_ptr->flags3;
-
-	/* Artifacts ignore everything */
-	a_ptr->flags3 |= TR3_IGNORE_MASK;
-
-	/* Assign basic stats to the artifact based on its artifact level. */
-	switch (a_ptr->tval)
-	{
-		case TV_BOW: case TV_DIGGING: case TV_HAFTED:
-		case TV_SWORD: case TV_POLEARM:
-			a_ptr->to_h += (s16b)(a_ptr->level / 10 + rand_int(4) + rand_int(4));
-			a_ptr->to_d += (s16b)(a_ptr->level / 10 + rand_int(4) + rand_int((a_ptr->dd * a_ptr->ds) / 2 + 1));
-			break;
-		case TV_BOOTS: case TV_GLOVES: case TV_HELM: case TV_CROWN:
-		case TV_SHIELD: case TV_CLOAK: case TV_SOFT_ARMOR:
-		case TV_HARD_ARMOR:
-			a_ptr->to_a += (s16b)(a_ptr->level / 10 + a_ptr->ac / 3 + rand_int(8));
-			if (a_ptr->to_a < 10) a_ptr->to_a += (s16b)(2 + rand_int(4) + rand_int(4));
-			/*
-			 * Make sure armor gets some resists!  Hard body armor
-			 * is generally high-level stuff, with good ac and
-			 * to_a.  That sucks up all the points....
-			 */
-			switch (a_ptr->tval)
-			{
-			case TV_SOFT_ARMOR: case TV_HARD_ARMOR:
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_ACID;
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_ELEC;
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_COLD;
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_RES_FIRE;
-				break;
-			}
-			break;
-	}
-}
-
-
 /*
  * We've just added an ability which uses the pval bonus.  Make sure it's
  * not zero.  If it's currently negative, leave it negative (heh heh).
  */
-static void do_pval(artifact_type *a_ptr)
+static void do_pval(object_type *o_ptr)
 {
-	if (a_ptr->pval == 0) a_ptr->pval = (s16b)(1 + rand_int(3));
-	else if (a_ptr->pval < 0)
+	if (o_ptr->pval == 0) o_ptr->pval = (s16b)(1 + rand_int(3));
+	else if (o_ptr->pval < 0)
 	{
-		if (rand_int(2) == 0) a_ptr->pval--;
+		if (rand_int(2) == 0) o_ptr->pval--;
 	}
-	else if (rand_int(3) > 0) a_ptr->pval++;
+	else if (rand_int(3) > 0) o_ptr->pval++;
 }
 
 
-static void remove_contradictory(artifact_type *a_ptr)
+static void remove_contradictory(object_type *o_ptr)
 {
-	if (a_ptr->flags3 & TR3_AGGRAVATE) a_ptr->flags1 &= ~(TR1_STEALTH);
-	if (a_ptr->flags2 & TR2_IM_ACID) a_ptr->flags2 &= ~(TR2_RES_ACID);
-	if (a_ptr->flags2 & TR2_IM_ELEC) a_ptr->flags2 &= ~(TR2_RES_ELEC);
-	if (a_ptr->flags2 & TR2_IM_FIRE) a_ptr->flags2 &= ~(TR2_RES_FIRE);
-	if (a_ptr->flags2 & TR2_IM_COLD) a_ptr->flags2 &= ~(TR2_RES_COLD);
-
-	if (a_ptr->pval < 0)
-	{
-		if (a_ptr->flags1 & TR1_STR) a_ptr->flags2 &= ~(TR2_SUST_STR);
-		if (a_ptr->flags1 & TR1_INT) a_ptr->flags2 &= ~(TR2_SUST_INT);
-		if (a_ptr->flags1 & TR1_WIS) a_ptr->flags2 &= ~(TR2_SUST_WIS);
-		if (a_ptr->flags1 & TR1_DEX) a_ptr->flags2 &= ~(TR2_SUST_DEX);
-		if (a_ptr->flags1 & TR1_CON) a_ptr->flags2 &= ~(TR2_SUST_CON);
-		if (a_ptr->flags1 & TR1_CHR) a_ptr->flags2 &= ~(TR2_SUST_CHR);
-		a_ptr->flags1 &= ~(TR1_BLOWS);
-	}
-
-	if (a_ptr->flags3 & TR3_LIGHT_CURSE) a_ptr->flags3 &= ~(TR3_BLESSED);
-	if (a_ptr->flags1 & TR1_KILL_DRAGON) a_ptr->flags1 &= ~(TR1_SLAY_DRAGON);
-	if (a_ptr->flags3 & TR3_DRAIN_EXP) a_ptr->flags3 &= ~(TR3_HOLD_LIFE);
+	randart_type *x_ptr = &x_info[o_ptr->name3];
+
+	if (x_ptr->flags3 & TR3_AGGRAVATE) x_ptr->flags1 &= ~(TR1_STEALTH);
+	if (x_ptr->flags2 & TR2_IM_ACID) x_ptr->flags2 &= ~(TR2_RES_ACID);
+	if (x_ptr->flags2 & TR2_IM_ELEC) x_ptr->flags2 &= ~(TR2_RES_ELEC);
+	if (x_ptr->flags2 & TR2_IM_FIRE) x_ptr->flags2 &= ~(TR2_RES_FIRE);
+	if (x_ptr->flags2 & TR2_IM_COLD) x_ptr->flags2 &= ~(TR2_RES_COLD);
+
+	if (o_ptr->pval < 0)
+	{
+		if (x_ptr->flags1 & TR1_STR) x_ptr->flags2 &= ~(TR2_SUST_STR);
+		if (x_ptr->flags1 & TR1_INT) x_ptr->flags2 &= ~(TR2_SUST_INT);
+		if (x_ptr->flags1 & TR1_WIS) x_ptr->flags2 &= ~(TR2_SUST_WIS);
+		if (x_ptr->flags1 & TR1_DEX) x_ptr->flags2 &= ~(TR2_SUST_DEX);
+		if (x_ptr->flags1 & TR1_CON) x_ptr->flags2 &= ~(TR2_SUST_CON);
+		if (x_ptr->flags1 & TR1_CHR) x_ptr->flags2 &= ~(TR2_SUST_CHR);
+		x_ptr->flags1 &= ~(TR1_BLOWS);
+		x_ptr->flags1 &= ~(TR1_SHOTS);
+		x_ptr->flags1 &= ~(TR1_INFRA);
+	}
+
+	if (x_ptr->flags3 & TR3_LIGHT_CURSE) x_ptr->flags3 &= ~(TR3_BLESSED);
+	if (x_ptr->flags1 & TR1_BRAND_NETHR) x_ptr->flags3 &= ~(TR3_BLESSED);
+	if (x_ptr->flags1 & TR1_KILL_DRAGON) x_ptr->flags1 &= ~(TR1_SLAY_DRAGON);
+	if (x_ptr->flags3 & TR3_DRAIN_EXP) x_ptr->flags3 &= ~(TR3_HOLD_LIFE);
+
+	if (o_ptr->tval == TV_SHOT || o_ptr->tval == TV_ARROW ||
+		o_ptr->tval == TV_BOLT)
+	{
+		x_ptr->flags1 &= ~(TR1_PVAL_MASK);
+		x_ptr->flags2 = 0;
+		x_ptr->flags3 &= (TR3_IGNORE_MASK | TR3_CURSED_MASK);
+	}
 }
 
 
 /*
  * Randomly select an extra ability to be added to the artifact in question.
  * XXX - This function is way too large.
  */
-static void add_ability(artifact_type *a_ptr)
+static void add_ability(object_type *o_ptr, int power)
 {
+	randart_type *x_ptr = &x_info[o_ptr->name3];
+
 	int r;
+	int p = power;
+
+	/* Boost power */
+	while (rand_int(2) == 0)
+		p += randint(10);
 
-	r = rand_int(10);
-	if (r < 5)		/* Pick something dependent on item type. */
+	/* Cap power */
+	if (p > 50) p = 50;
+
+	/*
+	 *  0-29: minor ability
+	 * 30-49: major ability
+	 * 50+  : major power
+	 */
+
+	r = rand_int(p);
+	if (rand_int(2) != 0)		/* Pick something dependent on item type. */
 	{
-		r = rand_int(100);
-		switch (a_ptr->tval)
+		switch (o_ptr->tval)
 		{
-			case TV_BOW:
+			case TV_BOLT:
+			case TV_ARROW:
+			case TV_SHOT:
 			{
-				if (r < 15)
+				if (r < 3)
+					o_ptr->to_h += randint(5) + randint(5);
+				else if (r < 6)
+					o_ptr->to_d += randint(5) + randint(5);
+				else if (r < 20)
 				{
-					a_ptr->flags1 |= TR1_SHOTS;
-					do_pval(a_ptr);
+					o_ptr->to_h += randint(5) + randint(5);
+					o_ptr->to_d += randint(5) + randint(5);
 				}
-				else if (r < 35)
+				if (r < 30)
+				{
+					switch (rand_int(8))
+					{
+					case 0:
+					case 1:
+					case 2:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_ORC;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_TROLL;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_GIANT;
+							break;
+						}
+					case 3:
+					case 4:
+					case 5:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_EVIL;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_UNDEAD;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_DEMON;
+							break;
+						}
+					case 6:
+						{
+							x_ptr->flags1 |= TR1_SLAY_ANIMAL;
+							break;
+						}
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_SLAY_DRAGON;
+							break;
+						}
+					}
+				}
+				else
 				{
-					a_ptr->flags1 |= TR1_MIGHT;
-					do_pval(a_ptr);
+					switch (rand_int(8))
+					{
+					case 0:
+						{
+							x_ptr->flags1 |= TR1_KILL_DRAGON;
+							break;
+						}
+					case 1:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ACID;
+							break;
+						}
+					case 2:
+					case 3:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ELEC;
+							break;
+						}
+					case 4:
+					case 5:
+						{
+							x_ptr->flags1 |= TR1_BRAND_FIRE;
+							break;
+						}
+					case 6:
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_BRAND_COLD;
+							break;
+						}
+					}
 				}
-				else if (r < 65) a_ptr->to_h += (s16b)(2 + rand_int(2));
-				else a_ptr->to_d += (s16b)(2 + rand_int(3));
 
 				break;
 			}
-			case TV_DIGGING:
-			case TV_HAFTED:
-			case TV_POLEARM:
-			case TV_SWORD:
+			case TV_BOW:
 			{
-				if (r < 4)
-				{
-					a_ptr->flags1 |= TR1_WIS;
-					do_pval(a_ptr);
-					if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_WIS;
-					if (a_ptr->tval == TV_SWORD || a_ptr->tval == TV_POLEARM)
-						a_ptr->flags3 |= TR3_BLESSED;
-				}
-				else if (r < 7)
-				{
-					a_ptr->flags1 |= TR1_BRAND_ACID;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_ACID;
-				}
+				if (r < 5)
+					o_ptr->to_h += randint(5) + randint(5);
 				else if (r < 10)
+					o_ptr->to_d += randint(5) + randint(5);
+				else if (r < 30)
 				{
-					a_ptr->flags1 |= TR1_BRAND_ELEC;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_ELEC;
+					o_ptr->to_h += randint(5) + randint(5);
+					o_ptr->to_d += randint(5) + randint(5);
 				}
-				else if (r < 15)
+				else if (r < 33)
 				{
-					a_ptr->flags1 |= TR1_BRAND_FIRE;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_FIRE;
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else if (r < 20)
+				else if (rand_int(2) == 0)
 				{
-					a_ptr->flags1 |= TR1_BRAND_COLD;
-					if (rand_int(4) > 0) a_ptr->flags2 |= TR2_RES_COLD;
+					x_ptr->flags1 |= TR1_SHOTS;
+					do_pval(o_ptr);
 				}
-				else if (r < 28)
+				else
 				{
-					a_ptr->dd += (byte)(1 + rand_int(2) + rand_int(2));
-					if (a_ptr->dd > 9) a_ptr->dd = 9;
+					x_ptr->flags1 |= TR1_MIGHT;
+					do_pval(o_ptr);
 				}
-				else if (r < 31) a_ptr->flags1 |= TR1_KILL_DRAGON;
-				else if (r < 35) a_ptr->flags1 |= TR1_SLAY_DRAGON;
-				else if (r < 40) a_ptr->flags1 |= TR1_SLAY_EVIL;
 
-				else if (r < 45) a_ptr->flags1 |= TR1_SLAY_ANIMAL;
-				else if (r < 50)
-				{
-					a_ptr->flags1 |= TR1_SLAY_UNDEAD;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_DEMON;
-				}
-				else if (r < 54)
+				break;
+			}
+			case TV_DIGGING:
+			case TV_HAFTED:
+			case TV_POLEARM:
+			case TV_SWORD:
+			{
+				if (r < 3)
+					o_ptr->to_h += randint(5) + randint(5);
+				else if (r < 6)
+					o_ptr->to_d += randint(5) + randint(5);
+				else if (r < 18)
 				{
-					a_ptr->flags1 |= TR1_SLAY_DEMON;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_UNDEAD;
+					o_ptr->to_h += randint(5) + randint(5);
+					o_ptr->to_d += randint(5) + randint(5);
 				}
-				else if (r < 59)
+				else if (r < 20 && o_ptr->tval != TV_HAFTED)
+					x_ptr->flags3 |= TR3_BLESSED;
+				else if (r < 28)
 				{
-					a_ptr->flags1 |= TR1_SLAY_ORC;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_TROLL;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_GIANT;
+					switch (rand_int(8))
+					{
+					case 0:
+					case 1:
+					case 2:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_ORC;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_TROLL;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_GIANT;
+							break;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_STR;
+								do_pval(o_ptr);
+							}
+						}
+					case 3:
+					case 4:
+					case 5:
+						{
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_EVIL;
+							if (rand_int(2) == 0)
+								x_ptr->flags1 |= TR1_SLAY_UNDEAD;
+							if (rand_int(3) == 0)
+								x_ptr->flags1 |= TR1_SLAY_DEMON;
+							if (o_ptr->tval != TV_HAFTED && rand_int(3) != 0)
+								x_ptr->flags3 |= TR3_BLESSED;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_WIS;
+								do_pval(o_ptr);
+							}
+							if (rand_int(5) == 0)
+								x_ptr->flags3 |= TR3_HOLD_LIFE;
+							break;
+						}
+					case 6:
+						{
+							x_ptr->flags1 |= TR1_SLAY_ANIMAL;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_INT;
+								do_pval(o_ptr);
+							}
+							if (rand_int(5) == 0)
+								x_ptr->flags3 |= TR3_REGEN;
+							break;
+						}
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_SLAY_DRAGON;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_CON;
+								do_pval(o_ptr);
+							}
+							break;
+						}
+					}
 				}
-				else if (r < 63)
+				else if (r < 30)
+					o_ptr->to_a += randint(5);
+				else if (r < 32)
+					o_ptr->dd++;
+				else if (r < 40)
 				{
-					a_ptr->flags1 |= TR1_SLAY_TROLL;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_ORC;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_GIANT;
+					switch (rand_int(8))
+					{
+					case 0:
+						{
+							x_ptr->flags1 |= TR1_KILL_DRAGON;
+							if (rand_int(p) >= 40)
+							{
+								x_ptr->flags1 |= TR1_CON;
+								do_pval(o_ptr);
+							}
+							break;
+						}
+					case 1:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ACID;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_ACID;
+							break;
+						}
+					case 2:
+					case 3:
+						{
+							x_ptr->flags1 |= TR1_BRAND_ELEC;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_ELEC;
+							break;
+						}
+					case 4:
+					case 5:
+						{
+							x_ptr->flags1 |= TR1_BRAND_FIRE;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_FIRE;
+							break;
+						}
+					case 6:
+					case 7:
+						{
+							x_ptr->flags1 |= TR1_BRAND_COLD;
+							if (rand_int(p) >= 20)
+								x_ptr->flags2 |= TR2_RES_COLD;
+							break;
+						}
+					}
 				}
-				else if (r < 67)
+				else if (r < 42)
 				{
-					a_ptr->flags1 |= TR1_SLAY_GIANT;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_ORC;
-					if (rand_int(2) == 0) a_ptr->flags1 |= TR1_SLAY_TROLL;
+					switch (rand_int(3))
+					{
+					case 0:
+						{
+							x_ptr->flags1 |= TR1_BRAND_NEXUS;
+							if (rand_int(p) >= 30)
+								x_ptr->flags2 |= TR2_RES_NEXUS;
+							break;
+						}
+					case 1:
+						{
+							x_ptr->flags1 |= TR1_BRAND_NETHR;
+							if (rand_int(p) >= 30)
+								x_ptr->flags2 |= TR2_RES_NETHR;
+							break;
+						}
+					case 2:
+						{
+							x_ptr->flags1 |= TR1_BRAND_CHAOS;
+							if (rand_int(p) >= 30)
+								x_ptr->flags2 |= TR2_RES_CHAOS;
+							break;
+						}
+					}
 				}
-				else if (r < 72) a_ptr->flags3 |= TR3_SEE_INVIS;
-				else if (r < 76)
+				else if (r < 44)
 				{
-					if (a_ptr->pval < 0) break;
-					a_ptr->flags1 |= TR1_BLOWS;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_STR;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_STR;
+				}
+				else if (r < 47)
+				{
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else if (r < 89)
+				else
 				{
-					a_ptr->to_d += (s16b)(3 + rand_int(4));
-					a_ptr->to_h += (s16b)(3 + rand_int(4));
+					x_ptr->flags1 |= TR1_CON;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_CON;
 				}
-				else if (r < 92) a_ptr->to_a += (s16b)(3 + rand_int(3));
-				else if (r < 98)
-					a_ptr->weight = (a_ptr->weight * 9) / 10;
-				else
-					if (a_ptr->tval != TV_DIGGING)
-					{
-						a_ptr->flags1 |= TR1_TUNNEL;
-						do_pval(a_ptr);
-					}
 
 				break;
 			}
 			case TV_BOOTS:
 			{
-				if (r < 10) a_ptr->flags3 |= TR3_FEATHER;
-				else if (r < 50) a_ptr->to_a += (s16b)(2 + rand_int(4));
-				else if (r < 80)
+				if (r < 6)
+					x_ptr->flags3 |= TR3_FEATHER;
+				else if (r < 25)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
 				{
-					a_ptr->flags1 |= TR1_STEALTH;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_STEALTH;
+					do_pval(o_ptr);
 				}
-				else if (r < 90)
+				else if (r < 35)
 				{
-					a_ptr->flags1 |= TR1_SPEED;
-					if (a_ptr->pval < 0) break;
-					if (a_ptr->pval == 0) a_ptr->pval = (s16b)(3 + rand_int(8));
-					else if (rand_int(2) == 0) a_ptr->pval++;
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else a_ptr->weight = (a_ptr->weight * 9) / 10;
+				else if (r < 45)
+					x_ptr->flags3 |= TR3_FREE_ACT;
+				else
+				{
+					x_ptr->flags1 |= TR1_SPEED;
+					do_pval(o_ptr);
+					/* Supercharge! */
+					while (o_ptr->pval > 0 && rand_int(3) == 0)
+						o_ptr->pval++;
+				}
+
 				break;
 			}
 			case TV_GLOVES:
 			{
-				if (r < 25) a_ptr->flags3 |= TR3_FREE_ACT;
-				else if (r < 50)
-				{
-					a_ptr->flags1 |= TR1_DEX;
-					do_pval(a_ptr);
+				if (r < 25)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					o_ptr->to_h += rand_int(6);
+					o_ptr->to_d += rand_int(6);
+				}
+				else if (r < 40)
+				{
+					x_ptr->flags1 |= TR1_DEX;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_DEX;
 				}
-				else if (r < 75) a_ptr->to_a += (s16b)(3 + rand_int(3));
 				else
-				{
-					a_ptr->to_h += (s16b)(2 + rand_int(3));
-					a_ptr->to_d += (s16b)(2 + rand_int(3));
-					a_ptr->flags3 |= TR3_SHOW_MODS;
-				}
+					x_ptr->flags3 |= TR3_FREE_ACT;
+
 				break;
 			}
 			case TV_HELM:
 			case TV_CROWN:
 			{
-				if (r < 20) a_ptr->flags2 |= TR2_RES_BLIND;
-				else if (r < 45) a_ptr->flags3 |= TR3_TELEPATHY;
-				else if (r < 65) a_ptr->flags3 |= TR3_SEE_INVIS;
-				else if (r < 75)
+				if (r < 13)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 15)
+					x_ptr->flags1 |= TR3_LITE;
+				else if (r < 19)
 				{
-					a_ptr->flags1 |= TR1_WIS;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_INFRA;
+					do_pval(o_ptr);
 				}
-				else if (r < 85)
+				else if (r < 22)
 				{
-					a_ptr->flags1 |= TR1_INT;
-					do_pval(a_ptr);
+					x_ptr->flags1 |= TR1_SEARCH;
+					do_pval(o_ptr);
 				}
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+				else if (r < 26)
+					x_ptr->flags3 |= TR3_SEE_INVIS;
+				else if (r < 30)
+				{
+					x_ptr->flags1 |= TR1_CHR;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_CHR;
+				}
+				else if (r < 37)
+				{
+					x_ptr->flags1 |= TR1_INT;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_INT;
+				}
+				else if (r < 44)
+				{
+					x_ptr->flags1 |= TR1_WIS;
+					do_pval(o_ptr);
+					if (rand_int(3) != 0)
+						x_ptr->flags2 |= TR2_SUST_WIS;
+				}
+				else
+					x_ptr->flags3 |= TR3_TELEPATHY;
+
 				break;
 			}
 			case TV_SHIELD:
 			{
-				if (r < 20) a_ptr->flags2 |= TR2_RES_ACID;
-				else if (r < 40) a_ptr->flags2 |= TR2_RES_ELEC;
-				else if (r < 60) a_ptr->flags2 |= TR2_RES_FIRE;
-				else if (r < 80) a_ptr->flags2 |= TR2_RES_COLD;
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+				if (r < 20)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ACID;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ELEC;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_FIRE;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_COLD;
+				}
+				else if (r < 34)
+				{
+					x_ptr->flags2 |= TR2_RES_ACID;
+					x_ptr->flags2 |= TR2_RES_ELEC;
+					x_ptr->flags2 |= TR2_RES_FIRE;
+					x_ptr->flags2 |= TR2_RES_COLD;
+				}
+				else if (r < 47)
+				{
+					switch (rand_int(11))
+					{
+					case 0:  x_ptr->flags2 |= TR2_RES_POIS; break;
+					case 1:  x_ptr->flags2 |= TR2_RES_LITE; break;
+					case 2:  x_ptr->flags2 |= TR2_RES_DARK; break;
+					case 3:  x_ptr->flags2 |= TR2_RES_BLIND; break;
+					case 4:  x_ptr->flags2 |= TR2_RES_CONFU; break;
+					case 5:  x_ptr->flags2 |= TR2_RES_SOUND; break;
+					case 6:  x_ptr->flags2 |= TR2_RES_SHARD; break;
+					case 7:  x_ptr->flags2 |= TR2_RES_NETHR; break;
+					case 8:  x_ptr->flags2 |= TR2_RES_NEXUS; break;
+					case 9:  x_ptr->flags2 |= TR2_RES_CHAOS; break;
+					case 10: x_ptr->flags2 |= TR2_RES_DISEN; break;
+					}
+				}
+				else
+					x_ptr->flags3 |= TR3_HOLD_LIFE;
+
 				break;
 			}
 			case TV_CLOAK:
 			{
-				if (r < 50)
-				{
-					a_ptr->flags1 |= TR1_STEALTH;
-					do_pval(a_ptr);
+				if (r < 20)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					x_ptr->flags1 |= TR1_STEALTH;
+					do_pval(o_ptr);
+				}
+				else if (r < 44)
+				{
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ACID;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ELEC;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_FIRE;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_COLD;
 				}
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+				else if (r < 47)
+					x_ptr->flags3 |= TR3_FREE_ACT;
+				else
+					x_ptr->flags3 |= TR3_HOLD_LIFE;
+
 				break;
 			}
+			case TV_DRAG_ARMOR:
 			case TV_SOFT_ARMOR:
 			case TV_HARD_ARMOR:
 			{
-				if (r < 8)
-				{
-					a_ptr->flags1 |= TR1_STEALTH;
-					do_pval(a_ptr);
+				if (r < 25)
+					o_ptr->to_a += randint(5) + randint(5);
+				else if (r < 30)
+				{
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ACID;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_ELEC;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_FIRE;
+					if (rand_int(3) == 0)
+						x_ptr->flags2 |= TR2_RES_COLD;
+				}
+				else if (r < 34)
+				{
+					x_ptr->flags2 |= TR2_RES_ACID;
+					x_ptr->flags2 |= TR2_RES_ELEC;
+					x_ptr->flags2 |= TR2_RES_FIRE;
+					x_ptr->flags2 |= TR2_RES_COLD;
 				}
-				else if (r < 16) a_ptr->flags3 |= TR3_HOLD_LIFE;
-				else if (r < 22)
+				else if (r < 47)
 				{
-					a_ptr->flags1 |= TR1_CON;
-					do_pval(a_ptr);
-					if (rand_int(2) == 0)
-						a_ptr->flags2 |= TR2_SUST_CON;
-				}
-				else if (r < 34) a_ptr->flags2 |= TR2_RES_ACID;
-				else if (r < 46) a_ptr->flags2 |= TR2_RES_ELEC;
-				else if (r < 58) a_ptr->flags2 |= TR2_RES_FIRE;
-				else if (r < 70) a_ptr->flags2 |= TR2_RES_COLD;
-				else if (r < 80)
-					a_ptr->weight = (a_ptr->weight * 9) / 10;
-				else a_ptr->to_a += (s16b)(3 + rand_int(3));
+					switch (rand_int(11))
+					{
+					case 0:  x_ptr->flags2 |= TR2_RES_POIS; break;
+					case 1:  x_ptr->flags2 |= TR2_RES_LITE; break;
+					case 2:  x_ptr->flags2 |= TR2_RES_DARK; break;
+					case 3:  x_ptr->flags2 |= TR2_RES_BLIND; break;
+					case 4:  x_ptr->flags2 |= TR2_RES_CONFU; break;
+					case 5:  x_ptr->flags2 |= TR2_RES_SOUND; break;
+					case 6:  x_ptr->flags2 |= TR2_RES_SHARD; break;
+					case 7:  x_ptr->flags2 |= TR2_RES_NETHR; break;
+					case 8:  x_ptr->flags2 |= TR2_RES_NEXUS; break;
+					case 9:  x_ptr->flags2 |= TR2_RES_CHAOS; break;
+					case 10: x_ptr->flags2 |= TR2_RES_DISEN; break;
+					}
+				}
+				else
+					x_ptr->flags3 |= TR3_HOLD_LIFE;
+
 				break;
 			}
 		}
 	}
 	else			/* Pick something universally useful. */
 	{
-		r = rand_int(43);
-		switch (r)
-		{
-			case 0:
-				a_ptr->flags1 |= TR1_STR;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_STR;
-				break;
-			case 1:
-				a_ptr->flags1 |= TR1_INT;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_INT;
-				break;
-			case 2:
-				a_ptr->flags1 |= TR1_WIS;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_WIS;
-				if (a_ptr->tval == TV_SWORD || a_ptr->tval == TV_POLEARM)
-					a_ptr->flags3 |= TR3_BLESSED;
-				break;
-			case 3:
-				a_ptr->flags1 |= TR1_DEX;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_DEX;
-				break;
-			case 4:
-				a_ptr->flags1 |= TR1_CON;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_CON;
-				break;
-			case 5:
-				a_ptr->flags1 |= TR1_CHR;
-				do_pval(a_ptr);
-				if (rand_int(2) == 0) a_ptr->flags2 |= TR2_SUST_CHR;
-				break;
+		r = rand_int(power);
 
-			case 6:
-				a_ptr->flags1 |= TR1_STEALTH;
-				do_pval(a_ptr);
-				break;
-			case 7:
-				a_ptr->flags1 |= TR1_SEARCH;
-				do_pval(a_ptr);
-				break;
-			case 8:
-				a_ptr->flags1 |= TR1_INFRA;
-				do_pval(a_ptr);
-				break;
-			case 9:
-				a_ptr->flags1 |= TR1_SPEED;
-				if (a_ptr->pval == 0) a_ptr->pval = (s16b)(3 + rand_int(3));
-				else do_pval(a_ptr);
-				break;
-
-			case 10:
-				a_ptr->flags2 |= TR2_SUST_STR;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_STR;
-					do_pval(a_ptr);
-				}
-				break;
-			case 11:
-				a_ptr->flags2 |= TR2_SUST_INT;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_INT;
-					do_pval(a_ptr);
-				}
-				break;
-			case 12:
-				a_ptr->flags2 |= TR2_SUST_WIS;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_WIS;
-					do_pval(a_ptr);
-					if (a_ptr->tval == TV_SWORD || a_ptr->tval == TV_POLEARM)
-						a_ptr->flags3 |= TR3_BLESSED;
-				}
-				break;
-			case 13:
-				a_ptr->flags2 |= TR2_SUST_DEX;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_DEX;
-					do_pval(a_ptr);
-				}
-				break;
-			case 14:
-				a_ptr->flags2 |= TR2_SUST_CON;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_CON;
-					do_pval(a_ptr);
-				}
-				break;
-			case 15:
-				a_ptr->flags2 |= TR2_SUST_CHR;
-				if (rand_int(2) == 0)
-				{
-					a_ptr->flags1 |= TR1_CHR;
-					do_pval(a_ptr);
-				}
-				break;
-
-			case 16:
+		if (r < 2)
+			x_ptr->flags3 |= TR3_LITE;
+		else if (r < 4)
+			x_ptr->flags3 |= TR3_FEATHER;
+		else if (r < 7)
+			x_ptr->flags3 |= TR3_SLOW_DIGEST;
+		else if (r < 10)
+			x_ptr->flags3 |= TR3_SEE_INVIS;
+		else if (r < 12)
+		{
+			switch (rand_int(6))
 			{
-				if (rand_int(3) == 0) a_ptr->flags2 |= TR2_IM_ACID;
-				break;
+			case 0: x_ptr->flags2 |= TR2_SUST_STR; break;
+			case 1: x_ptr->flags2 |= TR2_SUST_INT; break;
+			case 2: x_ptr->flags2 |= TR2_SUST_WIS; break;
+			case 3: x_ptr->flags2 |= TR2_SUST_DEX; break;
+			case 4: x_ptr->flags2 |= TR2_SUST_CON; break;
+			case 5: x_ptr->flags2 |= TR2_SUST_CHR; break;
 			}
-			case 17:
+		}
+		else if (r < 13)
+		{
+			x_ptr->flags1 |= TR1_INFRA;
+			do_pval(o_ptr);
+		}
+		else if (r < 14)
+		{
+			x_ptr->flags1 |= TR1_SEARCH;
+			do_pval(o_ptr);
+		}
+		else if (r < 15)
+		{
+			x_ptr->flags1 |= TR1_STEALTH;
+			do_pval(o_ptr);
+		}
+		else if (r < 19)
+		{
+			switch (rand_int(4))
 			{
-				if (rand_int(3) == 0) a_ptr->flags2 |= TR2_IM_ELEC;
-				break;
+			case 0: x_ptr->flags2 |= TR2_RES_ACID; break;
+			case 1: x_ptr->flags2 |= TR2_RES_ELEC; break;
+			case 2: x_ptr->flags2 |= TR2_RES_FIRE; break;
+			case 3: x_ptr->flags2 |= TR2_RES_COLD; break;
 			}
-			case 18:
+		}
+		else if (r < 21)
+		{
+			x_ptr->flags1 |= TR1_CHR;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_CHR;
+		}
+		else if (r < 23)
+		{
+			x_ptr->flags1 |= TR1_DEX;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_DEX;
+		}
+		else if (r < 25)
+		{
+			x_ptr->flags1 |= TR1_INT;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_INT;
+		}
+		else if (r < 27)
+		{
+			x_ptr->flags1 |= TR1_WIS;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_WIS;
+		}
+		else if (r < 29)
+		{
+			x_ptr->flags1 |= TR1_CON;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_CON;
+		}
+		else if (r < 31)
+		{
+			x_ptr->flags1 |= TR1_STR;
+			do_pval(o_ptr);
+			if (rand_int(3) != 0)
+				x_ptr->flags2 |= TR2_SUST_STR;
+		}
+		else if (r < 33)
+			x_ptr->flags3 |= TR3_REGEN;
+		else if (r < 34)
+			x_ptr->flags3 |= TR3_TELEPATHY;
+		else if (r < 38)
+		{
+			switch (rand_int(11))
 			{
-				if (rand_int(4) == 0) a_ptr->flags2 |= TR2_IM_FIRE;
-				break;
+			case 0:  x_ptr->flags2 |= TR2_RES_POIS; break;
+			case 1:  x_ptr->flags2 |= TR2_RES_LITE; break;
+			case 2:  x_ptr->flags2 |= TR2_RES_DARK; break;
+			case 3:  x_ptr->flags2 |= TR2_RES_BLIND; break;
+			case 4:  x_ptr->flags2 |= TR2_RES_CONFU; break;
+			case 5:  x_ptr->flags2 |= TR2_RES_SOUND; break;
+			case 6:  x_ptr->flags2 |= TR2_RES_SHARD; break;
+			case 7:  x_ptr->flags2 |= TR2_RES_NETHR; break;
+			case 8:  x_ptr->flags2 |= TR2_RES_NEXUS; break;
+			case 9:  x_ptr->flags2 |= TR2_RES_CHAOS; break;
+			case 10: x_ptr->flags2 |= TR2_RES_DISEN; break;
 			}
-			case 19:
+		}
+		else if (r < 41)
+			x_ptr->flags3 |= TR3_FREE_ACT;
+		else if (r < 44)
+			x_ptr->flags3 |= TR3_HOLD_LIFE;
+		else if (r < 48)
+		{
+			x_ptr->flags1 |= TR1_SPEED;
+			do_pval(o_ptr);
+			/* Supercharge! */
+			while (o_ptr->pval > 0 && rand_int(3) == 0)
+				o_ptr->pval++;
+		}
+		else
+		{
+			switch (rand_int(4))
 			{
-				if (rand_int(3) == 0) a_ptr->flags2 |= TR2_IM_COLD;
-				break;
+			case 0: x_ptr->flags2 |= TR2_IM_ACID; break;
+			case 1: x_ptr->flags2 |= TR2_IM_ELEC; break;
+			case 2: x_ptr->flags2 |= TR2_IM_FIRE; break;
+			case 3: x_ptr->flags2 |= TR2_IM_COLD; break;
 			}
-			case 20: a_ptr->flags3 |= TR3_FREE_ACT; break;
-			case 21: a_ptr->flags3 |= TR3_HOLD_LIFE; break;
-			case 22: a_ptr->flags2 |= TR2_RES_ACID; break;
-			case 23: a_ptr->flags2 |= TR2_RES_ELEC; break;
-			case 24: a_ptr->flags2 |= TR2_RES_FIRE; break;
-			case 25: a_ptr->flags2 |= TR2_RES_COLD; break;
-
-			case 26: a_ptr->flags2 |= TR2_RES_POIS; break;
-			case 27: a_ptr->flags2 |= TR2_RES_LITE; break;
-			case 28: a_ptr->flags2 |= TR2_RES_DARK; break;
-			case 29: a_ptr->flags2 |= TR2_RES_BLIND; break;
-			case 30: a_ptr->flags2 |= TR2_RES_CONFU; break;
-			case 31: a_ptr->flags2 |= TR2_RES_SOUND; break;
-			case 32: a_ptr->flags2 |= TR2_RES_SHARD; break;
-			case 33:
-				if (rand_int(2) == 0)
-					a_ptr->flags2 |= TR2_RES_NETHR;
-				break;
-			case 34: a_ptr->flags2 |= TR2_RES_NEXUS; break;
-			case 35: a_ptr->flags2 |= TR2_RES_CHAOS; break;
-			case 36:
-				if (rand_int(2) == 0)
-					a_ptr->flags2 |= TR2_RES_DISEN;
-				break;
-			case 37: a_ptr->flags3 |= TR3_FEATHER; break;
-			case 38: a_ptr->flags3 |= TR3_LITE; break;
-			case 39: a_ptr->flags3 |= TR3_SEE_INVIS; break;
-			case 40:
-				if (rand_int(3) == 0)
-					a_ptr->flags3 |= TR3_TELEPATHY;
-				break;
-			case 41: a_ptr->flags3 |= TR3_SLOW_DIGEST; break;
-
-			case 42:
-				a_ptr->flags3 |= TR3_REGEN; break;
 		}
 	}
 
 	/* Now remove contradictory or redundant powers. */
-	remove_contradictory(a_ptr);
+	remove_contradictory(o_ptr);
 }
 
 
 /*
  * Make it bad, or if it's already bad, make it worse!
  */
-static void do_curse(artifact_type *a_ptr)
+static void do_curse(object_type *o_ptr)
 {
+	randart_type *x_ptr = &x_info[o_ptr->name3];
+
 	if (rand_int(3) == 0)
-		a_ptr->flags3 |= TR3_AGGRAVATE;
+		x_ptr->flags3 |= TR3_AGGRAVATE;
 	if (rand_int(5) == 0)
-		a_ptr->flags3 |= TR3_DRAIN_EXP;
+		x_ptr->flags3 |= TR3_DRAIN_EXP;
 	if (rand_int(7) == 0)
-		a_ptr->flags3 |= TR3_TELEPORT;
+		x_ptr->flags3 |= TR3_TELEPORT;
 
-	if ((a_ptr->pval > 0) && (rand_int(2) == 0))
-		a_ptr->pval = -a_ptr->pval;
-	if ((a_ptr->to_a > 0) && (rand_int(2) == 0))
-		a_ptr->to_a = -a_ptr->to_a;
-	if ((a_ptr->to_h > 0) && (rand_int(2) == 0))
-		a_ptr->to_h = -a_ptr->to_h;
-	if ((a_ptr->to_d > 0) && (rand_int(4) == 0))
-		a_ptr->to_d = -a_ptr->to_d;
+	if ((o_ptr->pval > 0) && (rand_int(2) == 0))
+		o_ptr->pval = -o_ptr->pval;
+	if ((o_ptr->to_a > 0) && (rand_int(2) == 0))
+		o_ptr->to_a = -o_ptr->to_a;
+	if ((o_ptr->to_h > 0) && (rand_int(2) == 0))
+		o_ptr->to_h = -o_ptr->to_h;
+	if ((o_ptr->to_d > 0) && (rand_int(4) == 0))
+		o_ptr->to_d = -o_ptr->to_d;
 
-	if (a_ptr->flags3 & TR3_LIGHT_CURSE)
+	if (x_ptr->flags3 & TR3_LIGHT_CURSE)
 	{
-		if (rand_int(2) == 0) a_ptr->flags3 |= TR3_HEAVY_CURSE;
+		if (rand_int(2) == 0) x_ptr->flags3 |= TR3_HEAVY_CURSE;
 		return;
 	}
 
-	a_ptr->flags3 |= TR3_LIGHT_CURSE;
-	if (rand_int(4) == 0) a_ptr->flags3 |= TR3_HEAVY_CURSE;
+	x_ptr->flags3 |= TR3_LIGHT_CURSE;
+	if (rand_int(4) == 0) x_ptr->flags3 |= TR3_HEAVY_CURSE;
 }
 
 
-/*
- * Note the three special cases (One Ring, Grond, Morgoth).
- */
-static int scramble_artifact(int a_idx)
+static byte activation_table[60] = {
+	ACT_ILLUMINATION,
+	ACT_MISSILE,
+	ACT_PHASE,
+	ACT_CURE_WOUNDS,
+	ACT_FIRE1,
+	ACT_STINKING_CLOUD,
+	ACT_FROST1,
+	ACT_ILLUMINATION,
+	ACT_MISSILE,
+	ACT_CURE_WOUNDS,
+	ACT_TRAP_DOOR_DEST,
+	ACT_SLEEP,
+	ACT_STONE_TO_MUD,
+	ACT_FIRE1,
+	ACT_ILLUMINATION,
+	ACT_STINKING_CLOUD,
+	ACT_PHASE,
+	ACT_MISSILE,
+	ACT_FROST2,
+	ACT_ACID1,
+	ACT_PROBE,
+	ACT_REM_FEAR_POIS,
+	ACT_CONFUSE,
+	ACT_MAGIC_MAP,
+	ACT_TELEPORT,
+	ACT_MAGIC_MAP,
+	ACT_HEAL1,
+	ACT_HASTE1,
+	ACT_DETECT,
+	ACT_IDENTIFY,
+	ACT_RESIST,
+	ACT_FIRE2,
+	ACT_FROST3,
+	ACT_TELEPORT,
+	ACT_FROST4,
+	ACT_ELEC2,
+	ACT_FIRE3,
+	ACT_TELEPORT,
+	ACT_IDENTIFY,
+	ACT_RECHARGE1,
+	ACT_DRAIN_LIFE1,
+	ACT_PROT_EVIL,
+	ACT_LIGHTNING_BOLT,
+	ACT_DETECT,
+	ACT_RESIST,
+	ACT_TELE_AWAY,
+	ACT_ARROW,
+	ACT_WOR,
+	ACT_HASTE2,
+	ACT_HEAL2,
+	ACT_RAGE_BLESS_RESIST,
+	ACT_FROST5,
+	ACT_DISP_EVIL,
+	ACT_WOR,
+	ACT_FIREBRAND,
+	ACT_DRAIN_LIFE2,
+	ACT_STAR_BALL,
+	ACT_RESTORE_LIFE,
+	ACT_GENOCIDE,
+	ACT_MASS_GENOCIDE,
+};
+
+
+bool make_randart_stupid(object_type *o_ptr)
+{
+	int i;
+	int x_idx = 0;
+	randart_type *x_ptr;
+
+	for (i = 1; i < z_info->x_max; i++)
+	{
+		if (x_info[i].name[0]) continue;
+		x_idx = i;
+		break;
+	}
+
+	if (!x_idx) return (FALSE);
+
+	o_ptr->name3 = x_idx;
+
+	x_ptr = &x_info[x_idx];
+
+	x_ptr->flags1 = 0;
+	x_ptr->flags2 = 0;
+	x_ptr->flags3 = 0;
+
+	name_randart(x_ptr);
+
+	for (i = 0; i < 4; i++)
+		add_ability(o_ptr, 30);
+	for (i = 0; i < 2; i++)
+		add_ability(o_ptr, 50);
+
+	/*
+	 * Add TR3_HIDE_TYPE to all artifacts with nonzero pval because we're
+	 * too lazy to find out which ones need it and which ones don't.
+	 */
+	if (o_ptr->pval)
+		x_ptr->flags3 |= TR3_HIDE_TYPE;
+
+	return TRUE;
+
+}
+
+
+
+bool make_randart(object_type *o_ptr, bool curse)
 {
-	artifact_type *a_ptr = &a_info[a_idx];
-	u32b activates = a_ptr->flags3 & TR3_ACTIVATE;
+	randart_type *x_ptr;
+	object_kind *k_ptr = &k_info[o_ptr->k_idx];
+	int x_idx = 0;
 	s32b power;
 	int tries;
 	s32b ap;
-	bool curse_me = FALSE;
 	bool aggravate_me = FALSE;
+	int i;
+	u32b f1, f2, f3;
 
-	/* Special cases -- don't randomize these! */
-	if ((a_idx == ART_POWER) ||
-	    (a_idx == ART_GROND) ||
-	    (a_idx == ART_MORGOTH))
-		return 0;
-
-	/* Skip unused artifacts, too! */
-	if (a_ptr->tval == 0) return 0;
-
-	/* Evaluate the original artifact to determine the power level. */
-	power = artifact_power(a_idx, TRUE);
-	if (power < 0) curse_me = TRUE;
-
-	if (randart_verbose)
-		msg_format("Artifact %d: power = %d", a_idx, power);
-
-	/* Really powerful items should aggravate. */
-	if (power > 100)
+	/* Find a free index */
+	for (i = 1; i < z_info->x_max; i++)
 	{
-		if (rand_int(100) < (power - 100) * 3)
-			aggravate_me = TRUE;
+		if (x_info[i].name[0]) continue;
+		x_idx = i;
+		break;
 	}
+	if (!x_idx) return (FALSE);
+
+	/* Get the object's current flags */
+	object_flags(o_ptr, &f1, &f2, &f3);
+
+	/* Get the artifact */
+	x_ptr = &x_info[x_idx];
+
+	/* Clear the artifact */	
+	x_ptr->cost = k_ptr->cost;
+	x_ptr->flags1 = f1;
+	x_ptr->flags2 = f2;
+	x_ptr->flags3 = f3 & ~(TR3_ACTIVATE);
+	x_ptr->level = (p_ptr->depth + k_ptr->level) / 2;
+	x_ptr->activation = 0;
+	x_ptr->time = 0;
+	x_ptr->randtime = 0;
+
+	/* Name it */
+	name_randart(x_ptr);
+
+	/* Assign the artifact index */
+	o_ptr->name3 = x_idx;
+
+	/* Sometimes artifacts are deeper */
+	while (rand_int((x_ptr->level - (p_ptr->depth + k_ptr->level) / 2) * 4) == 0)
+		x_ptr->level++;
+
+	/* Get current power */
+	ap = artifact_power(o_ptr);
+
+	/* Find a power */
+	power = (ap + 30) / 2 + randint(x_ptr->level + 10);
 
-	if (a_idx >= ART_MIN_NORMAL)
+	/* Reduce powerful items */
+	if (power > ap + 30)
+		power = ap + 30 + randint(power - ap - 30);
+
+	/* Always add something */
+	if (power < ap + 10) power = ap + 10;
+
+	/* Find a power based on level and rarity */
+	if (curse)
+		power = -power;
+
+	/* Sometimes add an activation */
+	if (rand_int(200) < power)
 	{
-		/*
-		 * Normal artifact - choose a random base item type.  Not too
-		 * powerful, so we'll have to add something to it.  Not too
-		 * weak, for the opposite reason.
-		 */
-		int count = 0;
-		s32b ap2;
+		int m = x_ptr->level / 2 + 20;
+		if (m > 60)
+			m = 60;
 
-		do
+		x_ptr->flags3 |= TR3_ACTIVATE;
+		x_ptr->activation = activation_table[rand_int(m)];
+
+		/* Default values */
+		x_ptr->time = x_ptr->randtime = 2 + x_ptr->level * x_ptr->level / 4;
+
+		/* Find a real artifact with the right activation */
+		for (i = 0; i < ART_MIN_RANDART; i++)
 		{
-			choose_item(a_idx);
-			ap2 = artifact_power(a_idx, FALSE);
-			count++;
-		} while ((count < MAX_TRIES) &&
-			   ((ap2 > (power * 8) / 10 + 1) ||
-			    (ap2 < (power / 10))));
+			if (a_info[i].tval == 0) continue;
+			if (!(a_info[i].flags3 & TR3_ACTIVATE)) continue;
+			if (a_info[i].activation != x_ptr->activation) continue;
+
+			/* Base on that timeout */
+			x_ptr->time = a_info[i].time * a_info[i].level / x_ptr->level;
+			x_ptr->randtime = a_info[i].randtime * a_info[i].level / x_ptr->level;
+
+			/* Not too much worse */
+			if (x_ptr->time > a_info[i].time * 2) x_ptr->time = a_info[i].time * 2;
+			if (x_ptr->randtime > a_info[i].randtime * 2) x_ptr->randtime = a_info[i].randtime * 2;
+
+			break;
+		}
+
+		/* Ensure sanity */
+		if (x_ptr->time < 2) x_ptr->time = 2;
+		if (x_ptr->randtime < 0) x_ptr->randtime = 0;
 	}
-	else
-	{
-		/* Special artifact (light source, ring, or
-		   amulet).  Clear the following fields; leave
-		   the rest alone. */
-		a_ptr->pval = 0;
-		a_ptr->to_h = a_ptr->to_d = a_ptr->to_a = 0;
-		a_ptr->flags1 = a_ptr->flags2 = 0;
 
-		/* Artifacts ignore everything */
-		a_ptr->flags3 = (TR3_IGNORE_MASK);
+	/* Really powerful items should aggravate. */
+	if (power > 60)
+	{
+		if (rand_int(60) < (power - 60))
+			aggravate_me = TRUE;
 	}
 
 	/* First draft: add two abilities, then curse it three times. */
-	if (curse_me)
+	if (curse)
 	{
-		add_ability(a_ptr);
-		add_ability(a_ptr);
-		do_curse(a_ptr);
-		do_curse(a_ptr);
-		do_curse(a_ptr);
-		remove_contradictory(a_ptr);
-		ap = artifact_power(a_idx, FALSE);
+		add_ability(o_ptr, 20);
+		add_ability(o_ptr, 20);
+		do_curse(o_ptr);
+		do_curse(o_ptr);
+		do_curse(o_ptr);
+		remove_contradictory(o_ptr);
+		ap = artifact_power(o_ptr);
 	}
 	else
 	{
 		/*
@@ -1921,18 +2053,21 @@
 		 * original's in terms of overall power/usefulness.
 		 */
 		for (tries = 0; tries < MAX_TRIES; tries++)
 		{
-			artifact_type a_old;
+			object_type o_old;
+			randart_type x_old;
 
 			/* Copy artifact info temporarily. */
-			a_old = *a_ptr;
-			add_ability(a_ptr);
-			ap = artifact_power(a_idx, FALSE);
+			o_old = *o_ptr;
+			x_old = *x_ptr;
+			add_ability(o_ptr, 20 + randint(power * 2 / 3));
+			ap = artifact_power(o_ptr);
 			if (ap > (power * 11) / 10 + 1)
 			{
 				/* too powerful -- put it back */
-				*a_ptr = a_old;
+				*o_ptr = o_old;
+				*x_ptr = x_old;
 				continue;
 			}
 
 			else if (ap >= (power * 9) / 10)	/* just right */
@@ -1941,171 +2076,32 @@
 			}
 
 			/* Stop if we're going negative, so we don't overload
 			   the artifact with great powers to compensate. */
-			else if ((ap < 0) && (ap < (-(power * 1)) / 10))
+			else if ((ap < 0) && (ap < (-(power * 5)) / 10))
 			{
 				break;
 			}
 		}		/* end of power selection */
 
 		if (aggravate_me)
 		{
-			a_ptr->flags3 |= TR3_AGGRAVATE;
-			remove_contradictory(a_ptr);
-			ap = artifact_power(a_idx, FALSE);
+			x_ptr->flags3 |= TR3_AGGRAVATE;
+			remove_contradictory(o_ptr);
+			ap = artifact_power(o_ptr);
 		}
 	}
 
-	a_ptr->cost = ap * (s32b)1000;
+	x_ptr->cost = ap * (s32b)(400 + 100 * randint(6));
 
-	if (a_ptr->cost < 0) a_ptr->cost = 0;
-
-#if 0
-	/* One last hack: if the artifact is very powerful, raise the rarity.
-	   This compensates for artifacts like (original) Bladeturner, which
-	   have low artifact rarities but came from extremely-rare base
-	   kinds. */
-	if ((ap > 0) && ((ap / 8) > a_ptr->rarity))
-		a_ptr->rarity = ap / 8;
-#endif /* 0 */
-
-	/* Restore some flags */
-	if (activates) a_ptr->flags3 |= TR3_ACTIVATE;
-	if (a_idx < ART_MIN_NORMAL) a_ptr->flags3 |= TR3_INSTA_ART;
+	if (x_ptr->cost < 0) x_ptr->cost = 0;
 
 	/*
 	 * Add TR3_HIDE_TYPE to all artifacts with nonzero pval because we're
 	 * too lazy to find out which ones need it and which ones don't.
 	 */
-	if (a_ptr->pval)
-		a_ptr->flags3 |= TR3_HIDE_TYPE;
-
-	return 0;
-}
-
-
-/*
- * Return nonzero if the whole set of random artifacts meets certain
- * criteria.  Return 0 if we fail to meet those criteria (which will
- * restart the whole process).
- */
-static int artifacts_acceptable(void)
-{
-	int swords = 5, polearms = 5, blunts = 5, bows = 3;
-	int bodies = 5, shields = 3, cloaks = 3, hats = 4;
-	int gloves = 4, boots = 4;
-	int i;
-
-	for (i = ART_MIN_NORMAL; i < z_info->a_max; i++)
-	{
-		switch (a_info[i].tval)
-		{
-			case TV_SWORD:
-				swords--; break;
-			case TV_POLEARM:
-				polearms--; break;
-			case TV_HAFTED:
-				blunts--; break;
-			case TV_BOW:
-				bows--; break;
-			case TV_SOFT_ARMOR:
-			case TV_HARD_ARMOR:
-				bodies--; break;
-			case TV_SHIELD:
-				shields--; break;
-			case TV_CLOAK:
-				cloaks--; break;
-			case TV_HELM:
-			case TV_CROWN:
-				hats--; break;
-			case TV_GLOVES:
-				gloves--; break;
-			case TV_BOOTS:
-				boots--; break;
-		}
-	}
-
-	if (swords > 0 || polearms > 0 || blunts > 0 || bows > 0 ||
-	    bodies > 0 || shields > 0 || cloaks > 0 || hats > 0 ||
-	    gloves > 0 || boots > 0)
-	{
-		if (randart_verbose)
-		{
-			char types[256];
-			sprintf(types, "%s%s%s%s%s%s%s%s%s%s",
-				swords > 0 ? " swords" : "",
-				polearms > 0 ? " polearms" : "",
-				blunts > 0 ? " blunts" : "",
-				bows > 0 ? " bows" : "",
-				bodies > 0 ? " body-armors" : "",
-				shields > 0 ? " shields" : "",
-				cloaks > 0 ? " cloaks" : "",
-				hats > 0 ? " hats" : "",
-				gloves > 0 ? " gloves" : "",
-				boots > 0 ? " boots" : "");
-			msg_format("Restarting generation process: not enough%s\n",
-				types);
-		}
-		return 0;
-	}
-	else
-	{
-		return 1;
-	}
-}
-
-
-static int scramble(void)
-{
-	/* This outer loop is for post-processing.  If our artifact set
-	   fails to meet certain criteria, we start over. :-( */
-	do
-	{
-		int a_idx;
-
-		/* Generate all the artifacts. */
-		for (a_idx = 1; a_idx < z_info->a_max; a_idx++)
-		{
-			scramble_artifact(a_idx);
-		}
-	} while (!artifacts_acceptable());	/* end of all artifacts */
-
-	return 0;
-}
-
-
-static int do_randart_aux(void)
-{
-	int result;
-
-	if ((result = init_names()) != 0) return result;
-
-	if ((result = scramble()) != 0) return result;
+	if (o_ptr->pval)
+		x_ptr->flags3 |= TR3_HIDE_TYPE;
 
 	return 0;
 }
 
-
-int do_randart(u32b randart_seed)
-{
-	int rc;
-
-	/* Prepare to use the Angband "simple" RNG. */
-	Rand_value = randart_seed;
-	Rand_quick = TRUE;
-
-	/* Allocate the "kinds" array */
-	C_MAKE(kinds, z_info->a_max, s16b);
-
-	rc = do_randart_aux();
-
-	/* Free the "kinds" array */
-	C_FREE(kinds, z_info->a_max, s16b);
-
-	/* When done, resume use of the Angband "complex" RNG. */
-	Rand_quick = FALSE;
-
-	return rc;
-}
-
-#endif /* GJW_RANDART */
Only in antiband/src: readdib.c
Only in antiband/src: readdib.h
diff --recursive --unified=4 angband-291/src/save.c antiband/src/save.c
--- angband-291/src/save.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/save.c	Thu Nov  1 23:23:32 2001
@@ -1030,8 +1060,9 @@
 
 	/* Dump the stats (maximum and current) */
 	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_max[i]);
 	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_cur[i]);
+	for (i = 0; i < A_MAX; ++i) wr_s16b(p_ptr->stat_lim[i]);
 
 	/* Ignore the transient stats */
 	for (i = 0; i < 12; ++i) wr_s16b(0);

diff --recursive --unified=4 angband-291/src/spells1.c antiband/src/spells1.c
--- angband-291/src/spells1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/spells1.c	Thu Nov 15 01:43:34 2001
@@ -950,9 +954,9 @@
 	/* Then augment the current/max stat */
 	value = p_ptr->stat_cur[stat];
 
 	/* Cannot go above 18/100 */
-	if (value < 18+100)
+	if (value < p_ptr->stat_lim[stat])
 	{
 		/* Gain one (sometimes two) points */
 		if (value < 18)
 		{
@@ -960,21 +964,21 @@
 			value += gain;
 		}
 
 		/* Gain 1/6 to 1/3 of distance to 18/100 */
-		else if (value < 18+98)
+		else if (value < p_ptr->stat_lim[stat] - 2)
 		{
 			/* Approximate gain value */
-			gain = (((18+100) - value) / 2 + 3) / 2;
+			gain = ((p_ptr->stat_lim[stat] - value) / 2 + 3) / 2;
 
 			/* Paranoia */
 			if (gain < 1) gain = 1;
 
 			/* Apply the bonus */
 			value += randint(gain) + gain / 2;
 
 			/* Maximal value */
-			if (value > 18+99) value = 18 + 99;
+			if (value > p_ptr->stat_lim[stat] - 1) value = p_ptr->stat_lim[stat] - 1;
 		}
 
 		/* Gain one point at a time */
 		else
@@ -1241,9 +1245,9 @@
  * Apply Nexus
  */
 static void apply_nexus(monster_type *m_ptr)
 {
-	int max1, cur1, max2, cur2, ii, jj;
+	int max1, cur1, max2, cur2, lim1, lim2, ii, jj;
 
 	switch (randint(7))
 	{
 		case 1: case 2: case 3:
@@ -1286,15 +1290,19 @@
 			for (jj = ii; jj == ii; jj = rand_int(6)) /* loop */;
 
 			max1 = p_ptr->stat_max[ii];
 			cur1 = p_ptr->stat_cur[ii];
+			lim1 = p_ptr->stat_lim[ii];
 			max2 = p_ptr->stat_max[jj];
 			cur2 = p_ptr->stat_cur[jj];
+			lim2 = p_ptr->stat_lim[jj];
 
 			p_ptr->stat_max[ii] = max2;
 			p_ptr->stat_cur[ii] = cur2;
+			p_ptr->stat_lim[ii] = lim2;
 			p_ptr->stat_max[jj] = max1;
 			p_ptr->stat_cur[jj] = cur1;
+			p_ptr->stat_lim[jj] = lim1;
 
 			p_ptr->update |= (PU_BONUS);
 
 			break;
@@ -1964,9 +1972,9 @@
  * also set "notice" to FALSE, or the player will learn what the spell does.
  *
  * We attempt to return "TRUE" if the player saw anything "useful" happen.
  */
-static bool project_m(int who, int r, int y, int x, int dam, int typ)
+static bool project_m(int who, int r, int y, int x, int dam, int typ, bool breath)
 {
 	int tmp;
 
 	monster_type *m_ptr;
@@ -2031,8 +2039,14 @@
 	l_ptr = &l_list[m_ptr->r_idx];
 	name = (r_name + r_ptr->name);
 	if (m_ptr->ml) seen = TRUE;
 
+#if 0
+	/* Never affect other monsters in same pack with breath weapons */
+	if (breath && (r_ptr->flags1 & RF1_GROUP_MASK) && who && m_list[who].r_idx == m_ptr->r_idx)
+		return (FALSE);
+#endif
+
 
 	/* Reduce damage by distance */
 	dam = (dam + r) / (r + 1);
 
@@ -3368,9 +3382,9 @@
 			if (p_ptr->resist_chaos)
 			{
 				dam *= 6; dam /= (randint(6) + 6);
 			}
-			if (!p_ptr->resist_confu)
+			if (!p_ptr->resist_confu && !p_ptr->resist_chaos)
 			{
 				(void)set_confused(p_ptr->confused + rand_int(20) + 10);
 			}
 			if (!p_ptr->resist_chaos)
@@ -4179,9 +4193,9 @@
 			y = gy[i];
 			x = gx[i];
 
 			/* Affect the monster in the grid */
-			if (project_m(who, dist, y, x, dam, typ)) notice = TRUE;
+			if (project_m(who, dist, y, x, dam, typ, rad > 0)) notice = TRUE;
 		}
 
 		/* Player affected one monster (without "jumping") */
 		if ((who < 0) && (project_m_n == 1) && !(flg & (PROJECT_JUMP)))
diff --recursive --unified=4 angband-291/src/spells2.c antiband/src/spells2.c
--- angband-291/src/spells2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/spells2.c	Thu Nov 15 01:46:46 2001
 	/* Analyze the weapon */
 	if (o_ptr->k_idx)
 	{
 		/* Special "Attack Bonuses" */
+		if (f1 & (TR1_BRAND_NETHR))
+		{
+			info[i++] = "Your weapon drains your foes of life.";
+		}
+		if (f1 & (TR1_BRAND_NEXUS))
+		{
+			info[i++] = "Your weapon warps space around your foes.";
+		}
+		if (f1 & (TR1_BRAND_CHAOS))
+		{
+			info[i++] = "Your weapon smites your foes with chaos.";
+		}
 		if (f1 & (TR1_BRAND_ACID))
 		{
 			info[i++] = "Your weapon melts your foes.";
 		}
@@ -2346,8 +2468,55 @@
 	if (speed) msg_print("You feel a sudden stirring nearby!");
 	else if (sleep) msg_print("You hear a sudden stirring in the distance!");
 }
 
+/*
+ * Wake up "los" monsters.
+ */
+void wake_monsters(int who)
+{
+	int i;
+
+	/* Aggravate everyone nearby */
+	for (i = 1; i < m_max; i++)
+	{
+		monster_type *m_ptr = &m_list[i];
+		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+
+		/* Paranoia -- Skip dead monsters */
+		if (!m_ptr->r_idx) continue;
+
+		/* Skip aggravating monster (or player) */
+		if (i == who) continue;
+
+		/* Wake up sleeping monsters in los of shouting monster */
+		if (los(m_list[who].fy, m_list[who].fx, m_ptr->fy, m_ptr->fx))
+		{
+			/* Wake up */
+			if (m_ptr->csleep)
+			{
+				/* Wake up */
+				m_ptr->csleep = 0;
+
+				/* Notice the "waking up" */
+				if (m_ptr->ml)
+				{
+					char m_name[80];
+
+					/* Get the monster name */
+					monster_desc(m_name, m_ptr, 0);
+
+					/* Dump a message */
+					msg_format("%^s wakes up.", m_name);
+
+					/* Hack -- Update the health bar */
+					if (p_ptr->health_who == who) p_ptr->redraw |= (PR_HEALTH);
+				}
+			}
+		}
+	}
+}
+
 
 
 /*
  * Delete all non-unique monsters of a given "type" from the level
@@ -3262,8 +3431,11 @@
 bool fire_ball(int typ, int dir, int dam, int rad)
 {
 	int py = p_ptr->py;
 	int px = p_ptr->px;
+	int sx, sy;
+
+	int d;
 
 	int ty, tx;
 
 	int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
@@ -3282,8 +3454,60 @@
 	}
 
 	/* Analyze the "dir" and the "target".  Hurt items on floor. */
 	return (project(-1, rad, ty, tx, dam, typ, flg));
+}
+
+bool fire_meteor(int typ, int dir, int dam, int rad, int scatter, int num)
+{
+	int py = p_ptr->py;
+	int px = p_ptr->px;
+	int sx, sy;
+
+	int d, i;
+
+	int ty, tx;
+	int fx, fy;
+	bool result = FALSE;
+
+	int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
+
+	/* Use the given direction */
+	ty = py + 99 * ddy[dir];
+	tx = px + 99 * ddx[dir];
+
+	/* Hack -- Use an actual "target" */
+	if ((dir == 5) && target_okay())
+	{
+		flg &= ~(PROJECT_STOP);
+
+		ty = p_ptr->target_row;
+		tx = p_ptr->target_col;
+	}
+
+	for (i = 0; i < num; i++)
+	{
+		fx = tx;
+		fy = ty;
+
+		/* Scatter a bit */
+		d = (distance(py, px, ty, tx) * scatter + 9) / 10;
+		if (d > 0)
+		{
+			do
+			{
+				sx = rand_int(2 * d + 1) - d;
+				sy = rand_int(2 * d + 1) - d;
+			}
+			while (distance(ty, tx, ty + sy, tx + sx) > d);
+			fy += sy;
+			fx += sx;
+		}
+
+		/* Analyze the "dir" and the "target".  Hurt items on floor. */
+		if (project(-1, rad, fy, fx, dam, typ, flg)) result = TRUE;
+	}
+	return (result);
 }
 
 
 /*
diff --recursive --unified=4 angband-291/src/store.c antiband/src/store.c
--- angband-291/src/store.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/store.c	Thu Nov  8 20:05:22 2001
@@ -1161,21 +1167,29 @@
 
 	object_type *i_ptr;
 	object_type object_type_body;
 
+	bool random;
+
+	random = (rand_int(100) < 20);
 
 	/* Paranoia -- no room left */
 	if (st_ptr->stock_num >= st_ptr->stock_size) return;
 
 
-	/* Hack -- consider up to four items */
-	for (tries = 0; tries < 4; tries++)
+	/* Hack -- consider up to four items, fifty if random */
+	for (tries = 0; tries < random ? 50 : 4; tries++)
 	{
 		/* Black Market */
 		if (store_num == STORE_B_MARKET)
 		{
 			/* Pick a level for object/magic */
-			level = 25 + rand_int(25);
+			/* ANTIBAND: Increased maximum level for BM items */
+			level = 20 + rand_int(50);
+
+			/* Deliberate cruelty - stock some terrific stuff at the beginning */
+			if (turn < 50 && rand_int(4) == 0)
+				level = 120;
 
 			/* Random object kind (usually of given level) */
 			k_idx = get_obj_num(level);
 
@@ -1185,13 +1199,29 @@
 
 		/* Normal Store */
 		else
 		{
-			/* Hack -- Pick an object kind to sell */
-			k_idx = st_ptr->table[rand_int(st_ptr->table_num)];
+			/* ANTIBAND: Sometimes create random items of a type the store will buy */
+			if (random)
+			{
+				/* Pick a level for object/magic */
+				/* ANTIBAND: Increased maximum level for BM items, reduced minimum */
+				level = 5 + rand_int(30);
+
+				/* Random object kind (usually of given level) */
+				k_idx = get_obj_num(level);
+
+				/* Handle failure */
+				if (!k_idx) continue;
+			}
+			else
+			{
+				/* Hack -- Pick an object kind to sell */
+				k_idx = st_ptr->table[rand_int(st_ptr->table_num)];
 
-			/* Hack -- fake level for apply_magic() */
-			level = rand_range(1, STORE_OBJ_LEVEL);
+				/* Hack -- fake level for apply_magic() */
+				level = rand_range(1, STORE_OBJ_LEVEL);
+			}
 		}
 
 
 		/* Get local object */
@@ -1236,8 +1270,11 @@
 			/* No "worthless" items */
 			if (object_value(i_ptr) <= 0) continue;
 		}
 
+		/* Prune all stores */
+		if (!store_will_buy(i_ptr)) continue;
+
 
 		/* Mass produce and/or Apply discount */
 		mass_produce(i_ptr);
 
diff --recursive --unified=4 angband-291/src/wizard1.c antiband/src/wizard1.c
--- angband-291/src/wizard1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/wizard1.c	Tue Oct 30 11:10:48 2001
@@ -486,8 +486,11 @@
  * Elemental brands for weapons
  */
 static flag_desc brand_flags_desc[] =
 {
+	{ TR1_BRAND_NETHR,		  "Nether Brand" },
+	{ TR1_BRAND_NEXUS,		  "Nexus Brand" },
+	{ TR1_BRAND_CHAOS,		  "Chaos Brand" },
 	{ TR1_BRAND_ACID,         "Acid Brand" },
 	{ TR1_BRAND_ELEC,         "Lightning Brand" },
 	{ TR1_BRAND_FIRE,         "Flame Tongue" },
 	{ TR1_BRAND_COLD,         "Frost Brand" },
@@ -562,9 +565,9 @@
 	{ TR3_HOLD_LIFE,          "Hold Life" },
 	{ TR3_BLESSED,            "Blessed Blade" },
 	{ TR3_IMPACT,             "Earthquake impact on hit" },
 	{ TR3_AGGRAVATE,          "Aggravates" },
-	{ TR3_DRAIN_EXP,          "Drains Experience" }
+	{ TR3_DRAIN_EXP,          "Drains Experience" },
 };
 
 /*
  * A special type used just for deailing with pvals
@@ -927,8 +930,10 @@
  */
 
 static void object_analyze(object_type *o_ptr, obj_desc_list *desc_x_ptr)
 {
+	static char buffer[80];
+
 	analyze_general(o_ptr, desc_x_ptr->description);
 
 	analyze_pval(o_ptr, &desc_x_ptr->pval_info);
 
@@ -945,18 +950,18 @@
 	analyze_misc_magic(o_ptr, desc_x_ptr->misc_magic);
 
 	analyze_misc(o_ptr, desc_x_ptr->misc_desc);
 
-	desc_x_ptr->activation = item_activation(o_ptr);
+	desc_x_ptr->activation = item_activation(o_ptr, buffer);
 }
 
 
 static void print_header(void)
 {
 	char buf[80];
 
-	sprintf(buf, "Artifact Spoilers for Angband Version %d.%d.%d",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	sprintf(buf, "Artifact Spoilers for Antiband Version %d.%d.%d",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	spoiler_underline(buf);
 }
 
 /*
@@ -1169,8 +1174,12 @@
 	o_ptr->to_h = a_ptr->to_h;
 	o_ptr->to_d = a_ptr->to_d;
 	o_ptr->weight = a_ptr->weight;
 
+	/* Curse it if needed */
+	if (a_ptr->flags3 & TR3_LIGHT_CURSE)
+		o_ptr->ident |= IDENT_CURSED;
+
 	/* Success */
 	return (TRUE);
 }
 
@@ -1297,10 +1306,10 @@
 		return;
 	}
 
 	/* Dump the header */
-	fprintf(fff, "Monster Spoilers for Angband Version %d.%d.%d\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	fprintf(fff, "Monster Spoilers for Antiband Version %d.%d.%d\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	fprintf(fff, "------------------------------------------\n\n");
 
 	/* Dump the header */
 	fprintf(fff, "%-40.40s%4s%4s%6s%8s%4s  %11.11s\n",
@@ -1529,10 +1538,10 @@
 	}
 
 
 	/* Dump the header */
-	sprintf(buf, "Monster Spoilers for Angband Version %d.%d.%d\n",
-	        VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH);
+	sprintf(buf, "Monster Spoilers for Antiband Version %d.%d.%d\n",
+	        VERSION_MAJOR % 10, VERSION_MINOR, VERSION_PATCH);
 	spoil_out(buf);
 	spoil_out("------------------------------------------\n\n");
 
 	/* Allocate the "who" array */
@@ -1726,9 +1735,9 @@
 
 		/* Collect inate attacks */
 		vn = 0;
 		if (flags4 & (RF4_SHRIEK)) vp[vn++] = "shriek for help";
-		if (flags4 & (RF4_XXX2)) vp[vn++] = "do something";
+		if (flags4 & (RF4_SCREAM)) vp[vn++] = "scream for help";
 		if (flags4 & (RF4_XXX3)) vp[vn++] = "do something";
 		if (flags4 & (RF4_XXX4)) vp[vn++] = "do something";
 		if (flags4 & (RF4_ARROW_1)) vp[vn++] = "fire arrows";
 		if (flags4 & (RF4_ARROW_2)) vp[vn++] = "fire arrows";
diff --recursive --unified=4 angband-291/src/wizard2.c antiband/src/wizard2.c
--- angband-291/src/wizard2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/wizard2.c	Sun Nov  4 13:34:40 2001
@@ -150,9 +150,9 @@
 	/* Query the stats */
 	for (i = 0; i < A_MAX; i++)
 	{
 		/* Prompt */
-		sprintf(ppp, "%s (3-118): ", stat_names[i]);
+		sprintf(ppp, "%s (3-%i): ", stat_names[i], p_ptr->stat_lim[i]);
 
 		/* Default */
 		sprintf(tmp_val, "%d", p_ptr->stat_max[i]);
 
@@ -162,9 +162,9 @@
 		/* Extract */
 		tmp_int = atoi(tmp_val);
 
 		/* Verify */
-		if (tmp_int > 18+100) tmp_int = 18+100;
+		if (tmp_int > p_ptr->stat_lim[i]) tmp_int = p_ptr->stat_lim[i];
 		else if (tmp_int < 3) tmp_int = 3;
 
 		/* Save it */
 		p_ptr->stat_cur[i] = p_ptr->stat_max[i] = tmp_int;

diff --recursive --unified=4 angband-291/src/xtra1.c antiband/src/xtra1.c
--- angband-291/src/xtra1.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/xtra1.c	Thu Nov 15 01:39:52 2001
@@ -22,9 +22,13 @@
 	if (val > 18)
 	{
 		int bonus = (val - 18);
 
-		if (bonus >= 100)
+		if (bonus > 999)
+		{
+			strcpy(out_val, "18/***");
+		}
+		else if (bonus >= 100)
 		{
 			sprintf(out_val, "18/%03d", bonus);
 		}
 		else
@@ -130,9 +134,9 @@
 		c_put_str(TERM_L_GREEN, tmp, ROW_STAT + stat, COL_STAT + 6);
 	}
 
 	/* Indicate natural maximum */
-	if (p_ptr->stat_max[stat] == 18+100)
+	if (p_ptr->stat_max[stat] == p_ptr->stat_lim[stat])
 	{
 		put_str("!", ROW_STAT + stat, 3);
 	}
 }

diff --recursive --unified=4 angband-291/src/xtra2.c antiband/src/xtra2.c
--- angband-291/src/xtra2.c	Tue Jul 25 19:57:49 2000
+++ antiband/src/xtra2.c	Sun Nov  4 12:55:04 2001
@@ -1772,10 +1772,10 @@
 static int get_coin_type(monster_race *r_ptr)
 {
 	cptr name = (r_name + r_ptr->name);
 
-	/* Analyze "coin" monsters */
-	if (r_ptr->d_char == '$')
+	/* Analyze "coin" monsters and golems */
+	if (strchr("$g", r_ptr->d_char))
 	{
 		/* Look for textual clues */
 		if (strstr(name, " copper ")) return (2);
 		if (strstr(name, " silver ")) return (5);
