Developer Notes
===============

This is a place designed for developer discussion.  Comment at
appropriate places.

2: New method to enchant
------------------------
Here's a cut-n-paste from #angband:

<takkaria> parody; I'm thinking about allowing scrolls of enchant
armour/to-hit/to-dam to work on anything which can have those bonuses...
<takkaria> parody; so an amulet of slaying can have to-hit/to-dam scrolls
read on it
<parody> takk, an additional type for these?
<parody> takk, perhaps they should be deeper/rarer/more expensive as well...
<parody> you have the standard armor/weapon enchantment scrolls, and
a special type for adding armor or combat bonuses to misc. equipment

<_458_jir> how about adding 'enchant' to chance of destroying the item?
<_458_jir> you can enchant till +15 in place of +9, with risk of destroying it

<takkaria> I had the following plan ages ago:
<takkaria> Rewrite enchant() to work on forumulas instead of a table. 
<takkaria> Also change it so it gets harder to enchant to-dam as you get
<takkaria> nearer the maximum damage the weapon can do.  So a 1d4 dagger
<takkaria> is easy to get +1 dam, fairly easy to get +2 dam, fairly hard
<takkaria> to get +3 dam, and hard to get +4 dam.
<takkaria> [end]
<_458_jir> Scroll of enchant amulet To-Dam?
<takkaria> scroll of Equipment Enhancement, maybe
<takkaria> so you'd have to have seperate scrolls if I ever did the above
<parody> something of that nature...
that would allow you to add combat bonuses to something like belts...

--moose-- a decent name will be fun to come up with :)  other than
that, what do people think of this?


1: Behaviour of new monster lighting
------------------------------------
ABSORB_LIGHT monsters will absorb nearby light, reducing the practical
radius of the light to 0.

EMANATE_LIGHT monsters emit light; radius should be 2 or 3, depending on
level.

CARRY_LIGHT monsters are theoretically "carrying" light sources, which
should be radius 1 or 2, depending on level; probably, the transition
shouldn't occur much later than dungeon level 15.

--MS-- Could this light source be dropped or somehow run out?

--GW-- well if a basic monster inventory could be created this could
done, however the balancing issues would be pretty major. Of course
if we are to make this variant truely different then this could be an
interesting way of doing it. Another way could be to add lines into
the info files for the monsters to specify some generic drop types
I suppose themed drops would be more accurate, in fact I think this
has been done in other variants, but I'm not too sure how successfully
though. The main problem with the second idea is that the light source
wouldn't 'exist' until the creature is killed and therefore would be
more difficult to make run out in a nice way.

--MS-- Hmm. That takes in a completely differant direction than I had
originally intended (not a bad thing at all ;).  I will attempt to clarify
what I was thinking when I made that comment.  My idea of dropping, in
this case, was merely the monster losing their source of light. The light
source running out would achieve the same goal. This would be in contrast
to the monsters which emanate light; who either inherently emit light
from their bodies, or somehow have a light source (most likely magical in
nature).  Even these monsters could lose their source of light, but it
would take much more to affect them.  Perhaps a critical hit, or certain
spells could cause a monster carrying a light to drop it, whereas one
that emanates light would find that his light source becomes weaker as
his life force declines. Their light could shrink in radius,
proportionately with their hitpoints, possibly even affecting how they
interact with ABSORB_LIGHT monsters...

--moose-- Interesting.  I like the idea; in my last attempt at doing
monster light (which was in Elasticband, which is long dead now), monsters
did drop torches; this tended to get somewhat annoying.  I'm pondering over
implementing something like ARFC003 - Autodumper.
http://everything.vaevictus.net/?node=Autodumper+ARFC+003 contains details
on it; with it, there wouldn't be as much tedium with monsters dropping
lights, or even themed drops.
[note to moose: remember to go through the todo list again sometime soon]

--MS-- About monster inventories. I love the idea, and i think any steps
taken towards it would be well worth it.  Generic or themed drops would
be a good way to implement them cleanly and relatively quickly.  A good
place to start might be with uniques.  Giving a couple deep uniques set
drops, mostly in artifact form, would be a good step towards a full system.
And furthermore, it would be able to hold it's own as a feature, even if that
is as far as we take the concept. A more comprehensive system would be more
trouble than it is worth at this point in time, but something that should
definately not be ruled out.  I think it will be difficult to implement
this because a "real" monster inventory system would be one that allows
the monster access to it's inventory and the benefits that it would
receive from them.

--moose-- see above.

If an ABSORB_LIGHT monster is in the vicinity of a [CARRY|EMANATE]_LIGHT
monster, the priority of effects is EMANATE_LIGHT, ABSORB_LIGHT and then
CARRY_LIGHT.  CARRY_LIGHT monsters may be scared by the absence of
light, and may try to get away.

--GW-- hmm, if a monster with [EMANATE|CARRY]_LIGHT has no other way of
seeing in the dark (ie infra_vision, esp, etc) then maybe they would
fear being in the dark, or maybe ,if they do have an alternate sense,
the may just merely be slightly more timid and not all out scared.

--MS-- ABSORB_LIGHT monster could also possibly be afraid of EMANATE_LIGHT
monsters.

--GW-- see above

--pel^2-- This light priority rule would require three m_list loops
(lighting for CARRY_LIGHT, darkening for ABSORB_LIGHT, followed by lighting
for EMANATE_LIGHT), all using Z's fairly complicated multiple radii code.
It can be done, but I wonder how practical it is. CPUs are faster than
necessary these days, though. And if you don't like players to see
through darkness created by ABSORB_LIGHT monsters, we have to rewrite
update_view() as well, that means very substantial amount of work...

--moose-- I think that the amount of work required it worth it.  It would add
another element to the game, which is atmosphere.  Some of it may have to be
optional, though; maybe have view_monster_light which just does monster lighting
and absorbing, then have monster_light_complex or whatever to do the different
loops for each one. 

--pel^2-- Here's the outline of a light priority code
Prerequisites:
+ CAVE2_MDARK for cave_info2.
+ Another CAVE_TEMP flag, maybe called CAVE2_TEMP.

Outline:
+ Monster-lit grids are marked with CAVE_TEMP and monster-darkened ones
  CAVE2_TEMP.
+ Remove CAVE2_MLIGHT and CAVE2_MDARK flags from light_g grids, while
  dropping CAVE_SEEN from grids illuminated only by monster light sources,
  adding CAVE_SEEN from CAVE_GLOW grids darkened by monster darkness.
+ Scan through m_list, rejecting those with cdis > MAX_SIGHT + 3 and
  those who don't have lighting flags set. Store their positions,
  light/darkness radii and light priority in a temporary array.
+ (Important) Sort the temporary array by light priority.
+ Process the sorted just like update_monster_light now handles m_list.
+ Because the current code avoids overwriting already affected grids,
  this should eliminate the possibility of light/temp array overflow
  and handle lighting priority correctly, i.e. 
  if (info2 & (CAVE2_MLIGHT | CAVE2_MDARK)) continue;
  For EMANATE_LIGHT and CARRY_LIGHT it sets CAVE2_MLIGHT and CAVE_SEEN.
  For ABSORB_LIGHT, it sets CAVE2_MLIGHT and clears CAVE_SEEN (unless
  CAVE2_PLIGHT is set? I'm not sure).
+ Double the number of conditions in the redraw code in update_monster_light,
  to handle the effects of CAVE2_TEMP and CAVE2_MDARK.
+ In update_view, add "&& !(info2 & (CAVE2_MDARK))" whenever it checks
  CAVE_GLOW.

And here's the diff (VERY long -- feel free to remove it):
diff -ur nangband/src/cave.c pelpel/src/cave.c
--- nangband/src/cave.c	Mon Jul 29 10:47:35 2002
+++ pelpel/src/cave.c	Mon Jul 29 12:25:45 2002
@@ -2731,7 +2731,8 @@
 						}
 
 						/* Perma-lit grids */
-						else if (info & (CAVE_GLOW))
+						else if ((info & (CAVE_GLOW)) &&
+						         !(info2 & (CAVE2_MDARK)))
 						{
 							int y = GRID_Y(g);
 							int x = GRID_X(g);
@@ -2744,11 +2745,14 @@
 
 							/* Check for "complex" illumination */
 							if ((!(cave_info[yy][xx] & (CAVE_WALL)) &&
-							      (cave_info[yy][xx] & (CAVE_GLOW))) ||
+							      (cave_info[yy][xx] & (CAVE_GLOW)) &&
+							     !(cave_info2[yy][xx] & (CAVE2_MDARK))) ||
 							    (!(cave_info[y][xx] & (CAVE_WALL)) &&
-							      (cave_info[y][xx] & (CAVE_GLOW))) ||
+							      (cave_info[y][xx] & (CAVE_GLOW)) &&
+							     !(cave_info2[y][xx] & (CAVE2_MDARK))) ||
 							    (!(cave_info[yy][x] & (CAVE_WALL)) &&
-							      (cave_info[yy][x] & (CAVE_GLOW))))
+							      (cave_info[yy][x] & (CAVE_GLOW)) &&
+							     !(cave_info2[yy][x] & (CAVE2_MDARK))))
 							{
 								/* Mark as seen */
 								info |= (CAVE_SEEN);
@@ -2757,7 +2761,8 @@
 #else /* UPDATE_VIEW_COMPLEX_WALL_ILLUMINATION */
 
 							/* Check for "simple" illumination */
-							if (cave_info[yy][xx] & (CAVE_GLOW))
+							if ((cave_info[yy][xx] & (CAVE_GLOW)) &&
+							    !(cave_info2[yy][xx] & (CAVE2_MDARK)))
 							{
 								/* Mark as seen */
 								info |= (CAVE_SEEN);
@@ -2808,7 +2813,8 @@
 						}
 
 						/* Perma-lit or monster-lit grids */
-						else if ((info & (CAVE_GLOW)) ||
+						else if (((info & (CAVE_GLOW)) &&
+						          !(info2 & (CAVE2_MDARK))) ||
 						         (info2 & (CAVE2_MLIGHT)))
 						{
 							/* Mark as "CAVE_SEEN" */
@@ -2925,8 +2931,8 @@
 		/* Access grid */
 		g = fast_light_g[i];
 
-		/* Clear monster light flag */
-		fast_cave_info2[g] &= ~(CAVE2_MLIGHT);
+		/* Clear monster light and darkness flags */
+		fast_cave_info2[g] &= ~(CAVE2_MLIGHT | CAVE2_MDARK);
 	}
 
 	/* Forget light array */
@@ -2935,6 +2941,55 @@
 
 
 /*
+ * Hold light-affecting monsters, sorted by light priority,
+ * i.e. EMANATE_LIGHT > ABSORB_LIGHT > CARRY_LIGHT.
+ */
+
+typedef struct lighting_info lighting_info;
+
+#define PRIO_EMANATE_LIGHT	3
+#define PRIO_ABSORB_LIGHT	2
+#define PRIO_CARRY_LIGHT	1
+#define PRIO_NONE			0
+
+struct lighting_info
+{
+	byte prio;
+	byte rad;	/* Radius 1 -- 3 */
+	byte fy, fx; /* m_ptr->fy and m_ptr->fx */
+};
+
+
+/*
+ * XXX XXX Personally don't like to have global variables outside of
+ * variable.c...
+ * If sorting severely affects performance, use three queues, one for
+ * each priority, instead.
+ * Grids (== max number of monsters) in radius MAX_SIGHT + 3 == 1505
+ */
+static lighting_info mqueue[VIEW_MAX];
+
+
+/*
+ * A helper function for update_monster_light. Sort the list of monsters
+ * by light priority.
+ */
+static bool ang_sort_light_comp(const void *u, const void *v, int a, int b)
+{
+	lighting_info *who = (lighting_info*)(u);
+
+	lighting_info *l_ptr1 = &who[a];
+	lighting_info *l_ptr2 = &who[b];
+
+	/* Unused parameter */
+	(void)v;
+
+	/* Compare light priority -- in descending order */
+	return (l_ptr1->prio > l_ptr2->prio);
+}
+
+
+/*
  * A helper function for update_monster_light.
  *
  * Determine light radius of given monster race
@@ -2957,11 +3012,60 @@
 		else rad = 3;
 	}
 
+
+	/* ABSORB_LIGHT monsters */
+	else if (r_ptr->flags2 & (RF2_ABSORB_LIGHT))
+	{
+		if (r_ptr->level < 20) rad = 1;
+		else rad = 2;
+	}
 	/* Done */
 	return (rad);
 }
 
 
+/*
+ * A helper function for update_monster_light.
+ *
+ * Determine light kind & priority of given monster race
+ */
+static int monster_light_priority(monster_race *r_ptr)
+{
+	int prio;
+
+	if      (r_ptr->flags2 & (RF2_EMANATE_LIGHT)) prio = PRIO_EMANATE_LIGHT;
+	else if (r_ptr->flags2 & (RF2_ABSORB_LIGHT))  prio = PRIO_ABSORB_LIGHT;
+	else if (r_ptr->flags2 & (RF2_CARRY_LIGHT))   prio = PRIO_CARRY_LIGHT;
+	else                                          prio = PRIO_NONE;
+
+	return (prio);
+}
+
+
+/*
+ * Sorting hook -- Swap function -- see below
+ *
+ * We use "u" to point to array of monster indexes,
+ * and "v" to select the type of sorting to perform.
+ */
+static void ang_sort_light_swap(void *u, void *v, int a, int b)
+{
+	/* Maga-Hack XXX XXX XXX */
+	u32b *who = (u32b*)(u);
+
+	/* Maga-Hack XXX XXX XXX */
+	u32b holder;
+
+	/* Unused parameter */
+	(void)v;
+
+	/* Swap */
+	holder = who[a];
+	who[a] = who[b];
+	who[b] = holder;
+}
+
+
 /* Test if a location (y, x) is both in_bounds and cave_floor_bold */
 #define in_bounds_floor(Y, X) \
 	(in_bounds(Y, X) && cave_floor_bold(Y, X))
@@ -2993,6 +3097,8 @@
 	int fast_temp_n;
 	u16b *fast_temp_g = temp_g;
 
+	int mqueue_n;
+
 	byte *fast_cave_info = &cave_info[0][0];
 	byte *fast_cave_info2 = &cave_info2[0][0];
 
@@ -3000,14 +3106,14 @@
 	/*** Handle special case -- blindness ***/
 	if (p_ptr->blind)
 	{
-		/* Clear all the monster-lit grids */
+		/* Clear all the monster-affected grids */
 		for (i = 0; i < fast_light_n; i++)
 		{
 			/* Access grid */
 			g = fast_light_g[i];
 
-			/* Clear monster light flag */
-			fast_cave_info2[g] &= ~(CAVE2_MLIGHT);
+			/* Clear monster light and darkness flags */
+			fast_cave_info2[g] &= ~(CAVE2_MLIGHT | CAVE2_MDARK);
 
 			/* XXX XXX Square is invisible */
 			fast_cave_info[g] &= ~(CAVE_SEEN);
@@ -3031,16 +3137,39 @@
 		info = fast_cave_info[g];
 		info2 = fast_cave_info2[g];
 
-		/* Remember it by setting the CAVE_TEMP flag */
-		info |= (CAVE_TEMP);
+		/* The grid was lit */
+		if (info2 & (CAVE2_MLIGHT))
+		{
+			/* Remember it by setting the CAVE_TEMP flag */
+			info |= (CAVE_TEMP);
+
+			/* Forget monster light */
+			info2 &= ~(CAVE2_MLIGHT);
 
-		/* Forget monster light */
-		info2 &= ~(CAVE2_MLIGHT);
+			/*
+			 * Unseen unless it's glowing or illuminated by player light
+			 * source
+			 */
+			if (!(info & (CAVE_GLOW)) && !(info2 & (CAVE2_PLIGHT)))
+			{
+				info &= ~(CAVE_SEEN);
+			}
+		}
 
-		/* Unseen unless it's glowing or illuminated by player light source */
-		if (!(info & (CAVE_GLOW)) && !(info2 & (CAVE2_PLIGHT)))
+		/* The grid was darkened */
+		else
 		{
-			info &= ~(CAVE_SEEN);
+			/* Remember it by setting the CAVE2_TEMP flag */
+			info2 |= (CAVE2_TEMP);
+
+			/* Forget monster darkness */
+			info2 &= ~(CAVE2_MDARK);
+
+			/* Seen if it perma-lit or torch-lit */
+			if ((info & (CAVE_GLOW)) || (info2 & (CAVE2_PLIGHT)))
+			{
+				info |= (CAVE_SEEN);
+			}
 		}
 
 		/* Save cave info flags */
@@ -3051,23 +3180,17 @@
 
 	/*** Step 2 -- build list of newly lit grids ***/
 
-	/* Clear the temp list */
-	fast_temp_n = 0;
+	/* Clear the monster queue */
+	mqueue_n = 0;
 
 	/* Loop through monsters, adding newly lit grids to the temp queue */
 	for (i = 1; i < m_max; i++)
 	{
 		monster_type *m_ptr = &m_list[i];
 		monster_race *r_ptr = &r_info[m_ptr->r_idx];
+		lighting_info *l_ptr;
 
-		int rad;
-		int fy, fx;
-
-		/* XXX XXX */
-		byte queue_y[40];
-		byte queue_x[40];
-		int queue_n, q;
-
+		int rad, prio;
 
 		/* Skip dead monsters */
 		if (!m_ptr->r_idx) continue;
@@ -3081,9 +3204,52 @@
 		/* Skip monsters not carrying light sources */
 		if (rad <= 0) continue;
 
-		/* Access the location */
-		fy = m_ptr->fy;
-		fx = m_ptr->fx;
+		/* Get light priority... C doesn't have VALUES... */
+		prio = monster_light_priority(r_ptr);
+
+		/* Current queue slot */
+		l_ptr = &mqueue[mqueue_n++];
+
+		/* Enqueue the monster */
+		l_ptr->prio = prio;
+		l_ptr->rad = rad;
+		l_ptr->fy = m_ptr->fy;
+		l_ptr->fx = m_ptr->fx;
+	}
+
+	/* There are some entries in the queue */
+	if (mqueue_n > 0)
+	{
+		/* Select the sort method */
+		ang_sort_comp = ang_sort_light_comp;
+		ang_sort_swap = ang_sort_light_swap;
+
+		/* Sort monsters by lighting effect priority */
+		ang_sort(mqueue, 0, mqueue_n);
+	}
+
+
+	/* Clear the temp list */
+	fast_temp_n = 0;
+
+	/* Process queued monsters */
+	for (i = 0; i < mqueue_n; i++)
+	{
+		lighting_info *l_ptr;
+		int rad, prio;
+		int fy, fx;
+
+		/* XXX XXX */
+		byte queue_y[40];
+		byte queue_x[40];
+		int queue_n, q;
+
+		/* Retrieve monster light information */
+		l_ptr = &mqueue[i];
+		prio = l_ptr->prio;
+		rad = l_ptr->rad;
+		fy = l_ptr->fy;
+		fx = l_ptr->fx;
 
 		/*
 		 * Because the following sections might look intimidating...
@@ -3301,8 +3467,8 @@
 			/* Reject out-of-bound grids */
 			/* if (!in_bounds(y, x)) continue; */
 
-			/* Already illuminated */
-			if (cave_info2[y][x] & (CAVE2_MLIGHT)) continue;
+			/* Very important -- reject already affected grids */
+			if (cave_info2[y][x] & (CAVE2_MLIGHT | CAVE2_MDARK)) continue;
 
 			/* Access basic flags */
 			info = cave_info[y][x];
@@ -3334,11 +3500,29 @@
 			/* Add the grid to the temporary list */
 			fast_temp_g[fast_temp_n++] = g;
 
-			/* Mark the grid as lit by monster light source */
-			fast_cave_info2[g] |= (CAVE2_MLIGHT);
+			/* Affected by monster light source */
+			if (prio != PRIO_ABSORB_LIGHT)
+			{
+				/* Mark the grid as lit by monster light source */
+				fast_cave_info2[g] |= (CAVE2_MLIGHT);
+
+				/* Mark the grid as seen by the player */
+				fast_cave_info[g] |= (CAVE_SEEN);
+			}
+
+			/* Affected by monster darkness source */
+			else
+			{
+				/* Mark the grid as darkened by monster */
+				fast_cave_info2[g] |= (CAVE2_MDARK);
 
-			/* Mark the grid as seen by the player */
-			fast_cave_info[g] |= (CAVE_SEEN);
+				/* Don't affect torch-lit grids, or it would be too nasty */
+				if (!(fast_cave_info2[g] & (CAVE2_PLIGHT)))
+				{
+					/* Mark the grid as seen by the player */
+					fast_cave_info[g] &= ~(CAVE_SEEN);
+				}
+			}
 		}
 	}
 
@@ -3353,25 +3537,34 @@
 		y = GRID_Y(g);
 		x = GRID_X(g);
 
+		/* Flags */
+		info = fast_cave_info[g];
+		info2 = fast_cave_info2[g];
+
 		/* Monster index */
 		m_idx = cave_m_idx[y][x];
 
-		/* Was lit, is no longer lit */
-		if (!(fast_cave_info2[g] & (CAVE2_MLIGHT)))
+		/* Was affected */
+		if ((info & (CAVE_TEMP)) || (info2 & (CAVE2_TEMP)))
 		{
-			/* Clear the temp flag */
-			fast_cave_info[g] &= ~(CAVE_TEMP);
-
-			/* See if there was a visible monster */
-			if (player_has_los_bold(y, x) && m_idx)
+			/* Is no longer affected */
+			if (!(info2 & (CAVE2_MLIGHT | CAVE2_MDARK)))
 			{
-				/* Hide the monster */
-				update_mon(m_idx, FALSE);
-			}
-			else
-			{
-				/* Redraw */
-				light_spot(y, x);
+				/* Clear the temp flags */
+				fast_cave_info[g] &= ~(CAVE_TEMP);
+				fast_cave_info2[g] &= ~(CAVE2_TEMP);
+
+				/* See if there was a visible monster */
+				if (player_has_los_bold(y, x) && m_idx)
+				{
+					/* Show/Hide the monster */
+					update_mon(m_idx, FALSE);
+				}
+				else
+				{
+					/* Redraw */
+					light_spot(y, x);
+				}
 			}
 		}
 	}
@@ -3382,19 +3575,34 @@
 		/* Access grids */
 		g = fast_temp_g[i];
 
-		/* Retrieve cave info */
+		/* Access cave flags */
 		info = fast_cave_info[g];
+		info2 = fast_cave_info2[g];
 
-		/* No changes in illumination */
-		if (info & (CAVE_TEMP))
+		/* Was lit and now lit */
+		if ((info & (CAVE_TEMP)) && (info2 & (CAVE2_MLIGHT)))
 		{
 			/* Clear the temp flag */
 			fast_cave_info[g] &= ~(CAVE_TEMP);
 		}
 
-		/* Was not lit, is now lit */
+		/* Was darkened and now darkened */
+		else if ((info2 & (CAVE2_TEMP)) && (info2 & (CAVE2_MDARK)))
+		{
+			/* Clear the temp flag */
+			fast_cave_info2[g] &= ~(CAVE2_TEMP);
+		}
+
+		/* Change in illumination / darkening */
 		else
 		{
+			/*
+			 * Need to clear the flags anyway, because a monster-lit grid can
+			 * be monster-darkened or vice versa.
+			 */
+			fast_cave_info[g] &= ~(CAVE_TEMP);
+			fast_cave_info2[g] &= ~(CAVE2_TEMP);
+
 			/* Location */
 			y = GRID_Y(g);
 			x = GRID_X(g);
@@ -3408,7 +3616,7 @@
 			/* See if there is a monster */
 			if (m_idx)
 			{
-				/* Show it */
+				/* Show/Hide it */
 				update_mon(m_idx, FALSE);
 			}
 			else
diff -ur nangband/src/defines.h pelpel/src/defines.h
--- nangband/src/defines.h	Fri Jul 26 23:23:21 2002
+++ pelpel/src/defines.h	Mon Jul 29 12:19:43 2002
@@ -1835,6 +1835,8 @@
 #define CAVE2_TDETECT        0x01     /* trap detection flag */
 #define CAVE2_PLIGHT         0x02     /* Player light */
 #define CAVE2_MLIGHT         0x04     /* Monster light */
+#define CAVE2_MDARK          0x08     /* Monster darkness */
+#define CAVE2_TEMP           0x10     /* Yet another temp flag */
 
 
 
diff -ur nangband/src/melee2.c pelpel/src/melee2.c
--- nangband/src/melee2.c	Sun Jul 28 15:51:44 2002
+++ pelpel/src/melee2.c	Sun Jul 28 23:49:23 2002
@@ -4072,7 +4072,8 @@
 			}
 
 			/* The nearby monster is carrying a light source */
-			if ((r_ptr->flags2 & (RF2_CARRY_LIGHT | RF2_EMANATE_LIGHT)) &&
+			if ((r_ptr->flags2 & (RF2_CARRY_LIGHT | RF2_EMANATE_LIGHT |
+			                      RF2_ABSORB_LIGHT)) &&
 			    (m_ptr->cdis <= MAX_SIGHT + 3))
 			{
 				/* Update monster light */
diff -ur nangband/src/monster2.c pelpel/src/monster2.c
--- nangband/src/monster2.c	Fri Jul 26 23:18:03 2002
+++ pelpel/src/monster2.c	Sun Jul 28 23:48:40 2002
@@ -40,7 +40,8 @@
 	if (r_ptr->flags2 & (RF2_MULTIPLY)) num_repro--;
 
 	/* Hack -- Notice change in lighting effects */
-	if (r_ptr->flags2 & (RF2_ABSORB_LIGHT|RF2_EMANATE_LIGHT|RF2_CARRY_LIGHT))
+	if (r_ptr->flags2 & (RF2_EMANATE_LIGHT | RF2_CARRY_LIGHT |
+	                     RF2_ABSORB_LIGHT))
 	{
 		/* Update monster light later */
 		p_ptr->update |= (PU_UPDATE_LIGHT);
